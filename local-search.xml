<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文章</title>
    <link href="/lulalula/2023/11/09/%E6%96%87%E7%AB%A0/"/>
    <url>/lulalula/2023/11/09/%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/lulalula/2023/11/09/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/lulalula/2023/11/09/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<ul><li>Java动态代理分为 JDK代理（接口）和Cglib代理（子类继承）。JDK动态代理时，代理对象执行方法时，一定要经过 InvocationHandler类的 invoke 方法</li></ul><p><img src="http://yolo-img.oss-cn-beijing.aliyuncs.com/img/image-20231109170601601.png" alt="image-20231109170601601"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/lulalula/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/lulalula/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="算法笔记（LeetCode）"><a href="#算法笔记（LeetCode）" class="headerlink" title="算法笔记（LeetCode）"></a>算法笔记（LeetCode）</h1><h2 id="算法知识："><a href="#算法知识：" class="headerlink" title="算法知识："></a>算法知识：</h2><h3 id="1、回溯算法：（递归实现）"><a href="#1、回溯算法：（递归实现）" class="headerlink" title="1、回溯算法：（递归实现）"></a>1、回溯算法：（递归实现）</h3><p>回溯算法是穷举的一种改进，回溯算法依然会列举所有可能的结果（没有剪枝函数的情况下）。</p><p>它是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回到上一步，重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p>回溯算法在包含所有解的解空间树中，采取深度优先的策略，从根节点出发。</p><p>剪枝函数：<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/v2-368ff92d458bc2e3ae6eed63d550d75e_1440w.webp" alt="img" style="zoom:50%;" /></p><p>简单来说，某个节点出现后已经不满足要求，那这个节点和后续的所有子节点都没有必要再探索，此时需要“剪掉”该枝</p><h3 id="2、链表和栈"><a href="#2、链表和栈" class="headerlink" title="2、链表和栈"></a>2、链表和栈</h3><p>链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br>    <br>    ListNode() &#123;&#125;<br><br>    ListNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br><br>    ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123; <span class="hljs-built_in">this</span>.val = val; <span class="hljs-built_in">this</span>.next = next; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在使用链表时，最好加一个pre节点指向头节点</strong></p><p><strong>在连接节点时，要注意改变的是当前指针的next，而不是当前指针，不然只是修改了指针的指向，连接不上</strong></p><p>栈：<br>目前，已经用Deque代替了Stack，原因在于Stack效率低，并且只是简单的栈。而Deque作为万能接口，可以作为栈、队列等，只要程序员想。</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDEzNjI5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>（因为Vector是当初JAVA曾经写得不太行的类，所以Stack也不太行。</p><p>Vector不行是因为效率不太行，很多方法都用了synchronized修饰，虽然线程安全，但是像ArrayDeque,LinkedList这些线程不安全的，在需要安全的时候也可以用Collections.synchronizedCollection()转化成线程安全的，所以Vector就没什么用处了）</p><p>Deque常用的方法：</p><p>​当栈用：push()、pop()、peek()等，peek()函数是用来取栈顶元素的值，但不弹出。</p><p>​当队列用：入队offer()、出队poll()</p><h3 id="3、分治思想（自顶向下）"><a href="#3、分治思想（自顶向下）" class="headerlink" title="3、分治思想（自顶向下）"></a>3、分治思想（自顶向下）</h3><p>将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>（1）分治的策略：</p><p>​对于一个规模为n的问题，若该问题可以容易的解决(比如规模n较小)则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，<strong>递归</strong>地解决这些子问题，然后将各个子问题的解合并得到原问题的解。</p><p>​如果原问题可以分割成k个子问题，1&lt;k&lt;&#x3D;n，且这些子问题均可解并且利用这些子问题的解求出原问题的解，那么分治方法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归经常同时应用在算法设计之中。</p><p>（2）使用场景：</p><ul><li>该问题的规模缩小到一定的程度就可以容易的解决。</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。（基础）</li><li>利用该问题分解出的子问题的解可以合并为该问题的解。（关键）</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li></ul><p>（3）可以使用分治的场景：</p><p>二分搜索、大整数乘法、Strassen矩阵乘法、棋盘覆盖、合并排序、快速排序、线性时间选择、最接近点对问题、循环赛日程表、<strong>汉诺塔</strong></p><h3 id="4、动态规划"><a href="#4、动态规划" class="headerlink" title="4、动态规划"></a>4、动态规划</h3><p>动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p><p>（1）动态规划的核心思想：<strong>拆分子问题，记住过往，减少重复计算</strong>。</p><p>（2）动态规划一般是自底向上，从较小问题的解，逐步求出大的问题的解。大的问题的解依靠上一个最优的子问题的解</p><p>（3）动态规划有几个典型特征，<strong>最优子结构、状态转移方程、边界、重叠子问题</strong>。</p><p>​最优子结构：假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质</p><p>可以使用动态规划的情况：<strong>最长递增子序列、最小编辑距离、背包问题、凑零钱问题</strong>等</p><p>相关文章：<a href="https://zhuanlan.zhihu.com/p/365698607">看一遍就理解：动态规划详解 - 知乎 (zhihu.com)</a></p><h2 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h2><h3 id="17、电话号码的字母组合"><a href="#17、电话号码的字母组合" class="headerlink" title="17、电话号码的字母组合"></a>17、电话号码的字母组合</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="/lulalula/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230420135137788.png" alt="image-20230420135137788"></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">eg:<br>输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>看到所有二字，就考虑用回溯算法。##为什么不用嵌套for循环呢，因为字符串的长度不确定，不知道要使用几层for。只能使用递归来实现</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> String[] digit_map = &#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <br>        <span class="hljs-comment">//空字符串时</span><br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        &#125;<br>        backtrace(digits, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>());<br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>    <span class="hljs-comment">//以 2(a,b,c) 3(d,e,f)为例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> index, StringBuilder letter)</span> &#123;<br>        <span class="hljs-comment">//递归第一步：设置出口</span><br>        <span class="hljs-keyword">if</span> (index == str.length()) &#123;<br>            res.add(String.valueOf(letter));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//先拿到digits的第一个字符2, 寻找它的字符映射(a, b, c)</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(index);<br>        <span class="hljs-comment">//ASCII 32减去ASCII 32</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">map_letter</span> <span class="hljs-operator">=</span> digit_map[pos];<br>        <span class="hljs-comment">//拿到映射后，进行遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map_letter.length(); i++) &#123;<br>            letter.append(map_letter.charAt(i));<br>            backtrace(str, index + <span class="hljs-number">1</span>, letter);<br>            <span class="hljs-comment">//相对难点</span><br>            <span class="hljs-comment">//比如letter得到adg之后，下一个遍历的是h，此时就需要先把g先截掉</span><br>            letter.deleteCharAt(letter.length() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优秀解答：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/</a></p><h2 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h2><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>尝试使用一趟扫描实现</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230421103030482.png" alt="image-20230421103030482" style="zoom: 67%;" /><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>不考虑进阶时，最容易想到的是先遍历一遍链表，获得总长度，然后定位到n的位置，进行删除。</p><p><strong>但是</strong>，看到倒数类似的字眼，就考虑可以使用栈，因为栈可以后进的先出。</p><p>如果要求一趟扫描，也就是说不能退回或者重新来一遍，那么栈也就不能用了。此时就要使用<strong>快慢指针</strong>。</p><p><strong>快慢指针在链表相关问题中重要，需要掌握</strong></p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a><strong>题解</strong>：</h4><p>1、使用栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-comment">//使用pre,可以简单实现只有头指针单个节点，n为1时的情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    <span class="hljs-comment">//cur指向pre而不是head，因为在后续出栈时，目标节点上一个节点也要得到才能完成</span><br>    <span class="hljs-comment">//对目标节点的删除。针对的也是只有头节点的情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre;<br><br>    <span class="hljs-comment">//所有节点入栈，包括pre</span><br>        Deque&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;ListNode&gt;();<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(cur);<br>            cur = cur.next;<br>        &#125;<br>    <span class="hljs-comment">//弹出n个节点，最后一个弹出的恰好是目标节点</span><br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n--;<br>            stack.pop();<br>        &#125;<br>    <span class="hljs-comment">//获取目标节点上一个节点</span><br>        cur = stack.peek();<br>    <span class="hljs-comment">//删除</span><br>        cur.next = cur.next.next;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>2、快慢指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    <span class="hljs-comment">//快指针</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">ahead</span> <span class="hljs-operator">=</span> pre;<br>    <span class="hljs-comment">//慢指针</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">after</span> <span class="hljs-operator">=</span> pre;<br>    <span class="hljs-comment">//快指针先走n步</span><br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>    n--;<br>        ahead = ahead.next;<br>    &#125;<br>    <span class="hljs-comment">//快慢指针一块走</span><br>    <span class="hljs-comment">//走到快指针所指节点的下一个节点为null时，慢指针恰好指向目标节点的上一个</span><br>    <span class="hljs-keyword">while</span> (ahead.next != <span class="hljs-literal">null</span>) &#123;<br>        ahead = ahead.next;<br>        after = after.next;<br>    &#125;<br>    <span class="hljs-comment">//删除</span><br>    after.next = after.next.next;<br>    <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span>输出：<span class="hljs-literal">true</span><br>输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span>输出：<span class="hljs-literal">true</span><br>输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a><strong>思路</strong>：</h4><p>左右匹配问题直接用栈，栈使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Deque&lt;&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedList</span>()<br></code></pre></td></tr></table></figure><p>最开始想的是使用双栈，先把所有char入栈A，然后栈A的栈顶开始出栈，与栈B的栈顶元素进行匹配，如果匹配的上，栈B的栈顶元素就出栈，匹配不上则A栈刚刚出栈的元素压入栈B。当栈A为空时，如果栈B为空，则返回true，否则返回false；</p><p>事实证明该想法想的过于复杂，简单问题复杂化。</p><p>******只需要使用一个栈。<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/baa8829ac398e665eb645dca29eadd631e2b337e05022aa5a678e091471a4913-20.gif" alt="20.gif" style="zoom: 50%;" /></p><p>这是一种办法。另一种办法是，当s.charAt（index） 出现左括号时，栈中压入对应的右括号。当出现右括号时，判断当前栈是否为空，为空return false，不为空则判断当前的char与栈顶元素是否相等，不相等就return false；</p><p>当所有元素遍历结束时，栈为空就返回true，否则返回false。</p><p>第二种相对难想到。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h4><p>第一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//map的新用法</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Character,Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character,Character&gt;()&#123;&#123;<br>        put(<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-string">&#x27;&#125;&#x27;</span>); put(<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;]&#x27;</span>); put(<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;)&#x27;</span>); put(<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;?&#x27;</span>);<br>    &#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-comment">//要一一匹配必须是偶数个字符</span><br>        <span class="hljs-keyword">if</span> (s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-comment">//如果是左括号就入栈</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(c)) &#123;<br>                stack.push(c);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果不是左括号，并且此时栈已经为空，也就是类似（）&#123;&#125;&#125; 这种情况，返回false</span><br>                <span class="hljs-comment">//如果栈不为空，但是此时的c和栈顶元素不相等，说明括号匹配不上，返回false</span><br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || c != map.get(stack.peek()))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//匹配的上则出栈，消掉一对括号</span><br>                stack.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最终如果栈为空则true</span><br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        Stack&lt;Character&gt; stack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s.toCharArray())&#123;<br>        <span class="hljs-comment">//如果是左括号，则入栈对应的右括号</span><br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;[&#x27;</span>)<br>                stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-comment">//如果不是左括号，并且此时栈已经为空，也就是类似（）&#123;&#125;&#125; 这种情况，返回false</span><br>            <span class="hljs-comment">//如果栈不为空，但是此时的c和栈顶元素不相等，说明括号匹配不上，返回false</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.empty()||c!=stack.pop())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(stack.empty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="day-3"><a href="#day-3" class="headerlink" title="day 3"></a>day 3</h2><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/merge_ex1.jpg" alt="img" style="zoom: 50%;" /><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br>输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span>输出：<span class="hljs-comment">[]</span><br>输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>最开始看到题目想到的是新建第三个链表L3，然后将值依次填到L3中，应该可以实现。但是编码失败，问题出在函数出入口上，条件和语句顺序处理不好。（也有可能是直接用头节点往下遍历，应该在头节点前加一个pre节点）    <strong>最终实现了！！！ 之前没有实现的原因在于，没设pre节点，导致遍历结束之后多一个空节点</strong></p><p>上述方法的简化是，不用给L3填值，而是直接用一个pre节点，将L1，L2所有节点按照val的大小串起来，最终返回pre.next就行。</p><p>递归也可实现，使用递归时，考虑：递归的出口、子问题是什么。 理解较难，但是理解后就很通透。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>1、迭代：（使用L3）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prehead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//prev节点，使用prev就会简化很多过程</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> prehead;<br>       <span class="hljs-comment">//没必要提前处理l1 或者 l2 为空，因为最终都要处理</span><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//l1的当前val小,则prev直接串上该节点，而不是赋值</span><br>            <span class="hljs-comment">//l1 后移</span><br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                prev.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            <span class="hljs-comment">//prev 后移，后移到哪无所谓</span><br>            prev = prev.next;<br>        &#125;<br>        <span class="hljs-comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br>        prev.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> prehead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、递归</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230422095516053.png" alt="image-20230422095516053" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br><span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            <span class="hljs-comment">//当l1的val小时，该节点就相当于被处理了</span><br>            <span class="hljs-comment">//只需要考虑l1和l2剩下的节点</span><br>            <span class="hljs-comment">//l1.next就是将该节点和剩下的节点连接起来</span><br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-comment">//当之后的所有节点处理完时，需要返回该节点，与之前的所有节点相连</span><br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="day-4"><a href="#day-4" class="headerlink" title="day 4"></a>day 4</h2><h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br>输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span>输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>看到所有可能的组合，考虑使用回溯。这一类问题是在一棵隐式的树上求解。</p><p><strong>注意</strong>：在从空生成一个括号序列的过程中，左括号数量一定是大于等于右括号数量的。否则生成的括号组合是无效的。</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230423095529327.png" alt="image-20230423095529327" style="zoom: 67%;" /><p>可以分析出的结论：</p><p>当前左右括号数量都不为n的时候，才产生分支；<br>产生左分支的时候，只看当前左括号数量是否为n；<br>产生右分支的时候，还受到左分支的限制，右边的括号数量一定得在严格小于左边数量的时候，才可以产生分支；<br>在左边和右边的括号数都等于 n 的时候结算。</p><p>使用到剪枝函数。此思路学习某个答主的，甚妙甚妙。</p><p><a href="https://leetcode.cn/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/">https://leetcode.cn/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/</a></p><p>答主还有其他解法，有空再看。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//看到所有情况的时候，使用回溯</span><br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        dfs(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String cur, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> n, List&lt;String&gt; result)</span> &#123;<br>        <span class="hljs-comment">//设置递归出口</span><br>        <span class="hljs-keyword">if</span> (left == n &amp;&amp; right == n) &#123;<br>            result.add(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//当右括号多于左括号时，剪枝</span><br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">//此时，左括号数量一定大于右括号数量</span><br>        <span class="hljs-comment">//因此可以加上一个左括号，然后继续递归</span><br>        <span class="hljs-keyword">if</span> (left &lt; n) &#123;<br>            dfs(cur + <span class="hljs-string">&quot;(&quot;</span>, left + <span class="hljs-number">1</span>, right, n, result);<br>        &#125;<br><span class="hljs-comment">//右括号数量小于左括号数量</span><br>        <span class="hljs-keyword">if</span> (right &lt; n) &#123;<br>            dfs(cur + <span class="hljs-string">&quot;)&quot;</span>, left, right + <span class="hljs-number">1</span>, n, result);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>递归执行流程见上图箭头指向。</p><h2 id="day-5"><a href="#day-5" class="headerlink" title="day 5"></a>day 5</h2><h3 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a>23. 合并 K 个升序链表</h3><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br><br>输入：lists = []输出：[]<br>输入：lists = [[]]输出：[]<br><br></code></pre></td></tr></table></figure><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>合并读个链表到一个链表中可以这样考虑：</p><p>（1）用一个目标链表和数组中的每一个链表进行合并，每次得到一个升序链表，再用这个升序链表和数组中的下一个合并，最终合并完所有的。这个思路相对简单，两个链表合并day 3也已经做过。（但是效率低）</p><p>（2）对（1）进行优化，分治，两两合并，两两合并…..最终子问题的结果汇总就是题目的解</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png" alt="img" style="zoom: 50%;" /><p>（3）优先队列：简单明了。一个队列中存放数组中每个链表的头节点，根据val的值进行优先级排序，val小的优先级高。每次优先级高的先出队，该节点指针向后移，将该链表的下一个节点放入队列中。</p><p>知道队列为空，所有的链表都处理完成。</p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>1、依次合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    <span class="hljs-keyword">for</span> (ListNode listNode:<br>         lists) &#123;<br>        <span class="hljs-comment">//result和数组中的每一项进行合并</span><br>        result = mergeTwo(result, listNode);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwo</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> l3;<br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>        pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>            pre.next = l1;<br>            l1 = l1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre.next = l2;<br>            l2 = l2.next;<br>        &#125;<br>        pre = pre.next;<br>    &#125;<br>    pre.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>    <span class="hljs-keyword">return</span> l3.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、分治</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br><br>        <span class="hljs-comment">//两两配对进行合并，一直合并到只剩一个ListNode</span><br>        <span class="hljs-comment">//分治自顶向下，一层一层划分</span><br>        <span class="hljs-comment">//因此，从首尾开始，往下分解问题</span><br>        <span class="hljs-comment">//分解到只有单个节点时返回，然后进两两merge</span><br>        <span class="hljs-comment">//子问题的解交给上层，再进行两两merg</span><br>        <span class="hljs-comment">//最终得到问题的解</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lists.length;<br>        <span class="hljs-keyword">return</span> merg(lists, <span class="hljs-number">0</span>, length -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merg</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br><br>        <span class="hljs-comment">//递归出口</span><br>        <span class="hljs-comment">//子问题无法再分</span><br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> lists[l];<br>        &#125;<br>        <span class="hljs-comment">//防止出现[]这种情况，此时length为-1</span><br>        <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> mergeTwo(merg(lists, l, mid), merg(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwo</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> l3;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                pre.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            pre = pre.next;<br>        &#125;<br>        pre.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> l3.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>3、优先队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergKLists</span><span class="hljs-params">(ListNode[] list3)</span> &#123;<br>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> result;<br>    <span class="hljs-comment">//优先队列，根据val的值，val值越小，对应的节点在队列中优先级越高</span><br>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(lists.length, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;ListNode&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(ListNode o1, ListNode o2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (o1.val &lt; o2.val) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1.val == o2.val) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>            &#125;<br>        &#125;);<br><span class="hljs-comment">//所有链表头节点入队</span><br>        <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            queue.add(node);<br>        &#125;<br><span class="hljs-comment">//队列为空代表结束</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-comment">//取出优先级最高的节点接在目标链表尾部，也就是val值最小的那个</span><br>            pre.next = queue.poll();<br>            <span class="hljs-comment">//取到出队节点的下一个节点</span><br>            pre = pre.next;<br>            /<br>            <span class="hljs-keyword">if</span> (pre.next != <span class="hljs-literal">null</span>)&#123;<br>                queue.add(pre.next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.next;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h3><p>arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</p><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><p>首先从后往前找，找出第一组nums[i] &lt; nums[i + 1], 此时，<strong>可以保证nums[i+1]以后是降序排列的。</strong></p><p>找到 nums[i] 后，就要把它往后换，换的那个数要比 nums[i] 大，并且保证它仅仅比 nums[i] 大，比 nums[i] 后边的其他数都小。  这样较为复杂，<strong>换个思路</strong>，    此时 nums[i] 后边已经是降序了，那么从 nums 末尾往前找第一个比nums[i] 大的就行。交换 nums[i] 和这个数， 然后将 i 位置后边的数重新升序排列。  </p><p>如果没找到 nums[i] &lt; nums[i + 1] ，直接将数组倒序输出就行</p><p>图解较为明显：</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150509405.png" alt="image-20230425150509405" style="zoom: 50%;" /><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150532584.png" alt="image-20230425150532584" style="zoom:50%;" /><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150544910.png" alt="image-20230425150544910" style="zoom:50%;" /><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150600018.png" alt="image-20230425150600018" style="zoom:50%;" /><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150611569.png" alt="image-20230425150611569" style="zoom:50%;" /><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//找到nums[i] 小于 nums[i + 1]</span><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>            i--;<br>        &#125;<br>    <span class="hljs-comment">//i &gt;= 0 说明nums[i] &lt; nums[i + 1]存在</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//从末尾找第一个大于nums[i]的数</span><br>            <span class="hljs-comment">//此时可以保证是i以后的最小的满足条件的数</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//交换位置</span><br>            swap(nums, i, j);<br>        &#125;<br>    <span class="hljs-comment">//然后将 i 位置以后的进行升序排序</span><br>    <span class="hljs-comment">//如果此时 i &lt; 0 ，说明nums本来就已经是降序，是最大的组合。</span><br>    <span class="hljs-comment">//因此返回 最小的组合 </span><br>        reverse(nums, i + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br><span class="hljs-comment">//因为已经保证了 i 位置以后是降序，则只需要前后不断交换就行</span><br><span class="hljs-comment">//不需要双层循环</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            swap(nums, left, right);<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h3><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(()&quot;</span>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br><br>输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;)()())&quot;</span>输出：<span class="hljs-number">4</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()()&quot;</span><br><br>输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>出现有关括号这种匹配问题的字眼，考虑用栈。该题就是在  day 2 20.有效的括号  那一题的基础上进行求解。</p><p>也就是说，字符串从前往后遍历，看哪些连着的字串能够匹配起来，匹配成功长度就增加，然后在所有能够匹配的相连子串中，找到最长的那个。</p><p><strong>该题目稍微有点不同的是</strong>，入栈的不是括号而是对应的下标。 这样，就可以相对轻松的计算出能够匹配的子串的长度</p><p>描述一下算法流程：遍历给定的字符串，取每一位上的字符，首先，判断该字符是 ‘(‘ 还是 ‘)’ ，如果是左括号，那就直接下标入栈，因为左括号不可能与前边的字符匹配。如果是右括号，则取出栈顶元素n， 判断 s.charAt(n) 是不是左括号，是就说明这两个匹配成功，成功就出栈，并用当前右括号的下标减去出栈后栈顶元素的数值（也就是没能匹配上的最后一个字符的下标），这样就计算出了当前相连的有效的子串的长度。然后继续往后，如果又有有效的子串，则又计算出它的长度，如果比之前的子串长，则选择这个。   直到遍历完整个字符串。</p><h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longestValidParentheses2</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//定义栈</span><br>Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">//最长有效子串长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//因为如果第一个字符就是 ) ，那么就需要出栈，但是此时栈为空就会出错</span><br>    <span class="hljs-comment">//所以提前入栈一个-1</span><br>   <span class="hljs-comment">//还有一个作用是，当有效的子串在整个字符串首部时</span><br>    <span class="hljs-comment">//需要用最后一个匹配的字符的下标减去栈顶元素，设置为-1才能满足条件</span><br>stack.push(-<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">//遍历每一个字符</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-comment">//如果是左括号说明不满足条件，直接入栈</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.peek();<br>            <span class="hljs-comment">//是右括号时，取出栈顶元素，判断是不是左括号，如果是则匹配成功，计算目前有效的子串的长度</span><br>            <span class="hljs-comment">//判断top等不等于-1的目的是看当前栈是不是为空</span><br><span class="hljs-keyword">if</span> (top != -<span class="hljs-number">1</span> &amp;&amp; s.charAt(top) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>stack.pop();<br>                <span class="hljs-comment">//在所有有效的子串中拿最长的</span><br>length = (i - stack.peek()) &gt; length ? i - stack.peek() : length;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果栈顶元素不是左括号说明匹配失败，则直接入栈</span><br>stack.push(i);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stack.push(i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> length;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h3><p>整数数组 <code>nums</code> 原本按升序排列，数组中的值 <strong>互不相同</strong> 。然后从某个位置阶段，将前边的部分拼接到后边。</p><p>给定一个target，在数组中查找，如果有，返回下标，没有返回-1。时间复杂度要求为 <code>O(log n)</code></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>输出：<span class="hljs-number">4</span><br>输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">3</span>输出：<span class="hljs-number">-1</span><br>输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>升序或者降序的数组中查找一个数，并且要求时间复杂度是<code>O(log n)</code>，就要使用二分查找。</p><p>但是这个题目是升序数组变换得到的，因此需要在二分查找的基础上进行补充修饰。</p><p>考虑，尽管这个数组已经不是升序数组了，但是，如果从中间截断，那么前半段和后半段一定有一个仍然是升序。所以针对前半段是升序和后半段是升序两种情况进行分别处理。 判断前半段是升序的条件是 nums[0] &lt;&#x3D; nums[mid] ，（因为数组中的值互不相同，因此这里的 &#x3D; 是针对只有两个数的情况）。</p><p>判断target是在升序段还是非升序段，如果在升序段直接使用二分查找。如果是在非升序段，则继续二分，看哪段是升序，…..一直到找到target，或者是l  &gt; r，说明没找到。程序结束</p><h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//找到了</span><br>            <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-comment">//前半部分有序的情况</span><br>            <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt;= nums[mid]) &#123;<br>                <span class="hljs-comment">//说明target在有序的前半部分</span><br>                <span class="hljs-comment">//直接使用二分查找</span><br>                <span class="hljs-keyword">if</span> (target &gt;= nums[<span class="hljs-number">0</span>] &amp;&amp; target &lt; nums[mid]) &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//说明target不在前半部分</span><br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//后半部分有序的情况</span><br><span class="hljs-comment">//说明target在后半部分</span><br>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[r]) &#123;     <br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8输出：<span class="hljs-comment">[3,4]</span><br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6输出：<span class="hljs-comment">[-1,-1]</span><br>输入：nums = <span class="hljs-comment">[]</span>, target = 0输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><p>在数组中查找元素并且要求<code>O(log n)</code>的时间复杂度，用二分查找。</p><p>这个题有点变化的就是目标元素可能不止一个。 </p><p>解法一：用二分查找找到一个目标元素，然后向两边扩散，直到找到所有的目标元素，之后返回起始位置和结束位置。 如果target元素很多，甚至于整个数组都是target，则算法退化到 <code>O(n)</code>。</p><p>解法二：用二分查找找到第一个等于目标元素的，再二分查找找到第一个大于目标元素的（也就是找第一个大于等于 target + 1 的），然后就得到了解。（思路容易理解，但是编码不太容易理解）</p><h4 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h4><p>解法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right + left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//找到了任意一个目标元素</span><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                left = mid - <span class="hljs-number">1</span>;<br>                right = mid + <span class="hljs-number">1</span>;<br> <span class="hljs-comment">//向左扩散</span><br>                <span class="hljs-keyword">while</span> (left &gt;=<span class="hljs-number">0</span> &amp;&amp; nums[left] == target) &#123;<br>                    left--;<br>                &#125;<br>                <span class="hljs-comment">//向右扩散</span><br>                <span class="hljs-keyword">while</span> (right &lt;= nums.length - <span class="hljs-number">1</span> &amp;&amp; nums[right] == target) &#123;<br>                    right++;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;++left, --right&#125;;<br>            &#125;<br>            <span class="hljs-comment">//二分查找</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//没找到就返回[-1, -1]</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><p>解法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] searchRange2(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><span class="hljs-comment">//查找大于等于target的第一个元素，如果target存在，返回的就是开始位置，如果不存在，返回的是第一  //个比target大的元素的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> binarySearch(nums, target);<br>    <span class="hljs-comment">//查找大于target的第一个元素（即大于等于 target + 1 的第一个元素）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> (binarySearch(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//如果查到的位置满足左小于等于右，并且开始和结束位置的元素都是target，则证明查找成功，返回</span><br>        <span class="hljs-keyword">if</span> (begin &lt;= end &amp;&amp; nums[begin] == target &amp;&amp; nums[end] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;begin, end&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>                ans = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><h4 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h4><p>所有组合，出现类似字眼考虑回溯。画出解空间树：</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/1598091943-hZjibJ-file_1598091940241.png" alt="img" style="zoom: 25%;" /><p>从根节点出发，将所有小于根节点大小的candidates元素作为子节点，小于就说明该子节点可能是有效解的一部分，将该子节点数值加入res中，此时target变成 target - 该子节点 ，然后以该子节点为根节点重复上述过程，直到叶子节点。达到叶子节点时有两种情况，一种是target恰好为零，说明此时res中的所有节点大小加起来刚好是原始的target，则是一个有效的解。另一种情况是target不为零，则不是有效解，此时需要回到当前叶子节点的父节点，也就是回溯，需要把当前叶子节点从res中删除。深度优先搜索直到拿到所有有效解。</p><p>这里存在一个问题是，[2, 2, 3] 和 [3, 2, 2] 这两条路径是重复的解，需要处理。如何处理呢？ 因为确定子节点的时候是遍历candidates数组，因此在确定该节点的子节点时，要排除掉该节点之前的兄弟节点。（因为之前的兄弟节点在求解过程中，肯定会将该节点作为子节点）</p><h4 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>      List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-comment">//start的作用就是在确定某个节点子节点的时候，排除掉之前出现过的兄弟节点</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      dfs(candidates, target, res, ans, start);<br>      <span class="hljs-keyword">return</span> ans;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, List&lt;Integer&gt; res, List&lt;List&lt;Integer&gt;&gt; ans, <span class="hljs-type">int</span> start)</span> &#123;<br>      <span class="hljs-comment">//递归出口</span><br>      <span class="hljs-comment">//此时target变为了0，说明此路径上的所有节点值加起来为target，是一个有效解</span><br>      <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">//不能使用ans.add(res)</span><br>          <span class="hljs-comment">//因为res是地址，虽然地址一直不会变</span><br>          <span class="hljs-comment">//但是由于回溯的原因，res的内容最终为[]</span><br>          ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(res));<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><span class="hljs-comment">//i = start 就排除了已经处理过的兄弟节点</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; i++) &#123;<br>          <span class="hljs-comment">//满足成为有效解一部分的条件</span><br>          <span class="hljs-keyword">if</span> (candidates[i] &lt;= target) &#123;<br>              res.add(candidates[i]);<br>              dfs(candidates, target - candidates[i], res, ans, i);<br>              <span class="hljs-comment">//回溯</span><br>              res.remove(res.size() - <span class="hljs-number">1</span>);<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br>输入：nums = <span class="hljs-comment">[0,1]</span>输出：<span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><h4 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h4><p>所有可能的全排列，考虑回溯。</p><p>执行过程</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">  递归之前 =&gt; <span class="hljs-comment">[1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 2, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[1, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 3, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[1, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[1]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 1, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[2, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 3, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[2, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[2]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 1, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[3, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 2, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[3, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[3]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>输出 =&gt; <span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>, <span class="hljs-comment">[1, 3, 2]</span>, <span class="hljs-comment">[2, 1, 3]</span>, <span class="hljs-comment">[2, 3, 1]</span>, <span class="hljs-comment">[3, 1, 2]</span>, <span class="hljs-comment">[3, 2, 1]</span>]</span><br></code></pre></td></tr></table></figure><h4 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>      <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      &#125;<br>      List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      dfs(nums, ans, res, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;Integer&gt; ans, List&lt;List&lt;Integer&gt;&gt; res, <span class="hljs-type">boolean</span>[] used, <span class="hljs-type">int</span> size)</span> &#123;<br>      <span class="hljs-comment">//递归出口，size代表遍历解空间树的深度</span><br>      <span class="hljs-keyword">if</span> (size == nums.length) &#123;<br>          res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(ans));<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><span class="hljs-comment">//每次递归i都要从0开始</span><br>      <span class="hljs-comment">//这样才能让nums中的每一个元素都能做ans的头元素</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>          <span class="hljs-comment">//判断当前元素是不是已经被加入了ans中</span><br>          <span class="hljs-comment">//也可以使用used[]数组表示当前元素是否被使用过  来代替 contains</span><br>          <span class="hljs-keyword">if</span> (!ans.contains(nums[i])) &#123;<br>              <span class="hljs-comment">//如果没有则加入，并递归搜索子树</span><br>              ans.add(nums[i]);<br>              dfs(nums, ans, res, used, size + <span class="hljs-number">1</span>);<br>              <span class="hljs-comment">//回溯</span><br>              ans.remove(ans.size() - <span class="hljs-number">1</span>);<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230502101338537.png" alt="image-20230502101338537" style="zoom: 50%;" /><h4 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h4><ol><li>使用一个额外的矩阵进行转换，观察发现第一行变成了最后一列，第二行变成了倒数第二列…..</li><li>先将矩阵上下翻转，然后对角翻转</li></ol><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230502101554478.png" alt="image-20230502101554478" style="zoom:50%;" /><h4 id="题解：-11"><a href="#题解：-11" class="headerlink" title="题解："></a>题解：</h4><p>1、额外矩阵</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>    <span class="hljs-comment">//矩阵的第一行变成了倒数第一列，第二行变成了倒数第二列....</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                res[j][n - i - <span class="hljs-number">1</span>] = matrix[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                matrix[i][j] = res[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>2、原地变换翻转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> matrix.length;<br>    <span class="hljs-comment">//上下翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[length - i - <span class="hljs-number">1</span>][j];<br>                matrix[length - i - <span class="hljs-number">1</span>][j] = temp;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//沿对角线翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; length; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><h4 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h4><p>字母异位体排列虽有不同，但是组成的字符种类（只有小写字母）以及各个字符的数量是完全一致的，因此可以考虑：</p><ol><li>将字符串的所有字符进行排序，这样的话只要时字母异位体，排序后是完全一样的，对应的哈希值也是一样的。这时就可以使用HashMap，将排序后hash值相同的字符串收集在一块。</li><li>统计26个字母每一个的数量，最终所有字母的数量都相等的字符串收集在一起</li></ol><h4 id="题解：-12"><a href="#题解：-12" class="headerlink" title="题解："></a>题解：</h4><p>1、hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br><br>    Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <br>    <span class="hljs-keyword">for</span> (String str :<br>            strs) &#123;<br>        <span class="hljs-comment">//字符串转为char数组</span><br>        <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>        <span class="hljs-comment">//排序</span><br>        Arrays.sort(chars);<br>        <span class="hljs-comment">//重新转为String，因为相同内容的String哈希值相同，而相同内容的char数组哈希值不同</span><br>        s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>        <span class="hljs-comment">//如果此哈希值已经有先例，则拿出对应的List</span><br>        <span class="hljs-comment">//如果没有，即此字符串是第一次，则新建一个ArrayList</span><br>        <span class="hljs-comment">//getsOrDefault方法：如果key有对应的value，则返回，如果没有，则返回设定的默认值</span><br>        List&lt;String&gt; list = map.getOrDefault(s, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-comment">//注意，add的是str，而不是s</span><br>        list.add(str);<br>        <span class="hljs-comment">//key设置的是排序后的zi&#x27;fu&#x27;hcu</span><br>        map.put(s, list);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h2><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><h4 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h4><p>1、暴力解，求出该数组每一个子数组的和，取最大值，但这样时间复杂度太高。</p><p>2、动态规划：</p><p>求解出以数组中每一个元素为结尾的最大连续子数组和dp[i] ，例如 以 -2 为结尾的最大连续子数组 dp[0] 和为 -2 ， 以 1 为结尾的最大连续子数组和 dp[1] 为 1 （因为前边以 -2 为结尾的最大连续子数组和小于0 ）….</p><p>总结规律发现，以 nums[i] 为结尾的最大连续子数组和 dp[i] ，取值取决于以 nums[i-1] 为结尾的最大连续子数组和 dp[i-1] ， 当 dp[i -1] &gt; 0 时，dp[i] &#x3D; dp[i-1] + nums[i] ;  当 dp[i-1] &lt;&#x3D; 0 时， dp[i] &#x3D; nums[i] ;</p><p>这样的话，我们自底向上，保存每一个子问题解的 dp[i] , 最终取其中的最大值，就可以求出问题的解。</p><h4 id="题解：-13"><a href="#题解：-13" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    <span class="hljs-comment">//以第一个元素为结尾的连续子数组的和</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-comment">//这个子问题的解依赖于上一个子问题的解</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? dp[i - <span class="hljs-number">1</span>] + nums[i] : nums[i];<br>            res = dp[i] &gt; res ? dp[i] : res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>优秀解答：<a href="https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/</a></p><h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>如果能到达每一个下标，则该下标之前的所有下标都可以达到。</p><p>从前往后遍历，更新整个数组能达到的最远距离，如果最远距离大于等于数组 length - 1 ，则说明能够到达最后一个下标。</p><h4 id="题解：-14"><a href="#题解：-14" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">//到达的最远位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= len - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">//如果此时遍历到的位置 i 已经大于 该数组能达到的最远距离maxIndex，说明越界了，直接返回//false</span><br>        <span class="hljs-keyword">if</span> (i &gt; maxIndex) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//取最远的距离</span><br>        maxIndex = Math.max(i + nums[i], maxIndex);<br>        <span class="hljs-comment">//如果能够到达的最远位置已经超过了数组结尾，则直接返回true</span><br>        <span class="hljs-comment">//不要该判断也可以，只要 i 能遍历到数组结尾，说明成功了</span><br>        <span class="hljs-comment">//这个判断的作用在于满足条件后直接返回，免去了后续</span><br>        <span class="hljs-keyword">if</span> (maxIndex &gt;= len - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><h4 id="思路：-15"><a href="#思路：-15" class="headerlink" title="思路："></a>思路：</h4><p>首先把intervals数组按每个区间开始的值从小打到排列。新造一个数组 res[][] 用来存放答案，先把第一个区间赋值给 res[0] ，然后，遍历剩下的所有区间。判断每一个区间的开始是否小于等于 res[index] 的结束，是的话说明该区间和 res[index] 区间有重合，则合并，将 res[index] 的结束更新为这两个重合区间的最右边。如果不是则说明不重合，index++，直接将该区间赋值给res[index] </p><h4 id="题解：-15"><a href="#题解：-15" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge1(<span class="hljs-type">int</span>[][] intervals) &#123;<br>    <span class="hljs-comment">//先把intervals排序</span><br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intervals.length][<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//先把第一个区间赋值给 res[0] </span><br>        res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        res[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= intervals.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">//有重合</span><br>            <span class="hljs-keyword">if</span> (res[index][<span class="hljs-number">1</span>] &gt; intervals[i][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-comment">//区间的末尾取最右边</span><br>                res[index][<span class="hljs-number">1</span>] = Math.max(intervals[i][<span class="hljs-number">1</span>], res[index][<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//没重合</span><br>                index++;<br>                res[index][<span class="hljs-number">0</span>] = intervals[i][<span class="hljs-number">0</span>];<br>                res[index][<span class="hljs-number">1</span>] = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//可以使用 res = Arrays.copyOfRange(res, 0, index+1);  替换</span><br>    <span class="hljs-comment">//但是Arrays.copyOfRange费时</span><br>        <span class="hljs-type">int</span>[][] res1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[index + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index + <span class="hljs-number">1</span>; i++) &#123;<br>            res1[i] = res[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res1;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><img src="/lulalula/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/robot_maze.png" alt="img"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h4 id="思路：-16"><a href="#思路：-16" class="headerlink" title="思路："></a>思路：</h4><p>1、动态规划</p><p>从Finish往回看，可以走到Finish的只有上和左两个方块，因此到Finish的路径数量就等于 两个方块的路径和。….所以子问题就分析出来，求到某个块的路径数量，只需要求前置块的路径数量，然后加和。</p><p>边界就是起点。 需要注意的是，最上面和最左边的一行一列，所有块的路径数量都是1。</p><p>2、数学公式</p><p>因为规定了只能往下和往右，因此无论怎样走，向下走的都是3-1格，向右走的都是7-1格，总共是走8格。</p><h1 id="所以只需要在8格中任意选两个向下就可以列出所有结果。-C-m-n-2-m-1"><a href="#所以只需要在8格中任意选两个向下就可以列出所有结果。-C-m-n-2-m-1" class="headerlink" title="所以只需要在8格中任意选两个向下就可以列出所有结果。$$C_{m+n-2}^{m-1}"></a>所以只需要在8格中任意选两个向下就可以列出所有结果。<br>$$<br>C_{m+n-2}^{m-1}</h1><h1 id="m-n−2-m-n−3-⋯n-over-m−1"><a href="#m-n−2-m-n−3-⋯n-over-m−1" class="headerlink" title="{(m+n−2)(m+n−3)⋯n\over(m−1)!}"></a>{(m+n−2)(m+n−3)⋯n<br>\over(m−1)!}</h1><p>{(m−1)!(n−1)!<br>\over(m+n−2)!}<br>$$</p><h4 id="题解：-16"><a href="#题解：-16" class="headerlink" title="题解："></a>题解：</h4><p>1、动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">//最上面一行</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//最左边一列</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//上面的块和左边的块的路径和为当前块的路径和</span><br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>2、数学公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> n, y = <span class="hljs-number">1</span>; y &lt; m; ++x, ++y) &#123;<br>            ans = ans * x / y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h3><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<strong>说明：</strong>每次只能向下或者向右移动一步。</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/minpath.jpg" alt="img" style="zoom:50%;" /><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><h4 id="思路：-17"><a href="#思路：-17" class="headerlink" title="思路："></a>思路：</h4><p>动态规划</p><h4 id="题解：-17"><a href="#题解：-17" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = grid[i][j];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + grid[i][j];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + grid[i][j];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><h4 id="思路：-18"><a href="#思路：-18" class="headerlink" title="思路："></a>思路：</h4><p>最简单的动态规划问题</p><h4 id="题解：-18"><a href="#题解：-18" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">//简化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            res = p + q;<br>            p = q;<br>            q = res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h3><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><h4 id="思路：-19"><a href="#思路：-19" class="headerlink" title="思路："></a>思路：</h4><p>1、两次遍历，设置有序界限index。第一次将所有的 0 移动到头部，每次移动更新 index的值。第二次将所有的 1 移动到 0 后面。</p><p>2、一次遍历，两个指针。设置指针p0、p1，初始值为0，代表 0 和 1 的放置位置。遍历时，如果 nums[i] 为 0 则与 nums[p0] 交换；如果为1， 则先判断 p1 &gt; p0 是否成立，不成立先令 p1 &#x3D; p0 , 然后交换 nums[i] 和 nums[p1] 。因为如果 p1 &lt;&#x3D; p0 , 说明前边都是 0 ，p1首先需要移动到 0 后面。</p><h4 id="题解：-19"><a href="#题解：-19" class="headerlink" title="题解："></a>题解：</h4><p>1、两次遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//把 0 放在最头部</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index];<br>                nums[index] = nums[i];<br>                nums[i] = temp;<br>                index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 1 放在 0 后面</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index];<br>            nums[index] = nums[i];<br>            nums[i] = temp;<br>            index++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、两个指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>         <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>             nums[i] = nums[p0];<br>             nums[p0++] = temp;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>             <span class="hljs-keyword">if</span> (p1 &lt; p0) &#123;<br>                 p1 = p0;<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                 nums[i] = nums[p1];<br>                 nums[p1++] = temp;<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><h4 id="思路：-20"><a href="#思路：-20" class="headerlink" title="思路："></a>思路：</h4><p>看到 <strong>所有</strong> 这类的字眼，考虑回溯，这个题目需要将解空间树的每一个节点都保存下来。</p><h4 id="题解：-20"><a href="#题解：-20" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//空集</span><br>    res.add(list);<br>    dfs2(res, list, nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;nn<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs2</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">//叶子节点之后就返回</span><br>    <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//每一个节点都要保存</span><br>        list.add(nums[i]);<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(list));<br>        <span class="hljs-comment">//递归该节点的子树</span><br>        dfs(res, list, nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//回溯</span><br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230505174059190.png" alt="image-20230505174059190" style="zoom:50%;" /><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><h4 id="思路：-21"><a href="#思路：-21" class="headerlink" title="思路："></a>思路：</h4><p>深度优先搜索 + 回溯</p><p>先找出 board 中所有跟 word 第一个字符相等的位置，进入深度优先递归搜索环节，每到一个位置，上下左右判断有没有跟 word 下一个字符相等的，有就再搜索，直到搜索的深度等于 word 的长度，说明搜索到了，设置标志位为1 ，不能直接return true ；因为return是给上一层调用者，而不是返回最终结果。   因为题目说字母不能重复使用，因此设置 isUsed 二维数组，为0代表board该位置未使用过。</p><h4 id="题解：-21"><a href="#题解：-21" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> board.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>            <span class="hljs-comment">//每次从头查找isUsed数组都要重新归零</span><br>            <span class="hljs-type">int</span>[][] isUsed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row][col];<br>            <span class="hljs-comment">//找到了word的第一个字符</span><br>            <span class="hljs-keyword">if</span> (word.charAt(<span class="hljs-number">0</span>) == board[i][j]) &#123;<br>                <span class="hljs-comment">//表示该位置已被使用</span><br>                isUsed[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//递归搜索</span><br>                dfs(board, word, i, j, <span class="hljs-number">1</span>, flag, isUsed);<br>                <span class="hljs-comment">//如果 flag[0] 被修改为 1， 说明搜索过程中一定找到过 word</span><br>                <span class="hljs-keyword">if</span> (flag[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] flag, <span class="hljs-type">int</span>[][] isUsed)</span> &#123;<br>    <span class="hljs-comment">//查找的深度等于word的长度，说明找到了</span><br>    <span class="hljs-keyword">if</span> (index == word.length()) &#123;<br>        flag[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//往左走</span><br>    <span class="hljs-comment">//往左走时需要注意：左边还有没有，左边的字符等不等于word的下一个字符，左边的字符有没有被使用过</span><br>    <span class="hljs-comment">//往左往右往上往下这四步可以优化，简化写法和执行流程，但是本人懒得搞了</span><br>    <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; board[i][j - <span class="hljs-number">1</span>] == word.charAt(index) &amp;&amp; isUsed[i][j-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>        isUsed[i][j-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dfs(board, word, i, j - <span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>, flag, isUsed);<br>        <span class="hljs-comment">//回溯时，回溯的位置需要重新标识为未使用</span><br>        isUsed[i][j-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//往右走</span><br>    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= board[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> &amp;&amp; board[i][j + <span class="hljs-number">1</span>] == word.charAt(index) &amp;&amp; isUsed[i][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>        isUsed[i][j+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dfs(board, word, i, j+<span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>, flag, isUsed);<br>        isUsed[i][j+<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//往上走</span><br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; board[i - <span class="hljs-number">1</span>][j] == word.charAt(index) &amp;&amp; isUsed[i-<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>) &#123;<br>        isUsed[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        dfs(board, word, i - <span class="hljs-number">1</span>, j, index + <span class="hljs-number">1</span>, flag, isUsed);<br>        isUsed[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//往下走</span><br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt;= board.length - <span class="hljs-number">1</span> &amp;&amp; board[i + <span class="hljs-number">1</span>][j] == word.charAt(index) &amp;&amp; isUsed[i+<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>) &#123;<br>        isUsed[i+<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        dfs(board, word, i + <span class="hljs-number">1</span>, j, index + <span class="hljs-number">1</span>, flag, isUsed);<br>        isUsed[i+<span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><h4 id="思路：-22"><a href="#思路：-22" class="headerlink" title="思路："></a>思路：</h4><p>二叉树遍历就是递归，先序、中序、后续几乎一样，只是保存值的位置有点区别。</p><h4 id="题解：-22"><a href="#题解：-22" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            search(root, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">(TreeNode node, List&lt;Integer&gt; res)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//遍历左子树</span><br>        search(node.lft, res);<br><span class="hljs-comment">//保存</span><br>        res.add(node.val;<br>        <span class="hljs-comment">//遍历右子树</span><br>        search(node.rght(), res);<br>    &#125;<br>                <br>                <br><span class="hljs-comment">//先序</span><br>        res.add(node.val);<br>       search(node.lft, res);<br>        search(node.rght(), res);<br>                <br><span class="hljs-comment">//后序</span><br><br>       search(node.lft, res);<br>        search(node.rght(), res);<br>        res.add(node.val);<br></code></pre></td></tr></table></figure><h2 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230508112035813.png" alt="image-20230508112035813" style="zoom:50%;" /><h4 id="思路：-23"><a href="#思路：-23" class="headerlink" title="思路："></a>思路：</h4><p>二叉搜索树：从根节点，大的在左子树，小的在右子树。</p><p>n个节点组成二叉搜索树，首先，n个节点每一个都可以作为根节点。当 i 作为根节点时，从1 - （i-1）都在左子树，（i+1） - n 都在右子树。考虑此时的左子树，从 1 - （i-1）都可以作为根节点，依次往下，每层子树的构建过程的一样。最终会到叶子节点，0个左子树，0个右子树。 是一个动态规划问题。子问题的解结合起来构成问题的解。</p><p>设 G(n) 是 n 个节点可以组成的二叉树搜索树的个数。</p><p>设 F(i) 是以 i 为根节点，n个节点可以组成的二叉搜索树的个数。</p><p>可以发现，G(n) &#x3D; F(1) + F(2) + ······ + F(n) </p><p>而 F(i) &#x3D; G(i-1) * G(n-i)          <strong>原因</strong>：以 i 为节点时， 左子树有 i-1 个节点，这 i-1 个节点可以组成 G(i-1) 个二叉搜索树。右子树有 n-i 个节点，这 n-i 个节点可以组成 G(n-i) 个二叉搜索树。因此，以 i 为根节点的二叉搜索树的个数是 左子树个数 乘以 右子树个数</p><p>因此  G(n) &#x3D; G(1-1)G(n-1) + G(2-1)G(n-2) + ······ + G(n-1)G(n-n)</p><p>要求 G(n) 必须先求 G(n-1) G(n-2) ·····G(2) G(1) G(0)</p><p>要求 G(n-1) 必须先求 G(n-2) G(n-3) ······ G(1) G(0)</p><p>······  因此，这是一个动态规划问题，G(0)、G(1) 很明显为 1 (<strong>备注：G(0) 为1是因为左边没有子树也算一种情况</strong>) </p><p>,G(2) 可以由 G(1)、G(0) 求得，G(3) 可以由 G(2)、G(1)、G(0) 求得 ·······</p><h4 id="题解：-23"><a href="#题解：-23" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span>[] G = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>      <span class="hljs-comment">//已知的</span><br>      G[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      G[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//从G(2)开始算起，一直算到G(n),只有G(i-1)知道了，才能求解G(i)</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>              G[i] += G[j - <span class="hljs-number">1</span>] * G[i - j];<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> G[n];<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><h4 id="思路：-24"><a href="#思路：-24" class="headerlink" title="思路："></a>思路：</h4><p>1、广度优先遍历 BFS，使用队列，每一层从左到右入队，出队时下面一层又入队。</p><p>2、使用map，dep记录当前节点所处的深度，遍历所有节点，同一深度的所有节点使用 map.put(dep, list) 加到同一个List中。最后，拿出map中所有的key。</p><h4 id="题解：-24"><a href="#题解：-24" class="headerlink" title="题解："></a>题解：</h4><p>1、BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-comment">//广度优先遍历 -&gt; 使用队列</span><br>       List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>       queue.offer(root);<br>       <span class="hljs-comment">//队列不为空就一直出队</span><br>       <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>           List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           <span class="hljs-comment">//队列中当前的节点数</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>           <span class="hljs-comment">//这些节点都位于同一层</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>               list.add(node.getVal());<br>               <span class="hljs-keyword">if</span> (node.getLeft() != <span class="hljs-literal">null</span>) &#123;<br>                   queue.offer(node.getLeft());<br>               &#125;<br>               <span class="hljs-keyword">if</span> (node.getRight() != <span class="hljs-literal">null</span>) &#123;<br>                   queue.offer(node.getRight());<br>               &#125;<br>           &#125;<br>           res.add(list);<br>       &#125;<br>       <br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure><p>2、记录深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      dfs(root, map, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">for</span> (List&lt;Integer&gt; value : map.values()) &#123;<br>          res.add(value);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, Map&lt;Integer, List&lt;Integer&gt;&gt; map, <span class="hljs-type">int</span> dep)</span> &#123;<br>      <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//深度增加</span><br>      dep++;<br><span class="hljs-comment">//当前深度对应的list,如果没有就新建一个</span><br>      List&lt;Integer&gt; integers = map.getOrDefault(dep, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>      integers.add(node.getVal());<br>      map.put(dep, integers);<br><br>      dfs(node.getLeft(), map, dep);<br>      dfs(node.getRight(), map, dep);<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/lulalula/2023/11/09/%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE/"/>
    <url>/lulalula/2023/11/09/%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h5 id="1、使用-Spring-的好处是什么？"><a href="#1、使用-Spring-的好处是什么？" class="headerlink" title="1、使用 Spring 的好处是什么？"></a>1、使用 Spring 的好处是什么？</h5><p>MyAnswer：</p><p>首先，Spring 是一个开源的轻量型框架，是非侵入式的，可以以很小的代价改造旧的项目。其次，Spring 的生态很好，支持的框架和组件非常丰富。再有，Spring 极大地简化了开发，不用再重复造轮子，开箱即用，拓展性很强。Spring 支持 IOC，极大的降低了耦合度，对象的生命周期和配置都由容器管理。还支持 AOP，将业务逻辑和系统服务分开。Spring 还支持事务操作</p><h5 id="2、什么是AOP？"><a href="#2、什么是AOP？" class="headerlink" title="2、什么是AOP？"></a>2、什么是AOP？</h5><p>AOP（Aspect-Oriented Programming，面向切面编程），是指将与业务逻辑无关，但是被业务逻辑模块共同调用的逻辑和责任进行封装，便于减少代码的重复，降低模块间耦合度。     当需要为分散的对象引入公共行为的时候，使用AOP。</p><h5 id="3、AOP的代理方式有哪几种？"><a href="#3、AOP的代理方式有哪几种？" class="headerlink" title="3、AOP的代理方式有哪几种？"></a>3、AOP的代理方式有哪几种？</h5><p>当被代理对象有实现接口时，使用 JDK 动态代理。没有实现接口时，使用 Cglib 代理</p><h5 id="4、怎样实现动态代理-被代理对象必须实现了某接口"><a href="#4、怎样实现动态代理-被代理对象必须实现了某接口" class="headerlink" title="4、怎样实现动态代理(被代理对象必须实现了某接口)"></a>4、怎样实现动态代理(被代理对象必须实现了某接口)</h5><p>动态代理最核心的是一个接口 （InvocationHandler）和一个方法（ newProxyInstance ）</p><p>代理类首先实现该接口，表明该类是一个动态代理类，重写 invoke 方法，完成代理过程，返回被代理对象方法执行的结果。 </p><p>通过 Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 得到代理对象，代理对象是被代理对象实现的接口类型</p><h5 id="5、AOP的一些基本概念"><a href="#5、AOP的一些基本概念" class="headerlink" title="5、AOP的一些基本概念"></a>5、AOP的一些基本概念</h5><p>目标（Target）：被通知的对象（要增强的目标）</p><p>代理（Proxy）：向目标对象通知以后创建的代理对象</p><p>连接点（JointPoint）：目标对象所属类中，定义的所有方法均为连接点</p><p>切入点（Pointcut）：被切面拦截 &#x2F; 增强的连接点。 切入点一定是连接点，连接点不一定是切入点</p><p>通知（Advice）：增强的逻辑 &#x2F; 代码</p><p>切面（Aspect）：切入点 + 通知</p><p>织入（Weaving）：将通知应用到目标对象，进而生成代理对象的过程动作 </p><h5 id="6、通知（Advice）的类型"><a href="#6、通知（Advice）的类型" class="headerlink" title="6、通知（Advice）的类型"></a>6、通知（Advice）的类型</h5><p>前置通知 Before 、后置通知 After 、返回后通知 After Return 、异常后通知 After Throwing、环绕通知 Around </p><h5 id="7、Bean的生命周期"><a href="#7、Bean的生命周期" class="headerlink" title="7、Bean的生命周期"></a>7、Bean的生命周期</h5><ul><li>实例化</li><li>set 方法属性填充</li><li>如果实现了 Aware 接口，调用相关方法</li><li>如果有和加载这个 Bean 的容器相关的 BeanPostProcessor 接口实现类，则调用 postProcessBeforeInitialization() </li><li><strong>如果实现了 InitializingBean 接口，执行 afterPropertiesSet() 方法</strong></li><li>如果有自定义配置的 init-method 则调用</li><li>调用 postProcessAfterInitialization() </li><li>使用Bean</li><li><strong>Bean销毁时，如果实现了 DisposableBean 接口，则调用 destroy() 方法</strong></li><li>Bean 销毁时，如果有自定义配置的 destroy-method ，则调用</li></ul><h5 id="8、Bean-的作用域"><a href="#8、Bean-的作用域" class="headerlink" title="8、Bean 的作用域"></a>8、Bean 的作用域</h5><ul><li>singleton：唯一的 Bean 实例，如果没有设置懒加载则在创建容器时就创建唯一的 Bean，后续操作都是统一 Bean</li><li>prototype：每次从容器中获取，都会新创建一个 Bean 实例</li><li>request：每次请求新建一个 Bean 实例，在本次请求中都是同一个 Bean。该作用域仅适用于使用 web 的 Spring ApplicationContext 环境</li><li>session：每次会话新建一个 Bean 实例</li><li>application：每个web应用拥有一个 Bean</li></ul><h5 id="9、Spring-中单例-Bean-的线程安全问题"><a href="#9、Spring-中单例-Bean-的线程安全问题" class="headerlink" title="9、Spring 中单例 Bean 的线程安全问题"></a>9、Spring 中单例 Bean 的线程安全问题</h5><p>单例 Bean 分为两种，一种是拥有可变<strong>成员变量</strong>的有状态 Bean，这种单例 Bean 存在线程安全问题。另一种是不拥有可变<strong>成员变量</strong>的无状态 Bean，这种单例 Bean 不存在线程安全问题。</p><p>解决有状态 Bean 的线程安全问题，一是尽量避免使用可变成员变量，二是使用 ThreadLocal 对象，将可变成员变量存入其中</p><h5 id="10、Spring-常见的注入方式"><a href="#10、Spring-常见的注入方式" class="headerlink" title="10、Spring 常见的注入方式"></a>10、Spring 常见的注入方式</h5><ul><li>构造器依赖注入：通过容器触发一个类的构造器来实现，构造器有一系列参数，每个参数代表对其他类的依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FooController</span> &#123;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FooService fooService;<br> <br>  <span class="hljs-comment">//注意，不能有无参构造，如果有的话 SpringBoot 默认使用无参构造，注入为null</span><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FooController</span><span class="hljs-params">(FooService fooService)</span> &#123;<br>      <span class="hljs-built_in">this</span>.fooService = fooService;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Spring 推荐使用构造器依赖注入，原因是：注入的依赖不可变（推荐使用 final 修饰成员变量）、依赖不为空（在实例化对象时，调用它的有参构造进行注入，如果依赖为 null 的话，直接报错）、避免循环依赖，如果存在循环依赖，应用启动时就报错</p><ul><li>setter 方法注入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserService</span><span class="hljs-params">(UserService userService)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userService = userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好处：①如果有注入参数很多时，构造器注入过于臃肿，setter 注入就比较方便</p><p>②能够让类在之后重新配置或者重新注入</p><ul><li>属性 &#x2F; Field 注入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：简单明了、新增依赖十分方便</p><p>缺点：注入为 null 时只能等到使用时报空指针异常才能发现、有可能造成循环依赖</p><h5 id="11、Spring框架用到了哪几种设计模式"><a href="#11、Spring框架用到了哪几种设计模式" class="headerlink" title="11、Spring框架用到了哪几种设计模式"></a>11、Spring框架用到了哪几种设计模式</h5><ul><li>工厂设计模式：Spring 使用工厂模式通过 BeanFactory 创建 Bean 对象</li><li>代理设计模式：Spring AOP 的实现使用了代理模式</li><li>单例设计模式：Spring 中的 Bean 默认都是单例</li><li>模板方法模式：Spring 中 JdbcTemplate 等以 template 结尾的对数据库操作的类使用到了模板模式</li><li>包装器设计模式：项目需要连接很多数据库，每次访问可能是不同的数据库，包装器模式使可以动态的切换不同的数据源</li><li>观察者模式：Spring 事件驱动模型就是很典型的观察者模式</li><li>适配器模式：Spring MVC 中用到了适配器模式进行 Controller 的适配</li></ul><h5 id="12、ApplicationContext-的实现类"><a href="#12、ApplicationContext-的实现类" class="headerlink" title="12、ApplicationContext 的实现类"></a>12、ApplicationContext 的实现类</h5><ul><li>ClassPathXmlApplicationContext：加载类路径下的配置文件，读取其中 bean 的定义</li><li>AnnotationConfigApplicationContext：读取注解信息，创建容器加载 Bean</li><li>FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件</li></ul><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h5 id="1、Mysql架构"><a href="#1、Mysql架构" class="headerlink" title="1、Mysql架构"></a>1、Mysql架构</h5><p>Mysql 分为 Server 层和存储引擎层。所有跨存储引擎的功能都是在 Server 层实现的，存储引擎层负责数据的存储查询等</p><ul><li>Server 层：从上到下依次有 连接器（身份校验、权限查询）、查询缓存（如果是查询语句的话，Mysql8 已经删除）、分析器（语法语义分析）、优化器（执行方案的最优选择，比如选择使用什么索引）、执行器（首先进行权限校验，通过则调用存储引擎的接口，返回接口执行的结果）</li><li>存储引擎层：负责数据的存储查询等，采用可插拔式设计，Mysql 默认的存储引擎为 InnoDB，常见的还有 MyISAM</li></ul><h5 id="2、数据库的三范式"><a href="#2、数据库的三范式" class="headerlink" title="2、数据库的三范式"></a>2、数据库的三范式</h5><ul><li>第一范式：强调列的原子性，即表的每一列都是不可分割的原子数据项</li><li>第二范式：要求实体的属性完全依赖于主关键字（可以是多个属性组合），完全依赖是指不能仅依赖主关键字一部分的属性</li><li>第三范式：任何非主属性不依赖其他非主属性</li></ul><h5 id="3、char-和-varchar-的区别"><a href="#3、char-和-varchar-的区别" class="headerlink" title="3、char 和 varchar 的区别"></a>3、char 和 varchar 的区别</h5><ul><li><p>char 是定长的，对于不定长的数据，char 占用空间。适合存储固定长度的数据，效率高</p></li><li><p>varchar 是不定长的，存储的是所有的数据 + 自身此时的长度（占一个字节）</p></li></ul><h5 id="4、varchar-10-和-varchar-20-的区别"><a href="#4、varchar-10-和-varchar-20-的区别" class="headerlink" title="4、varchar(10) 和 varchar(20) 的区别"></a>4、varchar(10) 和 varchar(20) 的区别</h5><p>在硬盘存储上二者没有任何区别，所占的空间的都是所有数据的总字节长度 + 1，但是有些需要在内存中完成的作业就会有差别，因为在内存中是按照定义时的长度分配空间的，比如说 order by等操作</p><h5 id="5、谈谈你对索引的理解"><a href="#5、谈谈你对索引的理解" class="headerlink" title="5、谈谈你对索引的理解"></a>5、谈谈你对索引的理解</h5><p>索引出现的目的就是提高数据的查询效率，相当于书的目录。索引根据不同的分类标准可以分为很多。按照数据结构可以分为 B+ 树索引、Hash 索引、Full-text 索引，按照物理存储可以分为 聚簇索引和二级索引（辅助索引），按照字段类型可以分为 主键索引、唯一索引、普通索引、前缀索引，按照字段数量可以分为 单列索引和聚合索引；</p><p>索引的存在并不一定带来好处，因为它存在几个问题：</p><ol><li>索引需要占用物理空间</li><li>创建和维护索引需要耗费时间</li><li>降低了增删改的效率，因为进行增删改操作时，B+ 树为了保持索引的有序性，都要进行动态维护</li></ol><p>所以，索引的使用也要根据实际情况来定，不适合创建索引的字段有:</p><ol><li>where 、order by 、group by 中用不到的字段</li><li>经常被修改的字段</li><li>存在大量重复数据的字段</li><li>表数据太少时不适合创建索引</li></ol><p>适合创建索引的情况：</p><ol><li>字段有唯一性限制的</li><li>经常在 where、order by、group by 中出现的字段</li></ol><p>建立索引的原则就是：</p><ol><li>在最频繁使用的、用以缩小查询范围的字段上建立索引</li><li>在最频繁使用的、需要排序的字段上建立索引</li></ol><h5 id="6、为什么InnoDB使用-B-树而不是-B-树"><a href="#6、为什么InnoDB使用-B-树而不是-B-树" class="headerlink" title="6、为什么InnoDB使用 B+ 树而不是 B 树"></a>6、为什么InnoDB使用 B+ 树而不是 B 树</h5><ol><li>B+ 树只有叶子节点存放数据，非叶子节点不存放数据；而 B 树所有节点都存放数据。这样的话，B+ 树的非叶子节点可以存放更多的索引，相比于 B 树 B+ 树就更加“矮胖”，查询时磁盘 I&#x2F;O 的次数就少</li><li>B+ 树的叶子节点使用双向链表相互连接，有利于范围查询；而  B 树要进行范围查询只能遍历所有的节点</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余节点，所有节点的索引子节点都有），这些冗余让 B+ 树在删除、插入时效率更高。而 B 树在删除、插入操作时会发生复杂的树的变化</li></ol><h5 id="7、对聚簇索引的理解"><a href="#7、对聚簇索引的理解" class="headerlink" title="7、对聚簇索引的理解"></a>7、对聚簇索引的理解</h5><p>聚簇索引就是对磁盘上数据重新组织以按一个或多个列的值进行排序的算法。特点是存储数据的顺序和索引一致。一张表只允许且一定有一个聚簇索引。如果有主键则以其为索引键，如果没有主键则以第一个不为 null 的唯一键作为索引键，如果没有，则 InnoDB 自己生成一个隐式自增 id 作为索引键</p><h5 id="8、聚簇索引和非聚簇索引的区别"><a href="#8、聚簇索引和非聚簇索引的区别" class="headerlink" title="8、聚簇索引和非聚簇索引的区别"></a>8、聚簇索引和非聚簇索引的区别</h5><p>聚簇索引的叶子节点存放数据，而非聚簇索引的叶子节点不存放数据，仍然是索引节点，存放的是聚簇索引的索引键</p><h5 id="9、谈谈对-Hash-索引的理解"><a href="#9、谈谈对-Hash-索引的理解" class="headerlink" title="9、谈谈对 Hash 索引的理解"></a>9、谈谈对 Hash 索引的理解</h5><p>Hash 索引能以 O（1）的时间进行查找，但是失去了有序性。无法用于范围查找、部分查找和排序，只支持精确查找。</p><p>InnoDB 对 B+ 树索引进行了优化，当某个索引值被频繁使用时，就在 B+ 树索引之上再建一个 Hash 索引，这样 B+ 索引也就具有了 Hash 索引的快速查找优点</p><h5 id="10、谈谈对覆盖索引的理解"><a href="#10、谈谈对覆盖索引的理解" class="headerlink" title="10、谈谈对覆盖索引的理解"></a>10、谈谈对覆盖索引的理解</h5><p>覆盖索引就是指索要查询的字段数据在辅助索引中直接就可以查到，而不用回表操作，再去聚簇索引中查记录。</p><h5 id="11、怎么直到是否使用到了索引"><a href="#11、怎么直到是否使用到了索引" class="headerlink" title="11、怎么直到是否使用到了索引"></a>11、怎么直到是否使用到了索引</h5><p>使用 explain 命令来查看执行计划，关注 possible_keys（可能用到的索引）、key（经过优化器评估最终使用的索引）、key_len（使用的索引的长度）这几个字段</p><h5 id="12、索引失效的几种情况"><a href="#12、索引失效的几种情况" class="headerlink" title="12、索引失效的几种情况"></a>12、索引失效的几种情况</h5><ol><li>对索引字段进行了表达式计算</li><li>对索引字段使用了函数运算</li><li>索引字段进行了隐式类型转换（字符串与数字比较时，默认会把字符串类型转为数字）</li><li>进行左或者左右模糊查询 like “%aa”  或者 like “%aa%”</li><li>where 语句里使用了 or</li></ol><h5 id="13、查询性能的优化"><a href="#13、查询性能的优化" class="headerlink" title="13、查询性能的优化"></a>13、查询性能的优化</h5><ol><li>减少查询的数据量：只返回必要的列，避免使用 select *；  只返回必要的行，使用 limit   ；缓存重复查询的数据</li><li>减少服务端扫描的行数：最有效的办法是使用索引来覆盖查询，也就是索引覆盖</li></ol><h5 id="14、InnoDB-和-MyISAM-的区别"><a href="#14、InnoDB-和-MyISAM-的区别" class="headerlink" title="14、InnoDB 和 MyISAM 的区别"></a>14、InnoDB 和 MyISAM 的区别</h5><ul><li>InnoDB 支持事务，MyISAM 不支持事务</li><li>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持表级锁</li><li>InnoDB 支持数据库异常崩溃后的安全恢复，依赖于 redo log，MyISAM 不支持</li><li>InnoDB 支持 MVCC，MyISAM 不支持</li><li>InnoDB 支持外键，MyISAM 不支持</li><li>InnoDB 的性能好于 MyISAM</li></ul><h5 id="15、主从复制中涉及的三个线程"><a href="#15、主从复制中涉及的三个线程" class="headerlink" title="15、主从复制中涉及的三个线程"></a>15、主从复制中涉及的三个线程</h5><ul><li>binlog 线程：负责将主服务器上的数据更改写入到二进制日志（binlog）中</li><li>I&#x2F;O 线程：负责从主服务器上读取二进制日志，并写入到从服务器的重放日志（relay log）中</li><li>SQL 线程： 负责读取重放日志，并重放其中的 SQL 语句</li></ul><h5 id="16、请你描述下事务的特性"><a href="#16、请你描述下事务的特性" class="headerlink" title="16、请你描述下事务的特性"></a>16、请你描述下事务的特性</h5><ul><li>原子性（atomicity）：事务中的操作要么全部执行，要么都不执行，发生错误就回滚</li><li>一致性（consistency）：事务执行前后，数据满足<strong>完整性约束</strong>，数据库保持一致性状态。换种说法，事务执行后的结果要与所抽象的客观世界的真实情况保持一致。</li><li>隔离性（isolation）：数据库允许多事务并发执行，在对同一数据进行操作时，多个并发事务应该互不影响，也就是事务之间是隔离的</li><li>持久性（durability）：事务一旦提交，对数据库的修改就是永久的</li></ul><p>原子性通过 undo log（回滚日志）来实现；持久性通过 redo log（重做日志）来实现； 隔离性通过 MVCC 或锁机制来实现；一致性通过 原子性 + 持久性 + 隔离性 来实现</p><h5 id="17、谈谈对-MVCC-的理解"><a href="#17、谈谈对-MVCC-的理解" class="headerlink" title="17、谈谈对 MVCC 的理解"></a>17、谈谈对 MVCC 的理解</h5><p>MVCC（多版本并发控制 multi-version concurrency control），是一种并发控制的方法，基于 隐藏字段 trx_id、roll_pointer + Read View + undo log 来实现。InnoDB 的<strong>可重复读</strong>、<strong>读已提交</strong>隔离级别都是基于 MVCC 实现的。相较于加锁的粗暴操作以及较大的性能影响，MVCC 用更好的方式去处理冲突，能有效提高数据库的并发性能</p><h5 id="18、说一下-MySQL-的表锁和行锁"><a href="#18、说一下-MySQL-的表锁和行锁" class="headerlink" title="18、说一下 MySQL 的表锁和行锁"></a>18、说一下 MySQL 的表锁和行锁</h5><ul><li>表级锁：MySQL 中粒度比较大的一种锁，主要有 表锁、元数据锁、意向锁、AUTO-INC锁，针对的是非索引字段。对当前操作的整张表加锁，实现简单，资源消耗少，加锁快，不会出现死锁。但是触发冲突的概率大，高并发下效率低。表级锁和存储引擎无关。 </li><li>行级锁：MySQL 中粒度最小的锁，主要有 Record Lock、Gap Lock、Next-Key Lock，针对的是索引字段。对表中的行记录加锁。实现较复杂，消耗资源较多，加锁慢，会出现死锁。但是行级锁能大大降低触发冲突的概率，高并发下效率高。行级锁与存储引擎有关，InnoDB 支持行级锁，MyISAM 不支持</li></ul><h5 id="19、MySQL-服务器-CPU-飙升到-500-怎么处理"><a href="#19、MySQL-服务器-CPU-飙升到-500-怎么处理" class="headerlink" title="19、MySQL 服务器 CPU 飙升到 500% 怎么处理"></a>19、MySQL 服务器 CPU 飙升到 500% 怎么处理</h5><p>先使用操作系统的 top 命令查看是不是 mysqld 占用导致的，如果不是，则找出占用高的进程进行相关处理；</p><p>如果是 mysqld 占用导致的，则使用 SHOW PEOCESSLIST 查看 MySQL 正在运行的线程，找出消耗高的 SQL，看看它的执行计划是否准确，索引是否失效，或者其他原因。</p><p>然后 kill 掉这些线程，做出调整，比如 sql 优化、索引优化等，再重新运行。</p><p>如果所有的 SQL 消耗都不高，只是同一时间有大量的 MySQL 连接导致 CPU 飙升，则分析相关原因，同时做出调整。</p><h5 id="20、谈谈你对水平切分和垂直切分的理解"><a href="#20、谈谈你对水平切分和垂直切分的理解" class="headerlink" title="20、谈谈你对水平切分和垂直切分的理解"></a>20、谈谈你对水平切分和垂直切分的理解</h5><ul><li>水平切分是指将同一个表中的记录拆分到多个结构相同的表中，可以将数据分布到集群的不同节点上，从而减小单个数据库的压力</li><li>垂直切分是指将一个表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可将经常使用和不经常使用的切分开</li></ul><h5 id="20、主从同步的延迟原因及解决办法"><a href="#20、主从同步的延迟原因及解决办法" class="headerlink" title="20、主从同步的延迟原因及解决办法"></a>20、主从同步的延迟原因及解决办法</h5><p>从服务器的 SQL 线程是单线程，当主库负载过高，从库读取重放日志，其中需要重放的DML、DDL 操作太多太费时，就会导致 SQL 线程处理不过来，导致延迟出现。</p><p>解决办法：增加从服务器，降低服务器负载； 提升从服务器配置</p><h5 id="21、对数据库读写分离的理解"><a href="#21、对数据库读写分离的理解" class="headerlink" title="21、对数据库读写分离的理解"></a>21、对数据库读写分离的理解</h5><p>读写分离常用代理方式实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作和实时性要求比较高的读操作，从服务器处理读操作；</p><p>读写分离极大的缓解了锁的争用，提升了系统性能，增加了冗余，提高了可用性</p><h5 id="22、MySQL问题排查的手段"><a href="#22、MySQL问题排查的手段" class="headerlink" title="22、MySQL问题排查的手段"></a>22、MySQL问题排查的手段</h5><ul><li>使用 show processlist 命令查看当前的所有连接信息</li><li>使用 explain 命令查看SQL 的执行计划</li><li>开启慢查询日志，查看慢查询的SQL</li></ul><h5 id="23、binlog、undolog、redolog都是干什么的"><a href="#23、binlog、undolog、redolog都是干什么的" class="headerlink" title="23、binlog、undolog、redolog都是干什么的"></a>23、binlog、undolog、redolog都是干什么的</h5><p>binlog：server层实现的，记录所有引擎对数据库的修改，用于事务提交时，是逻辑日志，记录语句的原始逻辑。是可以追加写入的，写到一定大小会创建一个新的文件继续写，不会覆盖。用于读写分离主从复制</p><p>undolog：记录修改前记录，用于事务回滚和MVCC。</p><p>redolog：是 InnoDB 存储引擎独有的，是物理日志，记录的是在具体某个数据页上做了什么修改。是循环写，写满之后会覆盖之前的。用于数据库故障之后的数据恢复。</p><h5 id="24、SQL-和-MySQL-的区别"><a href="#24、SQL-和-MySQL-的区别" class="headerlink" title="24、SQL 和 MySQL 的区别"></a>24、SQL 和 MySQL 的区别</h5><p>SQL 是一种结构化查询语言，用于在数据库上执行各种操作，而MySQL 是一个软件，是一个数据库管理系统，使用 SQL 执行所有数据操作</p><h5 id="25、什么是死锁？如何解决"><a href="#25、什么是死锁？如何解决" class="headerlink" title="25、什么是死锁？如何解决"></a>25、什么是死锁？如何解决</h5><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>官方解答：两个事务都持有对方需要的锁，并且都在等待对方释放锁，自己不会释放锁</p><p>常见的解决死锁的方法：</p><ul><li>设置事务等待锁的超时时间，超过这个时间就回滚，手中的锁就会释放</li><li>开启死锁主动检测，在发现死锁发生时，手动回滚死锁链条中的一个事务</li></ul><h5 id="26、什么是悲观锁和乐观锁？如何实现"><a href="#26、什么是悲观锁和乐观锁？如何实现" class="headerlink" title="26、什么是悲观锁和乐观锁？如何实现"></a>26、什么是悲观锁和乐观锁？如何实现</h5><ul><li>悲观锁：假定一定会发生冲突，屏蔽一切可能违反数据完整性的操作。实现方式：在数据库中使用锁机制</li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。适用于读多写少的场景。实现方式：版本号机制 或 CAS 算法</li></ul><h5 id="27、DROP、DELETE、TRUNCATE"><a href="#27、DROP、DELETE、TRUNCATE" class="headerlink" title="27、DROP、DELETE、TRUNCATE"></a>27、DROP、DELETE、TRUNCATE</h5><p>drop属于 DDL，用来删除表结构，不可回滚。删除速度最快。</p><p>delete属于DML，用来删除表中的记录，表的结构不变。可回滚，速度慢。需要逐行删除</p><p>truncate 属于DDL，不删除表结构，清空表中的所有数据，不可回滚，删除速度快</p><h5 id="28、为什么要分库分表"><a href="#28、为什么要分库分表" class="headerlink" title="28、为什么要分库分表"></a>28、为什么要分库分表</h5><p>随着时间和业务的发展，库中的表会越来越多，表中的数据也会越来越多。相关的数据库操作开销也会越来越大，同时，一台服务器的资源是有限的。所以从 性能和可用性角度考虑，进行数据库拆分有助于提升系统性能。拆分分为分库和分表，分库是将原本一个数据库中的表拆分到不同的数据库中。分表是指将一张表拆分成多张表。</p><h5 id="29、分库分表的问题"><a href="#29、分库分表的问题" class="headerlink" title="29、分库分表的问题"></a>29、分库分表的问题</h5><ul><li>事务问题：同一个数据库的表分在了不同的数据库上，如果单个操作涉及到多个数据库，自带的事务就没办法使用。</li><li>join操作：同一个数据库的表分在了不同的数据库上，join 操作就没法使用。只能手动多次查询进行封装</li><li>自增的主键id：分库分表后，数据遍布在不同的数据库上，自增主键就没法满足生成主键唯一的要求。需要使用分布式id</li></ul><h5 id="30、读写分离的实现方案"><a href="#30、读写分离的实现方案" class="headerlink" title="30、读写分离的实现方案"></a>30、读写分离的实现方案</h5><p>推荐 sharding-jdbc</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h5 id="1、谈下你对redis的了解"><a href="#1、谈下你对redis的了解" class="headerlink" title="1、谈下你对redis的了解"></a>1、谈下你对redis的了解</h5><p>redis 是一种非关系型数据库，是基于内存的键值对数据库，对数据的操作都是在内存中完成，因此读写速度非常快。常用于缓存、消息队列、分布式锁等场景。提供了多种数据类型，比如 String、set、zset、hash、list、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流）。Redis 还支持事务、持久化、多种集群方案、Lua脚本、发布&#x2F;订阅模式、内存淘汰机制、过期删除机制等等</p><h5 id="2、Redis的使用场景"><a href="#2、Redis的使用场景" class="headerlink" title="2、Redis的使用场景"></a>2、Redis的使用场景</h5><ul><li>String：缓存对象、分布式下共享session、分布式锁、常规计数</li><li>Set：聚合计算（并集、差集、交集）场景，比如点赞、共同关注、抽奖活动等</li><li>List：消息队列</li><li>Hash：购物车、缓存对象（一般使用String缓存，Hash比较少用）</li><li>ZSet：排序场景，比如排行榜</li><li>Bitmap：签到统计、判断用户登陆状态</li><li>GEO：滴滴叫车</li><li>Stream：消息队列</li></ul><h5 id="3、Redis的常见功能"><a href="#3、Redis的常见功能" class="headerlink" title="3、Redis的常见功能"></a>3、Redis的常见功能</h5><p>数据持久化、分布式锁的实现、数据缓存、支持事务、支持消息队列</p><h5 id="4、Redis为什么快？为什么单线程还快？"><a href="#4、Redis为什么快？为什么单线程还快？" class="headerlink" title="4、Redis为什么快？为什么单线程还快？"></a>4、Redis为什么快？为什么单线程还快？</h5><ul><li>基于内存，对数据的操作都在内存中，速度快。性能瓶颈不在CPU，而在内存和网络I&#x2F;O，因此单线程不影响性能</li><li>数据结构简单，对数据的操作也简单</li><li>采用单线程，避免了线程切换的开销，避免了线程竞争产生的消耗</li><li>使用多路I&#x2F;O复用，而不是阻塞IO</li></ul><h5 id="5、缓存雪崩、缓存穿透、缓存击穿以及解决方案"><a href="#5、缓存雪崩、缓存穿透、缓存击穿以及解决方案" class="headerlink" title="5、缓存雪崩、缓存穿透、缓存击穿以及解决方案"></a>5、缓存雪崩、缓存穿透、缓存击穿以及解决方案</h5><p><a href="https://xiaolincoding.com/redis/base/redis_interview.html#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">缓存问题</a></p><ul><li>缓存雪崩：大量缓存在同一时间过期，此时有大量的用户请求，在Redis中都无法命中，于是直接请求数据库，从而导致数据库压力骤增。</li></ul><p>解决方案：将缓存失效时间随机打散、设置缓存不过期</p><ul><li>缓存击穿：缓存中的某个热点数据过期了，此时有大量请求访问该热点数据，Redis中无法命中，于是直接请求数据库，导致数据库压力骤增。</li></ul><p>解决方案：互斥锁方案（保证同一时间只有一个业务线程请求缓存）、不给热点数据设置过期时间</p><ul><li>缓存穿透：当发生缓存雪崩和缓存击穿时，一旦缓存恢复相应的数据，数据库压力就可减小，而缓存穿透不同。当大量的请求访问缓存和数据库中都没有的数据时，数据库压力骤增。</li></ul><p>缓存穿透一般是由于误操作（误删除了数据）或者黑客恶意攻击造成的</p><p>解决方案：限制非法请求、设置空值或者默认值（当发现有缓存穿透发生时，针对查询的数据设置空值或默认值）、使用布隆过滤器</p><h5 id="6、怎么保证缓存和数据库的数据的一致性"><a href="#6、怎么保证缓存和数据库的数据的一致性" class="headerlink" title="6、怎么保证缓存和数据库的数据的一致性"></a>6、怎么保证缓存和数据库的数据的一致性</h5><ul><li>设置合理的缓存过期时间，过期后就会请求数据库获取数据</li><li>当数据库发生修改时，更新或删除缓存</li></ul><p>就出现了四种方案：</p><p>先更新数据库，再更新缓存    ；先更新缓存，再更新数据库；   先删除缓存，再更新数据库；   先更新数据库，再删除缓存</p><p><strong>一般选用先更新数据库再删除缓存。这种叫做Cache Aside（旁路缓存）策略，是Redis 和 MySQL 的更新策略</strong></p><img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/1cc7401143e79383ead96582ac11b615.png" alt="图片" style="zoom: 50%;" /><p>可能出现的问题如上，但是，缓存的写入是远远快于数据库写入的，所以上述情况出现的可能性很小。</p><h5 id="7、Redis-的持久化有几种方式"><a href="#7、Redis-的持久化有几种方式" class="headerlink" title="7、Redis 的持久化有几种方式"></a>7、Redis 的持久化有几种方式</h5><ul><li>AOF（Append-only file）：Redis会将收到的每一个写命令都通过 write 函数追加到文件末尾。当Redis重启时，会读取文件，重新执行其中的命令在内存中重建整个数据库的内容。</li><li>RDB（Redis Database）：按照一定的时间周期策略把内存中的数据以快照（snapshot）的形式保存到硬盘的二进制文件中。</li><li>混合持久化：AOF文件前半部分为RDB格式的全量数据，后半部分为AOF格式的增量数据</li></ul><p>AOF和RDB区别：</p><ul><li>AOF比RDB 更新频率高，优先使用AOF</li><li>AOF比RDB更安全，文件也更大，恢复时资源消耗更大，更耗时</li><li>如果两个都配置了则优先加载AOF</li></ul><h5 id="8、Redis的内存淘汰策略有哪些"><a href="#8、Redis的内存淘汰策略有哪些" class="headerlink" title="8、Redis的内存淘汰策略有哪些"></a>8、Redis的内存淘汰策略有哪些</h5><ul><li>不进行数据淘汰的策略：当运行内存大于最大设置值时，暂停服务，直接返回错误</li><li>进行数据淘汰的策略（可分为在 设置了过期时间的数据之间淘汰 和 在所有数据之中淘汰）：<strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；    <strong>volatile-ttl</strong>：优先淘汰更早过期的键值。    <strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；     <strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；                                                                                                 在所有数据范围内进行淘汰：      <strong>allkeys-random</strong>：随机淘汰任意键值;      <strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；      <strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><h5 id="9、Redis过期键的清除"><a href="#9、Redis过期键的清除" class="headerlink" title="9、Redis过期键的清除"></a>9、Redis过期键的清除</h5><p>过期策略主要有三个：</p><ul><li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就立即清除。 优点是清除及时，对内存友好；缺点是会占用大量的CPU资源去处理过期的数据</li><li>惰性过期：只有在访问一个key时，才会判断该 key 是否过期，过期则清除。优点是可以最大化的节省CPU资源；缺点是对内存非常不优化，很久都不访问的过期数据可能一直无法清除</li><li>定期清除：每隔一定的时间，会扫面一定数量的key，并清除其中的过期的key。如果过期的key占比超过一定比例，则继续扫描一定数量的key，直到过期的key占比不超过设定比例或者扫描时间达到了设定上限，则停止清除。</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h5 id="1、OSI-的七层模型分别是什么？各自的功能是什么？"><a href="#1、OSI-的七层模型分别是什么？各自的功能是什么？" class="headerlink" title="1、OSI 的七层模型分别是什么？各自的功能是什么？"></a>1、OSI 的七层模型分别是什么？各自的功能是什么？</h5><p>七层分别是：</p><ul><li>应用层：各种应用软件，包含 Web 应用。<strong>协议有HTTP、FTP、SMTP、DNS等</strong></li><li>表现层：数据处理（编解码、加密解密、压缩解压缩）</li><li>会话层：控制应用程序之间的会话能力。<strong>有安全性协议 SSL（安全套接字层协议）、TLS（安全传输层协议）</strong></li><li>传输层：为两台主机进程之间的通信提供通用的数据传输服务。<strong>协议有 TCP、UDP</strong>。数据为段 segment</li><li>网络层：路由和寻址。如不同设备的数据转发。<strong>协议有ICMP、IGMP、IP</strong>。此时的数据是包 packages</li><li>数据链路层：帧编码和误差纠正控制。定义数据的基本格式，如何传输，如何标识。如网卡 MAC 地址。<strong>协议有ARP（地址解析协议）</strong>。此时的数据是帧 frames</li><li>物理层：底层的数据传输，透明的传输比特流。解决两个硬件之间怎么通信的问题，如网线、网卡等。此时的数据是比特流 bits</li></ul><h5 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h5><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h5 id="1、介绍下Java内存区域"><a href="#1、介绍下Java内存区域" class="headerlink" title="1、介绍下Java内存区域"></a>1、介绍下Java内存区域</h5><p>JDK 1.7之前：</p><p>线程共享的是堆和方法区，堆中有字符串常量池，方法区中是运行时常量池。线程私有的是 本地方法栈、虚拟机栈、程序计数器PC</p><p>JDK1.8 及以后：</p><p>没有了方法区，本地内存中添加了元空间，运行常量池放在其中</p><ul><li>堆：是所有线程共享的一块区域，是Java虚拟机管理的最大的一块空间。堆存在的唯一目的就是存放对象实例，几乎所有的对象实例和数组都在堆上分配内存。但JDK 1.7 开始，有了逃逸分析，如果某些方法的对象引用没有被返回或者未在外面使用，也可以分配在栈上。   堆也是垃圾收集管理的主要区域，因此也被称为 GC 堆。</li><li>方法区：当虚拟机需要使用一个类时，需要读取并解析Class 文件获取相关信息，再将信息存入方法区。方法区会存放已被虚拟机加载的类信息、字段信息、方法信息 等</li><li>虚拟机栈：除了一些本地方法外，其他所有的Java方法调用都是通过虚拟机栈实现的。每一个方法的调用都会有一个对应的栈帧压入栈中，每一个方法结束后都会弹出对应的栈帧。栈帧由 局部变量表、操作数栈、动态链接、方法返回地址构成。</li><li>本地方法栈：本地方法的调用通过本地方法栈实现，也是栈帧的压栈和弹出。栈帧由 操作数栈、局部变量表、动态链接、出口信息构成</li><li>程序计数器PC：是一块比较小的内存区域，可以看作当前线程所执行的字节码的行号指示器。有两个主要作用，一是字节码解释器通过改变PC的值来依次读取指令；二是多线程时，用来记录当前线程执行的位置，在线程切换回来时直到从哪继续执行。</li></ul><h5 id="2、对象创建的过程"><a href="#2、对象创建的过程" class="headerlink" title="2、对象创建的过程"></a>2、对象创建的过程</h5><ul><li>类加载检查：虚拟机在遇到一条 new 指令时，会先看能不能在常量池中找到需要 new 的类的符号引用，并且检查这个类是否已经被加载过、解析和初始化过。如果没有，则执行类加载过程</li><li>分配内存：在类加载检查通过后，就为对象在堆上分配内存，所需的大小在加载时就已经确定。分配内存有两种，一种是 指针碰撞（针对堆内存区域规整，用过的内存在一边，没用过的在另一边，由一个指针分隔），另一种是空闲列表（针对堆内存不规整，在分配时找一块足够大的内存块分配给对象实例，空闲不空闲由一个表来记录）</li><li>初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初设为零值。这样对象的实例字段在不赋初始化值时也能使用</li><li>设置对象头：初始化零值后，虚拟机需要对对象进行必要的设置，将一些信息存放到对象头中，例如这个对象是哪个类的实例、对象的哈希码等</li><li>执行init方法：在虚拟机角度看上述其实已经创建好了一个对象实例，这部是按照程序员的想法对对象进行初始化</li></ul><h5 id="3、对象的访问定位的两种方式"><a href="#3、对象的访问定位的两种方式" class="headerlink" title="3、对象的访问定位的两种方式"></a>3、对象的访问定位的两种方式</h5><ul><li>句柄：引用指向对象的句柄地址，在堆中开辟一块区域叫做句柄池，其中存放对象实例的地址和对象类型数据的地址</li><li>直接指针：引用直接是对象实例的地址</li></ul><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h5 id="4、如何判断对象死亡（不能再被任何途径使用的对象）"><a href="#4、如何判断对象死亡（不能再被任何途径使用的对象）" class="headerlink" title="4、如何判断对象死亡（不能再被任何途径使用的对象）"></a>4、如何判断对象死亡（不能再被任何途径使用的对象）</h5><ul><li>引用计数法：每个对象添加一个引用计数器，有一个地方引用计数器就加一，当为0时代表没有引用，则证明死亡。这种方法实现简单，效率高，但是使用的不多。原因是如果对象之间循环引用，则无法回收</li><li>可达性分析算法：基本思想是通过一系列的称为 GC Roots 的对象作为起点，从这些节点往下开始搜索，所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，就判定它死亡。需要被回收。</li></ul><img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/jvm-gc-roots.png" alt="可达性分析算法" style="zoom:50%;" /><p>这种 6-10都要被回收</p><p>GC Roots如何选？</p><ul><li>虚拟机栈或本地方法栈中引用的对象</li><li>方法区中类静态属性或常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h5 id="5、引用的类型"><a href="#5、引用的类型" class="headerlink" title="5、引用的类型"></a>5、引用的类型</h5><ul><li>强引用：当内存空间不足时，虚拟机宁愿抛出 OutOfMemory 也不随意回收具有强引用的对象</li><li>软引用：如果内存足够，就不会回收，如果内存不够才回收</li><li>弱引用：扫描到就回收</li><li>虚引用：扫描到就回收，并不会决定对象的生命周期。虚引用主要用来跟踪对象被垃圾回收的活动</li></ul><h5 id="6、判断一个类是无用类"><a href="#6、判断一个类是无用类" class="headerlink" title="6、判断一个类是无用类"></a>6、判断一个类是无用类</h5><ul><li>该类的所有实例都被回收了，也就是说Java堆中不存在该类的实例</li><li>加载该类的类加载器 ClassLoader 被回收了</li><li>该类对应的 Class 对象没有在任何地方被引用</li></ul><h5 id="7、垃圾收集算法"><a href="#7、垃圾收集算法" class="headerlink" title="7、垃圾收集算法"></a>7、垃圾收集算法</h5><ul><li>标记清除算法：最基础的收集算法，先标记出所有不需要被回收的对象，标记完成后统一回收没被标记的对象。   <strong>存在的问题</strong>：标记和清除两个操作效率都很低、清除后会产生大量不连续的内存碎片</li></ul><img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/mark-and-sweep-garbage-collection-algorithm.png" alt="标记-清除算法" style="zoom: 67%;" /><ul><li>复制算法：将内存分为大小相同的两块，每次使用其中一块。当这一块使用完了之后，将其中存活的对象复制到另一边，赋值完成后对这一块进行全部清除。    <strong>存在的问题</strong>：可用内存只有一半、对于大对象，复制开销比较大</li></ul><img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/copying-garbage-collection-algorithm.png" alt="复制算法" style="zoom: 67%;" /><ul><li>标记-整理算法：标记过程一样，但是不是标记完就清除，而是先将所有的存活对象移到同一端，然后直接清除掉存活对象边界以外的所有区域      <strong>存在的问题：</strong>效率仍比较低，适合老年代这种回收频率低的场景</li></ul><img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法" style="zoom:67%;" /><ul><li>分代收集算法：根据对象存活周期的不同将内存分为几块。一般将堆分为新生代和老年代，然后根据不同的年代特点选择合适的垃圾收集算法。  比如新生代每次收集都有大量对象死去，那么就采用 标记-复制算法，这样每次只需要复制很少数量的对象，成本比较低。而对于老年代这种存活几率比较高同时回收频率低的，就采用 标记-清除算法或者标记-整理算法。</li></ul><p><em><strong>像 为什么堆要分代 这种问题，就可以从这个方面回答</strong></em></p><h5 id="8、垃圾收集器"><a href="#8、垃圾收集器" class="headerlink" title="8、垃圾收集器"></a>8、垃圾收集器</h5><p>（1）CMS（Concurrent Mark Sweep）：</p><p>使用标记-清除算法，分为四个步骤：</p><ul><li>初始标记：暂停其他所有线程，标记所有与 GC Roots 直接相连的对象，速度很快</li><li>并发标记：同时开启GC 和用户线程，用一个闭包结构去记录可达对象，但是由于用户线程还在不断更新引用，所以并不能保证实时性</li><li>重新标记：暂停其他所有线程。修正并发标记期间用户线程更新的引用，比初始标记时间稍长，但远远短于并发标记</li><li>并发清楚：同时开启用户线程和 GC 线程，对未标记区域进行清除</li></ul><p>优点：并发收集、低停顿          缺点：对CPU资源敏感、无法处理浮动垃圾、会产生大量空间碎片（因为使用的是标记清除）</p><p>（2）G1 （Garbage First）收集器</p><p>一款面向服务器的垃圾收集器，从整体上看基于标记整理，从局部看基于标记复制。可预测停顿的时间。</p><p>分为四个步骤：初始标记、并发标记、最终标记、筛选回收</p><p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的区域（名字的由来）。</p><h5 id="9、类的加载过程"><a href="#9、类的加载过程" class="headerlink" title="9、类的加载过程"></a>9、类的加载过程</h5><p>加载  -&gt;连接&#x2F;链接（包括 验证、准备和解析）-&gt; 初始化  -&gt; 使用  -&gt;   卸载</p><h5 id="10、"><a href="#10、" class="headerlink" title="10、"></a>10、</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/lulalula/2023/11/09/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/"/>
    <url>/lulalula/2023/11/09/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a><a href="https://javaguide.cn/database/character-set.html#%E5%8F%82%E8%80%83">字符集</a></h1><h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="一、Java基础-上"><a href="#一、Java基础-上" class="headerlink" title="一、Java基础-上"></a>一、Java基础-上</h2><h3 id="1、基础概念与常识"><a href="#1、基础概念与常识" class="headerlink" title="1、基础概念与常识"></a>1、基础概念与常识</h3><h4 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h4><p><strong>简单易学、面向对象、平台无关性、支持多线程、编译与解释并存</strong>、可靠性、安全性、支持网络编程</p><p>注：平台无关性目前已经不是Java最大的优势了，因为docker等技术也可以容易的实现跨平台</p><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java虚拟机是运行Java字节码的虚拟机。因为有了字节码和虚拟机，才有了<strong>一次编译随处运行</strong>。</p><h4 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h4><p>JDK（Java Development Kit）是功能齐全的Java SDK（SoftWare Development Kit），提供给开发者使用，能够创建和编译 Java 程序。 包含了JRE，以及 编译 Java 源码的编译器 javac，以及文档注释工具 javadoc，调试器 jdb，反编译工具 javap 等等。</p><p>JRE（Java Runtime Environment）是Java运行时环境，它是运行编译后Java程序所需的所有内容的集合，主要包括 JVM，Java基础类库（Class Library）。仅包含 Java 应用程序的运行时环境和必要的类库。</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jdk-include-jre.png" alt="JDK 包含 JRE" style="zoom: 67%;" /><h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><p>​可以被JVM理解的代码就叫字节码（即.class文件）。它不面向任何特定处理器，只面向虚拟机。Java通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言的可移植性。</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java-code-to-machine-code.png" alt="Java程序转变为机器代码的过程" style="zoom:67%;" /><p>​.java文件首先经过编译器进行编译，得到.class字节码文件，然后.class字节码文件被JVM类加载器加载到内存中，然后通过解释器逐行解释运行。这种逐行解释运行速度较慢。而且有些方法和代码块是经常被调用的（热点代码），所以后面引进了 JIT编译器（just-in-time compilation），而JIT属于运行时编译，当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><p>​                     <img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程" style="zoom: 67%;" /> </p><h4 id="JDK、JRE、JVM关系"><a href="#JDK、JRE、JVM关系" class="headerlink" title="JDK、JRE、JVM关系"></a>JDK、JRE、JVM关系</h4><p><img src="/lulalula/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jdk-jre-jvm-jit.png" alt="JDK、JRE、JVM、JIT 这四者的关系"></p><h4 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h4><p>​编译型语言通过编译器一次性将源代码编译为可被该平台执行的机器代码，执行效率高，但是与开发平台密切相关。开发效率低。如C、C++、Go、Rust</p><p>​解释型语言通过解释器将代码一行一行进行解释运行，执行效率低，但是可移植，平台无关。开发效率高。如python、JavaScript</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/compiled-and-interpreted-languages.png" alt="编译型语言和解释型语言" style="zoom: 67%;" /><p>而Java是编译与解释并存。因为Java程序首先要经过javac进行编译得到 .class字节码文件，然后由解释器 进行逐行解释运行。</p><h3 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h3><h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4><p>a &#x3D; ++b  ：先 b &#x3D; b + 1 然后再 a &#x3D; b</p><p>a &#x3D; b++  ：先 a &#x3D; b，然后再 b &#x3D; b + 1</p><p>自增自减运算并不是原子运算</p><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><ul><li>左移 &lt;&lt;    向左移位，高位丢弃，不溢出情况下相当于 乘 2 </li><li>带符号右移 &gt;&gt;  向右移位，高位用符号位补齐，低位丢弃。相当于原数除以 2</li><li>无符号右移 &gt;&gt;&gt;  向右移位，忽略符号位，高位补0，低位丢弃</li><li><strong>由于float和double比较特殊，因此不能移位操作</strong>，能移位操作的只有int 和 long。</li><li>对于 short、byte、char类型的移位，<strong>移位前都会转为int类型</strong></li><li>因为 int 只有 32位，long只有64位， 因此，在移位时，如果移位位数大于32 或 64 ，就会先进行取余操作。</li></ul><h3 id="3、基本数据类型"><a href="#3、基本数据类型" class="headerlink" title="3、基本数据类型"></a>3、基本数据类型</h3><h4 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h4><p>boolean（理论上只占1位，实际会考虑计算机的高效存储因素）、byte（1个子节）、short、char（两个字节）、int、float（4个字节）、long、double（8个字节）</p><p><strong>Java的基本数据类型所占存储空间大小不会像其他语言随着机器硬件的改变而改变</strong>，因此，这也是Java更具移植性的原因之一。</p><h4 id="byte、char、short-进行-运算和-运算"><a href="#byte、char、short-进行-运算和-运算" class="headerlink" title="byte、char、short 进行 + 运算和 +&#x3D; 运算"></a>byte、char、short 进行 + 运算和 +&#x3D; 运算</h4><p>在进行+运算时，会被强转为int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<span class="hljs-comment">//会报错，128已经超过了byte表示范围</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>a = a + b;    <span class="hljs-comment">//报错，因为 a + b 运算a和b会被强转为int，所以相加结果为int，但是左边的变量a仍为byte</span><br><br>a += b;  <span class="hljs-comment">//正确， += 会将左右两边的都强转</span><br></code></pre></td></tr></table></figure><h4 id="包装类型和基本数据类型的区别"><a href="#包装类型和基本数据类型的区别" class="headerlink" title="包装类型和基本数据类型的区别"></a>包装类型和基本数据类型的区别</h4><p>每种基本数据类型都对应着包装类型</p><ul><li>从用途上：除了定义一些常量和局部变量外，很少使用到基本数据类型。像方法参数、对象属性这些基本都是用包装类型。并且，<strong>基本数据类型不能用于泛型</strong></li><li>从存储方式上：基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被static修饰）存放下Java虚拟机的堆中。包装类属于对象实例，而几乎所有的对象实例都放在堆中。</li><li>占用空间：基本数据类型所占的空间大小远远小于包装类</li><li>默认值：包装类型不赋值就是null，而基本数据类型有初始值不为null。比如 int 类型默认初始值为0；</li></ul><p><strong>注意</strong>：成员变量才有初始值，局部变量不会赋初始值，如果不赋值使用会报错。</p><ul><li>比较方式：对于基本数据类型来说， &#x3D;&#x3D; 比较的就是值想不想同。而对于包装类型来说，比较的是对象的内存空间地址是否相同。因此，如果两个包装类要比较数值是否相同，<strong>需要使用equals</strong>。</li></ul><p>******注意：基本数据类型存放在栈中这个说法是错误的。作为成员变量时，存放在堆中。</p><h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><p>​除了<code>Float</code>、<code>Double</code>两个包装类外，其他的包装类都有缓存。</p><p>​什么是缓存呢？就是说，这些包装类在加载过程中，已经创建了一些对应值的对象，缓存了起来。当下次使用时，如果在范围内则直接调的是缓存中的内容，而不是新创建。如果超过了范围，就需要新创建。</p><p>​<code>Byte</code>、<code>Short</code>、<code>Long</code>、<code>Integer</code>这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据。<code>Character</code>默认创建了数值在 <strong>[0,127]</strong> 范围的缓存数据。<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>​看一下相关源码：</p><p><code>Boolean</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">TRUE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">FALSE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">boolean</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> (b ? TRUE : FALSE);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Integer</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">//IntegerCache是Integer的一个静态内部类</span><br><span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>    <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br><br><span class="hljs-comment">//IntegerCache的其中的静态代码块的重点代码</span><br><span class="hljs-keyword">if</span> (archivedCache == <span class="hljs-literal">null</span> || size &gt; archivedCache.length) &#123;<br>     Integer[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[size];<br>     <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; c.length; i++) &#123;<br>     c[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br>     &#125;<br>     archivedCache = c;<br>&#125;<br></code></pre></td></tr></table></figure><p>举例说明缓存的存在以及超出范围就新建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">222</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">222</span>;<br>System.out.println(i1 == i2);<br><br><span class="hljs-comment">//输出false，因为超出了缓存的范围，需要新建</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br>System.out.println(i1 == i2);<br><br><span class="hljs-comment">//输出true，因为22在范围内，返回的都是缓存中的对象</span><br><br><span class="hljs-type">Float</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">22f</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">22f</span>;<br>System.out.println(i1 == i2);<br><br><span class="hljs-comment">//输出false，因为Float包装类没有缓存</span><br></code></pre></td></tr></table></figure><h4 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h4><p>装箱：将基本数据类型用对应的包装类包装起来</p><p>拆箱：将包装类型转换为基本数据类型</p><p>​举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure><p>自动装箱其实是调用了 包装类的 <code>valueOf()</code>方法，而自动拆箱则是调用了包装类的<code>xxxValue()</code>方法。</p><p>​因此上边的例子实际是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integet.intValue(i);<br></code></pre></td></tr></table></figure><p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><h4 id="浮点数精度丢失问题"><a href="#浮点数精度丢失问题" class="headerlink" title="浮点数精度丢失问题"></a>浮点数精度丢失问题</h4><p>计算机是二进制的，计算机在表示一个数时，需要将它转换为二进制，转换过程中，有可能转换的二进制是无限长的，而存储宽度是有限的，因此存储时只能被截断，这样就导致损失一部分精度。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.9f</span> - <span class="hljs-number">0.8f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.8f</span> - <span class="hljs-number">0.7f</span>;<br>System.out.println(f1);<span class="hljs-comment">//0.099999964</span><br>System.out.println(f2);<span class="hljs-comment">//0.100000024</span><br>System.out.println(f1 == f2);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>要解决这个问题，就可以使用<code>BigDecimal</code>这个类。不会造成精度的损失。</p><h5 id="BigDecimal-的创建"><a href="#BigDecimal-的创建" class="headerlink" title="BigDecimal 的创建"></a>BigDecimal 的创建</h5><p>推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.22222222222222&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">dd</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.2222222</span>);<br></code></pre></td></tr></table></figure><h5 id="BigDecimal的加减乘除"><a href="#BigDecimal的加减乘除" class="headerlink" title="BigDecimal的加减乘除"></a>BigDecimal的加减乘除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.22222222222222&quot;</span>);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.2222222</span>);<br><br>        System.out.println(d1.add(d2));<span class="hljs-comment">//0.44444442222222</span><br>        System.out.println(d1.subtract(d2));<span class="hljs-comment">//2.222222E-8</span><br>        System.out.println(d1.multiply(d2));<span class="hljs-comment">//0.049382711111110617284</span><br>        System.out.println(d1.divide(d2));<span class="hljs-comment">//1.0000001</span><br><br><span class="hljs-comment">//注意：在除运算时，最好使用带三个参数的divide</span><br><span class="hljs-comment">//scale代表保留的位数， roundingMode表示保留规则，包括向上取整、向下取整等</span><br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">divide</span><span class="hljs-params">(BigDecimal divisor, <span class="hljs-type">int</span> scale, RoundingMode roundingMode)</span> &#123;<br>    <span class="hljs-keyword">return</span> divide(divisor, scale, roundingMode.oldMode);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="BigDecimal的大小比较"><a href="#BigDecimal的大小比较" class="headerlink" title="BigDecimal的大小比较"></a>BigDecimal的大小比较</h5><p>最好使用 <code>compareTo()</code> ，不要使用 <code>equals()</code> 。  这是因为 <code>equals()</code> 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 <code>compareTo()</code> 方法比较的时候会忽略精度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br>System.out.println(a.equals(b));<span class="hljs-comment">//false</span><br>System.out.println(a.compareTo(b));<span class="hljs-comment">//0    0代表相等，1代表大于，-1代表小于</span><br></code></pre></td></tr></table></figure><h4 id="超过long整型的数"><a href="#超过long整型的数" class="headerlink" title="超过long整型的数"></a>超过<code>long</code>整型的数</h4><p>64位<code>long</code>是最大的整型，但是也可能超过这个范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>System.out.println(l + <span class="hljs-number">1</span>); <span class="hljs-comment">// -9223372036854775808</span><br>System.out.println(l + <span class="hljs-number">1</span> == Long.MIN_VALUE); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>超过<code>long</code>的就可以用<code>BigInteger</code>表示，<code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h3 id="4、变量"><a href="#4、变量" class="headerlink" title="4、变量"></a>4、变量</h3><h4 id="局部变量和成员变量的区别"><a href="#局部变量和成员变量的区别" class="headerlink" title="局部变量和成员变量的区别"></a>局部变量和成员变量的区别</h4><p><strong>语法形式上</strong>：成员变量是属于类的，而局部变量是方法中或者代码块中定义的变量或是方法的参数。成员变量可以使用<code>public</code>、<code>private</code>、<code>static</code>等修饰符修饰，而局部变量不可以。二者都可以使用final修饰。</p><p><strong>存储方式</strong>：没有被<code>static</code>修饰的成员变量存放在堆中，因为对象就存放在堆中。没有被<code>static</code>修饰的局部变量存放在栈中。被<code>static</code>的修饰的成员变量不属于对象，而属于类，因此类加载时静态成员变量就一块加载了，存放在方法区，被<code>static</code>修饰的局部变量也一样。</p><p><strong>生存时间</strong>：成员变量随着类的创建而存在，随着类的销毁而销毁。局部变量随着方法的调用而自动生成，随着方法的调用结束而结束。</p><p><strong>默认值</strong>：成员变量有默认值（除了被<code>final</code>修饰的成员变量需要自行赋值），局部变量没有默认值。</p><h4 id="字符型常量和字符串常量"><a href="#字符型常量和字符串常量" class="headerlink" title="字符型常量和字符串常量"></a>字符型常量和字符串常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExample</span> &#123;<br>    <span class="hljs-comment">// 字符型常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">LETTER_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>    <span class="hljs-comment">// 字符串常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">GREETING_MESSAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;字符型常量占用的字节数为：&quot;</span>+Character.BYTES);<br>        System.out.println(<span class="hljs-string">&quot;字符串常量占用的字节数为：&quot;</span>+GREETING_MESSAGE.getBytes().length);<br>    &#125;<br>&#125;<br><br>输出：<span class="hljs-number">2</span>   <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p>字符型常量占用两个字节。而字符串常量占若干个，String源码中存放字符串的为<code>byte[] value</code>，因此对于除汉字以外的字符串，每一位占一个子节。<strong>而一个汉字占3个字节</strong></p><p>字符常量相当于一个整型值（ASCII），可以参加表达式运算。而字符串常量代表一个地址值（该字符串在内存中的地址）。</p><h3 id="5、方法"><a href="#5、方法" class="headerlink" title="5、方法"></a>5、方法</h3><h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><p><strong>重载</strong>：发生在同一个类中（子类继承父类的方法也算），<strong>方法名必须相同，参数列表必须不同</strong>。返回值类型和访问修饰符可以不同。</p><p><strong>重写</strong>：子类与父类之间。方法名必须相同，参数列表必须相同。重写方法返回值类型、抛出异常大小必须小于等于父类中被重写方法的。访问修饰符必须大于等于被重写方法的。     总结就是：<strong>两同两小一大</strong></p><p>​这里的返回值类型小是指，如果返回值类型是引用类型，则子类重写方法的返回值一定要是父类原方法的子类或者相同。如果为基本数据类型或者void，则重写方法的返回值类型不能变。</p><p>​如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>private</code>、<code>static</code> 修饰的方法能够被再次声明。  ************重点：判断是不是重写要看父类中的方法是否对子类可见，如果是private，说明子类不可见，则子类就可以重新声明一个。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;bbb&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Person</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>s.eat();<br>&#125;<br><br><span class="hljs-comment">//像这种父类引用指向子类对象时。如果是重写，则编译看左运行看右，如果不是重写，是重新声明，则编译执行都看左。</span><br></code></pre></td></tr></table></figure><h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(String arg1, String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br>注意：可变长参数只能放在参数列表最后。<br></code></pre></td></tr></table></figure><p>可变长参数实际编译后实际是转化为了一个数组</p><h2 id="二、基础知识-中"><a href="#二、基础知识-中" class="headerlink" title="二、基础知识-中"></a>二、基础知识-中</h2><h3 id="1、面向对象基础"><a href="#1、面向对象基础" class="headerlink" title="1、面向对象基础"></a>1、面向对象基础</h3><h4 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h4><ul><li>面向过程是按照解决问题的流程，拆分成一个个方法，通过方法的执行解决问题。</li><li>面向对象是先在问题中抽象出相关对象，然后通过执行对象的方法来解决问题。</li></ul><p><strong>面向对象的优点</strong>：易复用、易扩展、易维护</p><p>​面向过程性能优于面向对象这句话并不准确，性能差异不是来自于语言采用的编程范式，而是来自于执行机制。比如说 <code>C</code> 和 <code>Java</code> , <code>Java</code> 在对象创建上需要花费较多时间，但是 <code>C</code> 在分配内存上也需要花费时间，而且由于 <code>Java</code> 目前在底层编译上优化很大，性能差距并不大。  真正引起差距的是， <code>Java</code> 首先是要编译生成字节码文件，然后字节码文件是逐行解释运行。而 <code>C</code> 是直接编译成机器语言，一次性执行。</p><h4 id="对象引用和对象实体"><a href="#对象引用和对象实体" class="headerlink" title="对象引用和对象实体"></a>对象引用和对象实体</h4><ul><li>一个对象引用可以指向一个或者零个对象实体。</li><li>多个对象引用可以指向一个对象实体。</li></ul><h4 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4><p><strong>封装：</strong> 封装是指将对象的状态信息（即属性）隐藏起来，不允许外部直接访问操作。但是可以提供一些接口（即方法）来操作属性。</p><p><strong>继承</strong>：不同的对象，可能会有一些共同点，比方上男生、女生都首先是人，因此就可以定义一个父类来体现这些共同点。而每一个子类又有各自的特点，比如说男生力气大，女生脾气大等等，就可以在子类中再添加各自的一些属性和方法。</p><p>继承需要注意的是：</p><ul><li>子类继承了父类所有的属性和方法（构造器不可以继承），子类不能选择性的继承，包括<code>private</code>也是继承了的，只不过子类不能访问，只是拥有而已。</li><li>子类拥有自己特有的属性和方法，并且子类可以用自己的方式实现父类中的方法（也就是重写或者重新声明）。</li></ul><p><strong>多态：</strong>顾名思义，表示一个对象有多个状态，具体表现为父类的引用指向子类的实例。</p><p>需要注意的：</p><ul><li>引用类型调用的方法究竟是子类的还是父类的，必须在运行期间才能确定。（因此才有运行看作还是看右）</li><li>引用类型调用的方法父类中一定要有，不能只存在子类中。（因为编译一定是看左的）</li><li>关于究竟执行的是谁的方法，分为两种，一种是该方法是子类继承自父类的并进行了重写，则调用的是子类的方法，即<strong>运行看右</strong>。另一种是该方法子类没有进行重写或者是该方法为 <code>static</code>子类没法进行重写（子类只是重新声明了），则调用的是父类的方法，即<strong>运行看左</strong>。</li></ul><h4 id="抽象类和接口的区别和共同点"><a href="#抽象类和接口的区别和共同点" class="headerlink" title="抽象类和接口的区别和共同点"></a>抽象类和接口的区别和共同点</h4><p>接口：接口中所有的方法都是默认 <code>public abstract</code>，不能有方法体。所有的成员变量都是<code>public static final</code>，必须初始化。在<code>JDK8</code>之后，有了默认方法<code>default</code>和静态方法<code>static</code>，可以有方法体。在<code>JDK9</code>后，方法可以为<code>private</code>，有方法体。</p><p>抽象类：抽象类和普通类的区别就是不能实例化，抽象方法只能在抽象类内，其他没有任何区别。</p><p><strong>相同点</strong>：</p><p>不能实例化、都可以包含抽象方法、都可以有默认方法（default）</p><p><strong>不同点</strong>：</p><ul><li>接口主要是对类的行为进行约束，也就是说，接口是一种规范。实现了哪个接口，就必须符合它的规范。抽象类主要用于代码复用，强调的是所属关系。（抽象类很少用）</li><li>接口是多继承，抽象类单继承</li><li>接口中的成员变量默认是<code>public static final</code>的，不能被修改且必须有初始值。抽象类的成员变量可以是任何类型，默认是<code>default</code>，可以不赋初始值。</li></ul><h4 id="引用拷贝、浅拷贝、深拷贝"><a href="#引用拷贝、浅拷贝、深拷贝" class="headerlink" title="引用拷贝、浅拷贝、深拷贝"></a>引用拷贝、浅拷贝、深拷贝</h4><ul><li>引用拷贝：两个不同的引用指向同一个对象</li><li>浅拷贝：在堆中复制新建了一个对象，但是如果原对象的属性中有引用类型（内部对象），则复制新建的是该引用的地址。也就是说，复制得到的对象和原对象使用的是同一个内部对象。</li><li>深拷贝：内部对象也进行复制新建，复制得到的对象和原对象使用的内部对象不是同一个。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//浅拷贝</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Address) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-keyword">return</span> person;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//深拷贝</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>        person.setAddress(person.getAddress().clone());<br>        <span class="hljs-keyword">return</span> person;<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/lulalula/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/shallow&deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p><h3 id="2、Object类"><a href="#2、Object类" class="headerlink" title="2、Object类"></a>2、Object类</h3><h4 id="Object类的方法（11个）"><a href="#Object类的方法（11个）" class="headerlink" title="Object类的方法（11个）"></a>Object类的方法（11个）</h4><p><code>getClass()</code>:返回当前运行时对象的<code>Class</code>对象</p><p><code>clone()</code>:创建并返回当前对象的一份拷贝（浅拷贝）</p><p><code>equals()</code>:只能用于引用类型，没有重写就是判断两个引用类型是否相等（比较的是地址）</p><p><code>wait()</code>: 有三个  暂停线程的执行。<strong>注意：</strong>这个方法会释放锁，<code>sleep()</code>不会释放锁</p><p><code>notify()</code>:唤醒在此对象监视器（锁）上等待的一个线程</p><p><code>notifyAll()</code>:唤醒所有在此对象监视器上等待的线程</p><p><code>hashCode()</code>:返回对象的哈希码，主要用于散列表中（HashSet、HashMap、HashTable…）</p><p><code>toString()</code>:返回类的名字实例的哈希码的 16 进制的字符串，建议所有的子类都重写</p><p><code>finalize()</code>: 实例被垃圾回收器回收时触发的操作。JDK9以后已经标为 <code>@Deprecated</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="equals-和-的区别"><a href="#equals-和-的区别" class="headerlink" title="equals 和 &#x3D;&#x3D; 的区别"></a>equals 和 &#x3D;&#x3D; 的区别</h4><ul><li>&#x3D;&#x3D; 比较基本数据类型时，比较的是值是否相同。比较引用类型数据时，比较的是地址是否相同</li><li>equals只能用于引用类型数据的比较，没有重写时比较的是地址，等同于&#x3D;&#x3D;。重写则按照自己的意愿。比如 <code>String</code>的equals方法进行了重写，比较的是字符串的值是否相同。</li></ul><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p><h4 id="hashCode-的作用"><a href="#hashCode-的作用" class="headerlink" title="hashCode()的作用"></a>hashCode()的作用</h4><p><code>hashCode()</code>的作用是获取对象的哈希码（int整数），也叫散列码。主要用于散列表的使用（HashSet、HashMap等）。<strong>在其他情况下，哈希码没有任何用。</strong></p><p>​散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong>。</p><p>为什么要有哈希码呢？ 是因为，在散列表中添加对象时，会先计算对象的哈希码，根据此找到放置的位置，并且将此哈希码和其他已经加入对象的哈希码进行比较。如果没有相同的，则说明该对象散列表中还不存在，可以直接加入。如果有相同的，则再用<code>equals()</code>比较两个对象，如果相同，则说明重复了，就不再加入。如果不相等，说明发生了哈希碰撞，也就是不同的对象生成了相同的哈希码，这样的话就重新找其他位置进行插入。</p><p>既然<code>hashCode()</code>、<code>equals()</code>的作用都是比较两个对象是否相等，并且<code>equals()</code>比哈希码还更准确，为什么还要存在<code>hashCode()</code>呢？   </p><p><strong>原因就是：</strong>使用<code>hashCode()</code>的话效率会更高。如果只使用equals，那么需要跟每一个元素进行比较，而使用哈希只需要比较一次（因为只需要一次就能找到是否有相等的，这是散列表的特点），虽然哈希并不准确，但是就算哈希出了问题，那么再调用一次equals就行，这样仍然比全部使用equals效率高得多。</p><h4 id="equals和hashCode为什么要同时重写？"><a href="#equals和hashCode为什么要同时重写？" class="headerlink" title="equals和hashCode为什么要同时重写？"></a>equals和hashCode为什么要同时重写？</h4><ul><li>equals判断相等的哈希码一定相等。哈希码相等的equals比较不一定相等</li></ul><p>原因就是，如果重写了equals而不重写hashCode，那么在比较两个对象时，尽管他们equals比较是相等的，但是由于哈希的原因，在添加到散列表时，会认为是两个不同的对象。</p><p>​比方说，现在散列表中要存Person对象，我们希望存的每一项年龄都是不同的，因此我们重写了equals方法用来比较Person对象的年龄，但是由于仍然是不同的对象，他们的哈希码还是不同的，在添加到散列表中时，尽管年龄相等，equals比较相等，但是哈希码不同。这样就产生了问题。</p><h3 id="3、String"><a href="#3、String" class="headerlink" title="3、String"></a>3、String</h3><p><em><strong>JDK9以后，存储字符串使用byte数组代替了之前的char数组</strong></em></p><h4 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h4><ul><li><code>String</code>是不可变的，表面原因是因为它使用<code>final</code>关键字修饰的<code>byte</code>数组来存储字符串，是一个常量所以不可变。但是有个问题，<code>final</code>对引用类型数据不可变是说指向的内存地址不可变，不是该内存地址里边的数据不可变，因此<code>final</code>只是表面原因。   <strong>深层原因</strong>在于：存储字符串的<code>byte</code>数组不仅是<code>final</code>的，而且还是<code>private</code>的，<code>String</code>这个类也没有提供可以修改数组内容的接口，所以才不可变。同时，<code>String</code>类也是<code>final</code>的，不可以被继承，也消除掉了子类继承后破坏<code>String</code>不可变这一因素。 这才是<code>String</code>不可变的真正原因。</li><li><code>StringBuilder</code>和<code>StringBuffer</code>同继承于抽象类<code>AbstractStringBuilder</code>，而<code>AbstractStringBuilder</code>类中用来存储字符串的<code>byte</code>数组没有用<code>private</code>、<code>final</code>修饰，因此是可变的。</li><li><code>String</code>是不可变的，可以理解为常量，自然就是线程安全的。<code>StringBuffer</code>中的绝大多数方法使用了<code>synchronized</code>关键字修饰，也就是加了同步锁，其余的部分方法没有加同步锁，但是调用这些方法的方法加了同步锁（）。因此<code>StringBuffer</code>是线程安全的。而<code>StringBuilder</code>的方法没有加同步锁，不是线程安全的。<img src="/lulalula/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230515150901846.png" alt="image-20230515150901846"></li><li>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h4 id="字符串拼接用”-”还是StringBuilder？"><a href="#字符串拼接用”-”还是StringBuilder？" class="headerlink" title="字符串拼接用”+”还是StringBuilder？"></a>字符串拼接用”+”还是StringBuilder？</h4><p><em>JDK9以前：</em></p><p>​使用 <strong>+</strong> 号拼接字符串底层，是新建一个<code>StringBuilder</code>对象，调用该对象的<code>append()</code>方法进行，拼接完成后调用<code>toString()</code>方法得到一个<code>String</code>对象。并且，如果是在循环中拼接字符串，每循环一次就会新建一个<code>StringBuilder</code>对象，之前新建的不会复用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    s += arr[i];<br>&#125;<br>System.out.println(s);<br></code></pre></td></tr></table></figure><p>​对应的字节码：</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20220422161320823.png" alt="img" style="zoom: 50%;" /><p><em>JDK9及以后：</em></p><p>​字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。这个改进是 JDK9 的 JEP 280 提出的，这也意味着 JDK 9 之后，可以放心使用“+” 进行字符串拼接了。</p><p>​</p><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>JVM为了提升性能和减少内存消耗，专门针对字符串开辟了一块区域，叫做字符串常量池。JDK7以前，字符串常量池放在持久代PermGen中，<u>由于持久代垃圾回收GC效率太低</u>，只有在整堆收集（Full GC）的时候才会被执行GC，导致大量等待被回收的字符串对象得不到回收，因此，在JDK及以后，将字符串常量池移动到了堆中。</p><p>字符串新建时的过程：</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/u=2116635709,3666027563&fm=253&fmt=auto&app=138&f=JPEG.jpeg" alt="img" style="zoom:67%;" /><p><strong>注意：</strong>字符串常量池中的是对象以及对象的引用（也有说只存的是引用）。</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/07a5bac4ce1743bcb6f856c903eb20b4.png" alt="img" style="zoom: 50%;" /><h4 id="String的intern-方法"><a href="#String的intern-方法" class="headerlink" title="String的intern()方法"></a>String的<code>intern()</code>方法</h4><p><code>String</code>的<code>intern()</code>方法，是一个本地native方法，作用是将指定字符串对象的引用保存在常量池中，可以分为两种情况：</p><ul><li>一种是常量池中已经有了该字符串的引用，则直接返回</li><li>一种是没有，则在字符串常量池中创建一个新的引用指向该字符串对象（不同的JDK实现细节不同，有的是直接拷贝一份到字符串常量池，有的是移动到字符串常量池中，堆中的删除）</li></ul><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/8e7ba3fe541d4970a5221097edaed7a0.png" alt="img" style="zoom:50%;" /><h4 id="String类型的变量和常量做“-”运算时发生了什么？"><a href="#String类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String类型的变量和常量做“+”运算时发生了什么？"></a>String类型的变量和常量做“+”运算时发生了什么？</h4><p><a href="https://www.zhihu.com/question/35014775">Java中，关于String类型的变量和常量做“+”运算时发生了什么？ - 知乎 (zhihu.com)</a></p><h2 id="三、基础知识-下"><a href="#三、基础知识-下" class="headerlink" title="三、基础知识-下"></a>三、基础知识-下</h2><h3 id="1、异常"><a href="#1、异常" class="headerlink" title="1、异常"></a>1、异常</h3><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图" style="zoom: 50%;" /><h4 id="Exception和Error"><a href="#Exception和Error" class="headerlink" title="Exception和Error"></a>Exception和Error</h4><p>二者有共同的父类<code>Throwable</code>，<code>Throwable</code>有也仅有两个重要的子类<code>Exception</code>和<code>Error</code>。</p><ul><li><p>Exception：程序本身可以处理的异常，可以使用catch捕获。Exception又分为受检异常和不受检异常，</p></li><li><p>Error：程序无法处理的错误。例如虚拟机错误（Virtual Machine Error）、内存不够错误（OutOfMemoryError）等</p></li></ul><h4 id="受检异常和不受检异常"><a href="#受检异常和不受检异常" class="headerlink" title="受检异常和不受检异常"></a>受检异常和不受检异常</h4><p>​IOException及其子类、SQLException、ClassNotFoundException是受检异常。RuntimeException及其子类全为不受检异常。 受检异常是指必须使用catch捕获或者使用throws抛给上层调用者。如果不这样则报错。</p><p><img src="/lulalula/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/checked-exception.png" alt="img"></p><h4 id="Throwable中的主要方法"><a href="#Throwable中的主要方法" class="headerlink" title="Throwable中的主要方法"></a>Throwable中的主要方法</h4><p><code>String getMessage()</code>: 返回异常发生时的简要描述</p><p><code>String toString()</code>: 返回异常发生时的详细信息</p><p><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</p><h4 id="try-catch-finally需要注意的"><a href="#try-catch-finally需要注意的" class="headerlink" title="try-catch-finally需要注意的"></a>try-catch-finally需要注意的</h4><ul><li>finally中的语句是一定要执行的，除非虚拟机停止运行、程序所在线程死亡、CPU关闭等情况。（也就是还没执行到finally就把电拔了）</li><li>try后如果没有catch，则必须有finally</li><li>如果try中有return语句，则执行return语句时，将return的内容存到一个临时变量中，然后去执行finally中的语句，执行完之后再return</li><li>如果try和finally中都有return语句，则以finally中的为主</li></ul><h4 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h4><p>**<u><em>使用范围</em></u>**：任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象（JDK7之后才能使用）</p><p>对于FileInputStream类似的输入输出流或者其他文件操作类使用完后需要关闭，即调用close方法。之前我们都是在finally语句中close，这并不推荐。</p><p>推荐使用try-with-resources。代码更简单，并且不用手动close</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取文本文件的内容  之前的写法</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D://read.txt&quot;</span>));<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (scanner != <span class="hljs-literal">null</span>) &#123;<br>        scanner.close();<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">//使用try-with-resources</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException fnfe) &#123;<br>    fnfe.printStackTrace();<br>&#125;<br><br><br><br><span class="hljs-comment">//多个资源需要关闭时，用封号隔开</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)));<br>     <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;out.txt&quot;</span>)))) &#123;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">while</span> ((b = bin.read()) != -<span class="hljs-number">1</span>) &#123;<br>        bout.write(b);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异常需要注意的事项"><a href="#异常需要注意的事项" class="headerlink" title="异常需要注意的事项"></a>异常需要注意的事项</h4><ul><li><p>异常不要定义为静态变量，这样会导致栈信息混乱。建议每次都是手动new</p></li><li><p>抛出的异常信息一定要有意义。</p></li><li><p>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</p></li><li><p>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</p></li></ul><h3 id="2、反射"><a href="#2、反射" class="headerlink" title="2、反射"></a>2、反射</h3><p><em><strong><u>类加载过程：</u></strong></em></p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/20170513133210763.png" alt="img" style="zoom:50%;" /><p><strong>（使用反射的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码），Class对象代表着类相关的信息）</strong></p><p>反射机制就是运行时可以分析获取类中的属性方法构造器等的能力。通过反射，可以获得这个类的所有信息和细节，包括私有等。</p><h4 id="使用反射的场景"><a href="#使用反射的场景" class="headerlink" title="使用反射的场景"></a>使用反射的场景</h4><p>Spring、SpringMVC等框架，注解等</p><h4 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h4><ul><li>优点：可以让代码更灵活，提高了程序的灵活性和拓展性，降低耦合。</li><li>缺点：增加了安全风险，比如无视了泛型参数的安全检查（安全检查在编译阶段）。某种意义上说破坏了封装性，同时，性能也要差点，因为  因为是运行时操作，编译器不能做优化；要操作的方法和属性有一个查找过程； invoke方法时，参数需要进行处理，比如说装箱、拆箱等等。</li></ul><h4 id="获取Class对象的四种方法"><a href="#获取Class对象的四种方法" class="headerlink" title="获取Class对象的四种方法"></a>获取Class对象的四种方法</h4><p><u><em><strong>注意：对于一个类只有一个Class对象，不管获取多少次都是同一个</strong></em></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、知道具体的类</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> TargetClass.class;<br><br><span class="hljs-comment">//2、知道对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz2</span> <span class="hljs-operator">=</span> targetClass.getClass();<br><br><span class="hljs-comment">//3、知道类的全路径</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.aqoo.TargetClass&quot;</span>);<br><br><span class="hljs-comment">//4、通过类加载器(通过类加载器将类加载到内存中)</span><br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>classLoader.loadClass(<span class="hljs-string">&quot;com.aqoo.TargetClass&quot;</span>);<br><br><span class="hljs-comment">//只有一个Class对象</span><br><span class="hljs-type">Solution</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> Solution.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz2</span> <span class="hljs-operator">=</span> s.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.aqoo.exer.Solution&quot;</span>);<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz4</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.aqoo.exer.Solution&quot;</span>);<br><br>System.out.println(clazz1 == clazz2 &amp;&amp; clazz2 == clazz3 &amp;&amp; clazz3 == clazz4);   <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="反射的一些基本操作"><a href="#反射的一些基本操作" class="headerlink" title="反射的一些基本操作"></a>反射的一些基本操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造方法相关</span><br><span class="hljs-comment">//clazz.newInstance()已经Deprecated</span><br><span class="hljs-comment">//尽量使用  getConstructor().newInstance();</span><br>clazz.newInstance();        <span class="hljs-comment">//相当于调用无参构造</span><br>clazz.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class);        <span class="hljs-comment">//获取构造方法</span><br>con.newInstance(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>);      <span class="hljs-comment">//实例化对象</span><br>con.getName()     <span class="hljs-comment">//获取构造方法的名称</span><br>con.getParameterCount()       <span class="hljs-comment">//获取构造方法的参数数量</span><br>con.getParameterTypes()       <span class="hljs-comment">//获取构造方法的参数类型</span><br><br><br><span class="hljs-comment">//方法相关</span><br>    <br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;charAt&quot;</span>, <span class="hljs-type">int</span>.class);             <span class="hljs-comment">//获取方法对象</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>) method.invoke(<span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-number">2</span>);      <span class="hljs-comment">//调用方法，相当于&quot;askdhjsad&quot;.charAt(2);</span><br><br><span class="hljs-comment">//属性相关</span><br>getDeclaredField(String name);                 <span class="hljs-comment">//获取域属性对象</span><br>getName()                                      <span class="hljs-comment">//获取属性名称</span><br>getType()                                      <span class="hljs-comment">//获取属性类型的字节码文件</span><br>setAccessible(<span class="hljs-literal">true</span>)                            <span class="hljs-comment">//设置暴力破解，获取对私有属性的使用</span><br>field.set(per, <span class="hljs-string">&quot;huawei&quot;</span>);                      <span class="hljs-comment">//相当于设置 per.name = &quot;huawei&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) field.get(per);          <span class="hljs-comment">//相当于 str = per.name</span><br><br></code></pre></td></tr></table></figure><h3 id="3、注解"><a href="#3、注解" class="headerlink" title="3、注解"></a>3、注解</h3><h4 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h4><p><u><em><strong>官方文档解释：</strong></em></u> 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。</p><p>简单点说，注解就是一张标签，贴到哪说明此处有这个特点或者特征。比如说<code>@Deprecated</code>贴到哪，说明被贴的这个方法过时了。</p><h4 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> TestAnnotation &#123;<br>    <span class="hljs-comment">//注解只能由属性，也就是成员变量，没有方法。</span><br>    <span class="hljs-comment">//注解的成员变量以“无形参的方法”形式来声明，方法名定义了成员变量的名字，返回值定义了成员变量的类型。</span><br>    <span class="hljs-comment">//如果成员变量没有默认值，则在使用该注解时必须给其赋值。</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//默认值用default定义</span><br>    String <span class="hljs-title function_">sex</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;man&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的注解要能工作，必须还依靠元注解，什么是元注解呢？<strong>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</strong> 也就是说，你要贴的这个标签，本身自己也要被贴“标签”，也就是一些限制定义之类的。 </p><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解有5个。分别是 <code>@Retention</code> <code>@Documented</code> <code>@Target</code> <code>@Inherited</code> <code>@Repeatable</code></p><p><code>@Retention</code> 作用是标识目标注解的存活期。取值有：</p><ul><li>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li><li>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li><li>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</li></ul><p><code>@Documented</code> 顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。</p><p><code>@Target</code> 指定了注解运用的地方。</p><ul><li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li><li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li><li>ElementType.FIELD 可以给属性进行注解</li><li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li><li>ElementType.METHOD 可以给方法进行注解</li><li>ElementType.PACKAGE 可以给一个包进行注解</li><li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li><li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li></ul><p><code>@Inherited</code> 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><p><code>@Repeatable </code>暂时不搞</p><h4 id="注解的解析方式"><a href="#注解的解析方式" class="headerlink" title="注解的解析方式"></a>注解的解析方式</h4><p>常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h4 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h4><p>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnnotationPresent</span><span class="hljs-params">(Class&lt;? extends Annotation&gt; annotationClass)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; A <span class="hljs-title function_">getAnnotation</span><span class="hljs-params">(Class&lt;A&gt; annotationClass)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>或者是 getAnnotations() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Annotation[] getAnnotations() &#123;&#125;<br></code></pre></td></tr></table></figure><p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p><p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。</p><h3 id="4、IO流"><a href="#4、IO流" class="headerlink" title="4、IO流"></a>4、IO流</h3><h2 id="四、集合"><a href="#四、集合" class="headerlink" title="四、集合"></a>四、集合</h2><h3 id="1、Comparable-和-Comparator-的区别"><a href="#1、Comparable-和-Comparator-的区别" class="headerlink" title="1、Comparable 和 Comparator 的区别"></a>1、Comparable 和 Comparator 的区别</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li>Comparable 接口是 java.lang 包下的，有方法 compareTo(Object o)</li><li>Comparator 接口是 java.util 包下的，有方法 compare(Object o1, Object o2)</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Comparable</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * T重写compareTo方法实现按年龄来排序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.age &gt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.age &lt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//Comparator</span><br>Collections.sort(arrayList, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o2.compareTo(o1);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2、集合概述"><a href="#2、集合概述" class="headerlink" title="2、集合概述"></a>2、集合概述</h3><p>Java集合，也叫容器，主要是由两大接口派生而来。一个是存储单一元素的<code>Collection</code>接口，另一个是存储键值对的<code>Map</code>接口。对于 Collection 接口，有三个子接口，分别是 List、Set 和 Queue</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java-collection-hierarchy.png" alt="Java 集合框架概览" style="zoom: 50%;" /><p><u><em><strong>注：</strong></em></u>只列举了部分继承实现关系</p><ul><li>List用于存储有序可重复元素</li><li>Set用于存储无序不可重复元素</li><li>Map用于存储键值对&lt;key, value&gt; ，key存储是Set类型，value是Collection。因此，map的key是无序不重复的，而value可以为null、重复。</li><li>Queue 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。比如说先进先出，后进先出等</li></ul><h3 id="3、List"><a href="#3、List" class="headerlink" title="3、List"></a>3、List</h3><p>List接口下主要几个实现类是 ArrayList、LinkedList（同时也实现了Deque接口，经常当作栈来使用）、Vector（Vector有个子类Stack）</p><h4 id="（1）ArrayList"><a href="#（1）ArrayList" class="headerlink" title="（1）ArrayList"></a>（1）ArrayList</h4><p>继承自 AbstractList，实现了 List、RandomAccess、Cloneable、Serializable接口。线程不安全</p><ul><li>Random接口是一个标记接口，没有任何方法和成员变量。作用仅仅是表明实现了该接口的类是可随机访问的。也就是可以根据下标访问的</li><li>实现了Cloneable 接口，覆盖了 clone() 方法，是可克隆的</li><li>实现了Serializable接口，表明可序列化</li></ul><p>底层存储是 Object[] ，使用transient修饰，不进行持久化。默认初始容量大小为10，当使用无参构造new一个ArrayList对象时，底层实际创建的是一个空数组，直到添加第一个元素时，才创建一个长度为 10 的数组。当使用有参构造new时，会根据指定的长度创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//空数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">//无参构造</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">//有参构造</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br><span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="扩容机制："><a href="#扩容机制：" class="headerlink" title="扩容机制："></a>扩容机制：</h5><p>ArrayList 扩容采用的是移位操作，每次容量增大1.5倍左右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object[] grow(<span class="hljs-type">int</span> minCapacity) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-keyword">if</span> (oldCapacity &gt; <span class="hljs-number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> ArraysSupport.newLength(oldCapacity,<br>                    minCapacity - oldCapacity, <span class="hljs-comment">/* minimum growth */</span><br>                    oldCapacity &gt;&gt; <span class="hljs-number">1</span>           <span class="hljs-comment">/* preferred growth */</span>);<br>            <span class="hljs-type">return</span> <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> Arrays.copyOf(elementData, newCapacity);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">return</span> <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];<br>        &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newLength</span><span class="hljs-params">(<span class="hljs-type">int</span> oldLength, <span class="hljs-type">int</span> minGrowth, <span class="hljs-type">int</span> prefGrowth)</span> &#123;<br>        <span class="hljs-comment">// preconditions not checked because of inlining</span><br>        <span class="hljs-comment">// assert oldLength &gt;= 0</span><br>        <span class="hljs-comment">// assert minGrowth &gt; 0</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">prefLength</span> <span class="hljs-operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="hljs-comment">// might overflow</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;<br>            <span class="hljs-keyword">return</span> prefLength;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// put code cold in a separate method</span><br>            <span class="hljs-keyword">return</span> hugeLength(oldLength, minGrowth);<br>        &#125;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><p>其实，ArrayList的扩容底层还是数组复制，源码中大量使用了 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *   复制数组 System类的方法</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">    */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src, <span class="hljs-type">int</span> srcPos, Object dest, <span class="hljs-type">int</span> destPos,  <span class="hljs-type">int</span> length)</span>;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.copyOf(T[] original, <span class="hljs-type">int</span> newLength)<br></code></pre></td></tr></table></figure><p>而Arrays.copyOf() 底层又使用的是 System.arraycopy()</p><p>arraycopy 是一个 native 方法，实现数组复制。而 Arrays.copyOf() 在它的基础上 内部新建了数组，拷贝后进行了返回。</p><h5 id="ArrayList-插入和删除的时间复杂度"><a href="#ArrayList-插入和删除的时间复杂度" class="headerlink" title="ArrayList 插入和删除的时间复杂度"></a>ArrayList 插入和删除的时间复杂度</h5><p>对于插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><p>对于删除：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h5 id="ArrayList-和-Array-数组-的区别："><a href="#ArrayList-和-Array-数组-的区别：" class="headerlink" title="ArrayList 和 Array(数组) 的区别："></a>ArrayList 和 Array(数组) 的区别：</h5><ul><li>Array是固定长度，一旦创建就不能再改变长度。而ArrayList可以动态扩容</li><li>ArrayList可以可以使用泛型确保类型安全。Array不可以</li><li>ArrayList 只能存储对象，如果是基本数据类型则会被自动装箱。而 Array 可以直接存储基本数据类型，也可以存储对象。</li><li>Array 创建后，就只能存储该类型数据。而 ArrayList没有指定泛型时可以存储任意类型数据</li><li>ArrayList 支持添加删除遍历等多种操作，有丰富的 api，而Array只能依照下标操作元素</li><li>ArrayList 创建时不需要指定 大小，而Array需要</li></ul><h4 id="（2）Vector和Stack"><a href="#（2）Vector和Stack" class="headerlink" title="（2）Vector和Stack"></a>（2）Vector和Stack</h4><ul><li>Stack继承自Vector，是一个先进后出的栈</li><li>Vector 和 Stack 都是线程安全的，都是使用 synchronized 关键字进行同步处理</li><li>目前二者已经几乎被淘汰，性能较差</li></ul><h4 id="（3）LinkedList"><a href="#（3）LinkedList" class="headerlink" title="（3）LinkedList"></a>（3）LinkedList</h4><ul><li>底层使用双向链表（JDK6 之前为双向循环链表，JDK7 取消了循环）</li><li>LinkedList不能实现 RandomAccess接口，因为它是链表实现，不能随机快速访问</li><li>LinkedList 不保证线程安全</li><li>我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！</li></ul><h5 id="插入和删除时间复杂度"><a href="#插入和删除时间复杂度" class="headerlink" title="插入和删除时间复杂度"></a>插入和删除时间复杂度</h5><ul><li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h3 id="4、Set"><a href="#4、Set" class="headerlink" title="4、Set"></a>4、Set</h3><h4 id="无序性和不可重复性"><a href="#无序性和不可重复性" class="headerlink" title="无序性和不可重复性"></a>无序性和不可重复性</h4><ul><li>无序性不等于随机性，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false才能加入，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h4 id="比较HashSet、LinkedHashSet、TreeSet"><a href="#比较HashSet、LinkedHashSet、TreeSet" class="headerlink" title="比较HashSet、LinkedHashSet、TreeSet"></a>比较HashSet、LinkedHashSet、TreeSet</h4><ul><li><p>都是Set接口的实现类，都能保证元素唯一，并且都不是线程安全的</p></li><li><p>LinkedHashSet 是 HashSet 的子类</p></li><li><p>HashSet 底层是哈希表，（HashMap实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。LinkedHashSet 并没有自己的独有的方法，都是继承自 HashSet、Object 和 实现Set接口。<code>TreeSet</code> 底层数据结构是红黑树（TreeMap实现），元素是有序的，排序的方式有自然排序和定制排序。</p></li><li><p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p></li></ul><h3 id="5、Queue"><a href="#5、Queue" class="headerlink" title="5、Queue"></a>5、Queue</h3><h4 id="Queue和Deque的区别（二者都是接口）"><a href="#Queue和Deque的区别（二者都是接口）" class="headerlink" title="Queue和Deque的区别（二者都是接口）"></a>Queue和Deque的区别（二者都是接口）</h4><ul><li>Queue是单端列表，只能从一端插入另一端删除，一般遵循先进先出原则（FIFO）。</li><li>Queue扩展了Collection接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong>，可以分为两类方法：一类是抛出异常，另一类是返回特殊值。</li></ul><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230523092849060.png" alt="image-20230523092849060" style="zoom:67%;" /><ul><li>Deque是双端队列，在队列的两端均可以插入或删除元素。</li><li>Deque扩展了Queue接口，增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</li></ul><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230523093107089.png" alt="image-20230523093107089" style="zoom:67%;" /><ul><li><strong>Deque还可以模拟栈，使用 push、pop</strong></li></ul><h4 id="ArrayDeque与LinkedList的区别"><a href="#ArrayDeque与LinkedList的区别" class="headerlink" title="ArrayDeque与LinkedList的区别"></a>ArrayDeque与LinkedList的区别</h4><ul><li>ArrayDeque实现了 Deque 接口，继承了 AbstractCollection。LinkedList 实现了 Deque接口和List接口，继承了AbstractSequentialList。  （AbstractCollection也是AbstractSequentialList的间接父类）</li><li>ArrayDeque基于可变长的数组和双指针（head、tail）实现，也就是说可以动态扩容（底层也有一个grow方法）。 LinkedList使用双向链表实现（JDK7及以后取消了循环）</li><li>ArrayDeque 不支持 null 数据存储。LinkedList支持</li><li>ArrayDeque 是JDK6 时才引入的。LinkedList 是 JDK1.2就有</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p><strong>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</strong></p><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><ul><li>PriorityQueue 底层使用二叉堆实现，使用可变长数组来存储数据</li><li>PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(log n) 的时间复杂度内插入元素和删除堆顶元素</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><h4 id="什么是-BlockingQueue？"><a href="#什么是-BlockingQueue？" class="headerlink" title="什么是 BlockingQueue？"></a>什么是 BlockingQueue？</h4><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><p><img src="/lulalula/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/blocking-queue.png" alt="BlockingQueue"></p><p>Java 中常用的阻塞队列实现类有以下几种：</p><ul><li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。和<code>ArrayBlockingQueue</code>类似， 它也支持公平和非公平的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li></ul><h3 id="6、Map（重点）"><a href="#6、Map（重点）" class="headerlink" title="6、Map（重点）"></a>6、Map（重点）</h3><h4 id="（1）HashMap"><a href="#（1）HashMap" class="headerlink" title="（1）HashMap"></a>（1）HashMap</h4><h5 id="重要变量介绍"><a href="#重要变量介绍" class="headerlink" title="重要变量介绍"></a>重要变量介绍</h5><ul><li><code>DEFAULT_INITIAL_CAPACITY</code> Table数组的初始化长度： <code>1 &lt;&lt; 4    2^4=16</code>（为什么要是 2的n次方？）</li><li><code>MAXIMUM_CAPACITY</code> Table数组的最大长度： <code>1&lt;&lt;30   2^30=1073741824</code></li><li><code>DEFAULT_LOAD_FACTOR</code> 负载因子：默认值为<code>0.75</code>。 当元素的总个数&gt;当前数组的长度 * 负载因子。数组会进行扩容，扩容为原来的两倍（todo：为什么是两倍？） <strong><u>答</u>：</strong>跟位置散列有关 <a href="">为什么长度一定是2的幂</a></li><li><code>TREEIFY_THRESHOLD</code> 链表树化阙值： 默认值为 <code>8</code> 。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。</li><li><code>UNTREEIFY_THRESHOLD</code> 红黑树链化阙值： 默认值为 <code>6</code> 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</li><li><code>MIN_TREEIFY_CAPACITY = 64</code> 最小树化阈值，当Table所有元素超过该值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</li></ul><h5 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h5><p>​JDK8之前，HashMap底层使用 数组加链表组合，也就是<strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。（因为计算出来的位置是同一个，所以在数组同一个位置采用链表串起来）</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jdk1.7_hashmap.png" alt="jdk1.8 之前的内部结构-HashMap" style="zoom:67%;" /><p>​所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p>​而JDK8之后，HashMap 底层变为了数组 + 链表 &#x2F; 红黑树。在哈希冲突发生时，先判断链表长度是否大于阈值（默认是8），如果没有大于阈值，就直接加在链表后。如果大于了阈值，首先判断数组的长度是否大于64，如果小于64先进行数组扩容，然后将链表转换为红黑树。</p><h5 id="为什么长度一定是2的幂"><a href="#为什么长度一定是2的幂" class="headerlink" title="为什么长度一定是2的幂"></a><a href="">为什么长度一定是2的幂</a></h5><p>跟HashMap通过key确定在数组中的位置机制有关。</p><p>HashMap在根据key通过hashCode()计算得到hash时，因为计算到的hash很大，一定会超过数组长度，因此需要处理保证最后的结果在 长度大小范围内。比如说长度为16，那么计算出最终的存储位置就应该是 0 — 15。一般我们考虑是取余操作。 但是HashMap底层的实现是 <code>(n - 1) &amp; hash</code>，n表示数组长度，这样的话，就一定要保证 <code>n-1</code>的值所有位是1（这样的话n一定是2的幂），这样才能保证 hash 处理后可能落在 0 — n-1 所有的位置。</p><p><strong>举个栗子来反证一下：</strong><br>我们现在 数组的长度为 15 减一为 14 ，二进制表示 <code>0000 1110</code> 进行相与时候，最后一位永远是0，这样就可能导致，不能够完完全全的进行数组的使用。违背了我们最开始的想要对数组进行<strong>最大限度的无序使用</strong>的原则，因为HashMap为了能够存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表⻓度⼤致相同。</p><h5 id="put和get操作"><a href="#put和get操作" class="headerlink" title="put和get操作"></a>put和get操作</h5><p>put方法</p><ul><li>对key的hashCode()做hash运算，计算index;</li><li>如果没碰撞直接放到bucket⾥；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过⻓(⼤于等于TREEIFY_THRESHOLD)，就把链表转换成红⿊树(JDK1.8中的改动)；</li><li>如果节点已经存在就替换old value(保证key的唯⼀性)</li><li>如果bucket满了(超过load factor*current capacity)，就要resize</li></ul><p>get方法</p><ul><li>对key的hashCode()做hash运算，计算index;</li><li>如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回；</li><li>如果有冲突，则通过key.equals(k)去查找对应的Entry;</li><li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li><li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ul><h5 id="HashMap-的线程不安全"><a href="#HashMap-的线程不安全" class="headerlink" title="HashMap 的线程不安全"></a>HashMap 的线程不安全</h5><p>​JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p><p>​数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p><p>举个例子：</p><ul><li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li><li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li><li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li></ul><h5 id="HashMap-的-7-种遍历方式与性能分析"><a href="#HashMap-的-7-种遍历方式与性能分析" class="headerlink" title="HashMap 的 7 种遍历方式与性能分析"></a><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">HashMap 的 7 种遍历方式与性能分析</a></h5><h4 id="2-HashMap-和-HashTable-的区别"><a href="#2-HashMap-和-HashTable-的区别" class="headerlink" title="(2) HashMap 和 HashTable 的区别"></a>(2) HashMap 和 HashTable 的区别</h4><ul><li><p>线程是否安全：HashMap线程不安全，HashTable 线程安全，方法都用synchronized修饰。<strong>要线程安全就使用ConcurrentHashMap</strong>，HashTable效率太低</p></li><li><p>效率：因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它</p></li><li><p>对 null key 和 null value 的支持：HashMap 可以存储 null 的键和值，HashTable不可以</p></li><li><p>初始容量和扩容：</p><p>​HashMap 不指定容量时，默认为<strong>16</strong>，指定容量时，将给定的容量扩充为<strong>2的幂</strong>。当数组中存储的数量大于 容量 * 负载因子（默认为0.75）时，容量变为2倍。 </p><p>​HashTable 不指定参数时，默认为<strong>11</strong>，给定容量时，直接使用给定的参数。每次扩容为 当前容量 * 2 + 1（2n + 1）。</p></li><li><p>底层数据结构： HashMap 底层使用 数组 + 链表&#x2F;红黑树。</p></li></ul><h4 id="3-HashMap-和-HashSet"><a href="#3-HashMap-和-HashSet" class="headerlink" title="(3) HashMap 和 HashSet"></a>(3) HashMap 和 HashSet</h4><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230523154053230.png" alt="image-20230523154053230" style="zoom: 50%;" /><p>HashSet 在add一个对象时，其实调用的是 HashMap的 map.put(e, PRESENT)   <strong>注：e为add的对象，PRESENT是一个private的静态常量，也就是说，HashSet存储其实是将要存储的对象作为键，所有的键共用一个值</strong></p><h4 id="4-HashMap-和-TreeMap"><a href="#4-HashMap-和-TreeMap" class="headerlink" title="(4) HashMap 和 TreeMap"></a>(4) HashMap 和 TreeMap</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/treemap_hierarchy.png" alt="TreeMap 继承关系图" style="zoom:67%;" /><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><h4 id="5-ConcurrentHashMap（线程安全）"><a href="#5-ConcurrentHashMap（线程安全）" class="headerlink" title="(5) ConcurrentHashMap（线程安全）"></a>(5) ConcurrentHashMap（线程安全）</h4><p>ConcurrentHashMap继承了AbstractMap，实现了ConcurrentMap接口</p><ul><li>底层数据结构：JDK1.7 采用 分段数组 + 链表实现， JDK8及以后跟HashMap一样，采用数组 + 链表 &#x2F; 红黑树实现。</li><li>**<u>实现线程安全的方式</u>**：JDK1.7时，对整个桶数组进行了分段分割（segment，分段锁），每一把锁只锁容器中的一部分数据，多线程访问不同段的数据时，不会存在锁竞争，提高了并发效率。<code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。<code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。      JDK1.8时，摒弃了 segment思想，直接用 Node数组 + 链表 &#x2F; 红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS来操作。锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</li></ul><p>​<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构" style="zoom:50%;" />JDK1.7</p><p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构" style="zoom: 50%;" />             JDK1.8</p><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="一、多线程上"><a href="#一、多线程上" class="headerlink" title="一、多线程上"></a>一、多线程上</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>进程是静态程序的一次动态执行，是系统运行程序的最基本单位。系统运行一个程序即是进程从创建到运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程与进程相似，是比进程更小的一个执行单位。一个进程运行过程中会产生多个线程。多个线程共享堆和方法区（JDK8之后的元空间），每个线程都有<strong>自己</strong>的 虚拟机栈、本地方法栈（<strong>保证线程中的局部变量不被别的线程访问到</strong>）、程序计数器。因此系统在产生一个线程或者在多个线程之间切换时，代价相较于进程会小很多。也因此线程也被称为<strong>轻量级进程</strong>。</p><h3 id="线程和进程的关系及优缺点"><a href="#线程和进程的关系及优缺点" class="headerlink" title="线程和进程的关系及优缺点"></a>线程和进程的关系及优缺点</h3><ul><li>关系：一个进程中有多个线程，多个线程共享一个进程的堆和方法区，但是各自有各自的虚拟机栈、本地方法栈、程序计数器。 进程和线程的最大不同在于，每一个进程都是相对独立的，而线程不一定，因为同一进程中的多个线程极有可能相互影响。</li><li>线程的优缺点：线程执行开销小，但不利于资源的管理和保护</li><li>进程的优缺点：进程执行开销大，但有利于资源的管理和保护</li></ul><h3 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h3><ul><li>字节码解释器通过修改程序计数器来依次读取指令，通过修改程序计数器来实现代码的流程控制，如顺序执行、循环、选择等</li><li>多线程线程切换时，程序计数器记录当前线程的执行的位置，当再次切换回来时，可以明确上次运行的位置</li></ul><p>因此，程序技术器一定是线程私有的</p><h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h3><ul><li>同步：发出一个调用之后，在没有得到结果之前，该调用不可返回，一直等待</li><li>异步：发出一个调用之后，不用等待结果，都直接返回</li></ul><h3 id="如何理解线程不安全"><a href="#如何理解线程不安全" class="headerlink" title="如何理解线程不安全"></a>如何理解线程不安全</h3><p>线程不安全指的是，在多线程环境中，对于同一份数据，多个线程同时执行可能导致数据的混乱、错误或者丢失。</p><p>线程安全指的是，在多线程环境中，对于同一份数据，能保证它的一致性、准确性。</p><h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h3><p>在Java中，线程有6种状态：</p><p>1、NEW：初始状态，线程被创建但是没被调用 start()</p><p>2、RUNNABLE：运行状态，线程被调用start()。 **<u><em>注意：</em></u>**这里与操作系统的状态划分有区别，<u>RUNNABLE里边包含了就绪和运行。</u></p><p>3、BLOCKED：阻塞状态，需要等待锁的释放</p><p>4、WAITING：等待状态，表示线程在等待其他线程做出一些特定动作</p><p>5、TIMED_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待</p><p>6、TERMINATED：终止状态，表示该线程已经运行完毕</p><ul><li>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li><li>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</li><li>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</li></ul><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/640.png" alt="Java 线程状态变迁图" style="zoom: 50%;" /><p><strong>为什么 JVM 没有区分这两种状态呢？</strong> （摘自：<a href="https://www.zhihu.com/question/56494969/answer/154053599">Java 线程运行怎么有第六种状态？ - Dawell 的回答open in new window</a> ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p><h3 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换"></a>什么是线程上下文切换</h3><p>上下文：运行条件和状态</p><p>​线程在执行时，会有自己的上下文，比如程序计数器、栈信息等。在线程切换时，需要保留该线程的上下文，留待下次切换回来时恢复现场。并加载下一个将要占用CPU的线程的上下文。这就是所谓的上下文切换。上下文切换要占用CPU、内存的资源。</p><p>​线程在占用CPU执行时，会有以下几种情况放弃CPU，前三种存在上下文切换：</p><ul><li>时间片用完</li><li>主动让出CPU，调用了sleep() 或者 wait() 方法</li><li>调用了阻塞类型的中断，如请求IO</li><li>被终止或者运行结束（这种情况不发生上下文切换）</li></ul><h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><ul><li>互斥条件：该资源任何一时刻只能被一个线程占用</li><li>请求与保持条件：一个线程因请求资源阻塞，不释放已获得资源</li><li>不可剥夺条件：线程在为执行完时，已获得的资源不能被其他线程强行剥夺</li><li>循环等待条件：若干线程形成了一种头尾相接的循环等待资源关系</li></ul><h3 id="预防和避免死锁"><a href="#预防和避免死锁" class="headerlink" title="预防和避免死锁"></a>预防和避免死锁</h3><p>预防死锁：</p><ul><li>破坏请求与保持条件：一次性申请所有资源</li><li>破坏不可剥夺条件：线程请求其他资源时发现获取不到，就释放手中已经获取的资源</li><li>破坏循环等待条件：按照特定顺序申请资源</li></ul><p>避免死锁：</p><p>​避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。<strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p><h3 id="sleep-和-wait-对比"><a href="#sleep-和-wait-对比" class="headerlink" title="sleep() 和 wait()对比"></a>sleep() 和 wait()对比</h3><p>共同点：二者都可以暂停线程的执行</p><p>不同点：</p><ul><li>sleep() 没有释放锁， wait() 释放了锁</li><li>sleep() 是 Thread类的静态方法，而wait() 是 Object 类的方法</li><li>sleep() 通常用于暂停线程， wait() 通常用于线程间通信&#x2F;交互</li><li>sleep() 执行后会自动苏醒， wait() 执行后不会自动苏醒，直到其他线程调用了同一对象上的 notify() 方法或者 notifyAll()。如果是 wait(long timeout)，则在timeout时间后也会自动苏醒</li></ul><p>为什么wait() 方法是 Object类的方法，而sleep是 Thread类的静态方法？</p><p>解答：每个对象都可以作为对象锁，因为 wait() 方法是暂停当前获得对象锁的线程，并且自动释放对象锁，是通过对作为锁的对象做操作，因此 wait() 方法要是每一个对象都有的方法。而 sleep() 方法仅仅是暂停当前线程，没有释放锁，所以只跟当前线程有关，不涉及对象锁，作为Thread的方法就够用。</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>A线程中执行另一线程B的 join 方法，则A线程会等待B线程执行完毕才接着往下执行      join（long）这个重载方法则可以指定一个等待时间，超过等待时间则A不再等待B执行完毕</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>Java 程序入口就是 JVM 启动 main 线程，main 线程又启动其他线程，直到所有非守护线程都执行结束，JVM 才退出。</p><p><strong>但是</strong>，有一类线程并不自动结束，比如定时任务线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(LocalTime.now());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种线程就会一直执行下去，无法退出。此时就需要有一种“专用的“线程，不需要“引起”JVM注意，也就是，不论这个线程退不退出，JVM 都可以退出。 <strong>守护线程就出现了，</strong>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。因此，JVM退出时，不必关心守护线程是否已结束。</p><p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>t.setDaemon(<span class="hljs-literal">true</span>);<br>t.start();<br></code></pre></td></tr></table></figure><p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。    守护线程用来做定时任务是最好的例子</p><h2 id="二、多线程下"><a href="#二、多线程下" class="headerlink" title="二、多线程下"></a>二、多线程下</h2><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554">中断线程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p>对目标线程调用<code>interrupt()</code>方法可以请求中断一个线程，目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到<code>InterruptedException</code>；</p><p>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</p><p>通过标志位判断需要正确使用<code>volatile</code>关键字；</p><p><code>volatile</code>关键字解决了共享变量在线程间的可见性问题。</p><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>volatile关键字用来修饰变量，被volatile修饰说明此变量是共享并且不稳定的，每次使用这个变量都要从主存中读取。这一关键字保证了变量的可见性。</p><p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jmm.png" alt="img" style="zoom:50%;" />             <strong>未被volatile修饰</strong></p><p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jmm2.png" alt="JMM(Java 内存模型)强制在主存中进行读取" style="zoom: 50%;" /><strong>被volatile修饰</strong></p><p><strong>volatile可以保证数据的可见性，但是不能保证数据的原子性</strong></p><p>​除了保证数据的原子性外，volatile还可以防止 JVM 的指令重排序，如果某变量被volatile修饰，在对该变量进行读写时，会插入特定的内存屏障，来静止指令重排序</p><blockquote><p>**<u>注：</u>**指令重排序是指，为了提升效率，提高CPU利用率，将指令的执行顺序进行修改。（有可能导致结果的不一致）；       内存屏障就是一组同步屏障指令，是一个同步点，在此同步点之前的所有操作结束后才能进行此点之后的操作             </p><p>​指令重排序就是一种来源于生活的优化思想，这种思想在生活中处处可见，就像平常咱们做菜，咱们会选择在炒第一个菜的同时就在洗第二个菜了， 咱们会把熟得最慢的菜放到最开始（比如煲汤），因为在等待这些菜熟的过程中（IO等待）咱们(CPU)还可以做其它事情，这就是一种时间上的优化，在计算机领域也是一样，它也会根据指令的类别做一些优化，目的就是把CPU的资源利用起来，这样就能就能提升整个计计算机的效率。</p></blockquote><p>举例：<strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//懒汉式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​uniqueInstance 变量被 volatile 修饰了，因此就保证了这个变量的可见性，以及禁止了关于这个变量的指令重排序。    <code>uniqueInstance = new Singleton();</code> 这条语句并不是原子操作，其实分为三步操作：</p><ul><li>1、为 uniqueInstance 分配内存</li><li>2、初始化 uniqueInstance</li><li>3、将uniqueInstance 指向分配的内存地址</li></ul><p>​这三步顺序执行是正确的，但是由于<strong>JVM 有指令重排序</strong>，执行顺序就有可能变成 1 - 3 - 2；假设线程1此时完成了 1 和 3 操作就切换为了线程2，此时线程2 进行判断，发现 uniqueInstance <strong>不为 null</strong>，则<strong>直接返回</strong>了 uniqueInstance，但此时 uniqueInstance <strong>实际上并未初始化</strong>。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>​1、悲观锁：总是假设最坏的情况，即共享资源每次被访问的时候都有可能出现问题（比如共享数据被修改），所以每次对共享资源进行操作时都会上锁，其他线程想获取该资源就会被阻塞。也就是说，共享资源任何一个时刻只能被一个线程使用，其他线程阻塞，直到该线程释放资源。  <strong>synchronized、ReentrantLock等独占锁就是悲观锁思想的实现</strong>。</p><blockquote><p>​高并发场景下，激烈的锁竞争会导致大量线程阻塞，大量阻塞线程会导致系统切换上下文，增加系统性能开销。而且，悲观锁还会导致死锁等情况发生。</p></blockquote><p>​2、乐观锁：总是假设最好的情况，即共享资源每次访问都不会产生问题，线程可以不断执行，无需加锁也无需等待。只是在提交的时候判断相关资源是否被其他线程修改过（<strong>具体实现有版本号机制、CAS算法</strong>）</p><blockquote><p>​高并发场景下，由于乐观锁没有加锁，线程不存在阻塞，并且不会造成死锁等问题，在性能上往往比悲观锁实现更好。但是，如果冲突发生比较频繁（大量写的情况），就可能频繁失败和重试，同样影响性能。</p></blockquote><p>理论上来说：</p><ul><li>悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h3 id="乐观锁的实现（版本号机制和CAS算法）"><a href="#乐观锁的实现（版本号机制和CAS算法）" class="headerlink" title="乐观锁的实现（版本号机制和CAS算法）"></a>乐观锁的实现（版本号机制和CAS算法）</h3><p>CAS算法使用的多一点</p><p>1、版本号机制</p><p>​在数据表中加入一个数据版本号 version，表示数据被修改的次数，当数据被修改时，version加一。线程A要更新共享数据时，在读取数据时也会读取版本号，在提交更新时，先判断版本号和数据库中的版本号值是否一致，一致就提交更新，如果不一致，则重试所有操作，直到更新成功。</p><p>举例：</p><blockquote><p>​假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>&#x3D;1 ），连同帐户扣除后余额（ <code>balance</code>&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号（ <code>version</code>&#x3D;1 ）试图向数据库提交数据（ <code>balance</code>&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol></blockquote><p>2、CAS算法</p><p>​CAS 全称 Compare And Swap，CAS思想很简单，就是用一个预期值和要更新的变量值进行比较，相等才会更新。<strong>CAS操作是一个原子操作，底层依赖于一条CPU的原子指令</strong></p><p>CAS涉及3个操作数：</p><ol><li>V：要更新的变量值（Var）</li><li>E：预期值（Expected）</li><li>N：拟更新的新值（New）</li></ol><p>当且仅当 V &#x3D;&#x3D; E 时，CAS通过原子操作用新值 N 来更新 V 的值。如果不相等，则说明其他线程修改了当前变量，当前线程就放弃更新。</p><p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p><ol><li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li><li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li></ol><p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><h3 id="乐观锁存在的问题"><a href="#乐观锁存在的问题" class="headerlink" title="乐观锁存在的问题"></a>乐观锁存在的问题</h3><p>1、ABA问题： </p><p>​即A线程获取到V，B线程修改了共享变量，V变成了 V1，后又有一个线程修改了共享变量，使V1又变回了V。那么此时对于A线程来说，它是感受不到发生的变化的，但实际上共享变量已经被操作过了。</p><p>2、循环时间长开销大：</p><p>​CAS经常使用自旋操作来进行操作，即不成功就一直循环直到成功。如果时间长不成功，一直重试，会给 CPU 带来非常大的执行开销。</p><p>3、只能保证一个共享变量的原子操作：</p><p>​CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>​synchronized 是 Java 的一个关键字，主要解决多个线程之间访问资源的同步性，可以保证被其修饰的方法或者代码块在任何一时刻只能由一个线程操作。</p><h4 id="synchronized的用法"><a href="#synchronized的用法" class="headerlink" title="synchronized的用法"></a>synchronized的用法</h4><p>synchronized关键字主要有三个使用方式：</p><ul><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ul><p>1、修饰实例方法（锁当前对象实例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//balabalaba.....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>给当前对象实例加锁，在进入方法之前，要先获得当前对象实例的锁</p><p>2、修饰静态方法（锁所在类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//balabala...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为静态方法是类方法，所以是给所在类加锁，在进入方法之前，先要获得所在类的锁</p><p>3、修饰代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">//balabala...</span><br>    <span class="hljs-comment">//表示进入同步代码库前要获得 给定对象的锁</span><br>&#125;<br><br><span class="hljs-keyword">synchronized</span>(Object.class) &#123;<br>    <span class="hljs-comment">//balabala...</span><br>    <span class="hljs-comment">// 表示进入同步代码前要获得 给定 Class 的锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</li></ul><p><strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h4 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h4><p>​1、synchronized关键字同步代码块时，实际使用的是 monitorenter 和 monitorexit 这两个指令。 其中，monitorenter 指令指明代码块开始的位置， monitorexit 指令指明代码块结束的位置。 一个monitorenter 指令一般会匹配两个 monitorexit 指令，目的是不论是正常结束还是异常结束都能正确释放锁。</p><p>​当执行 monitorenter 指令时，线程试图获取锁也就是获取**<u>对象监视器</u>** monitor 的使用权</p><blockquote><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p><p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p></blockquote><p>​</p><p>​在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p>​对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p>​2、synchronized修饰方法时，并没有 monitorenter 和 monitorexit 指令。取而代之的是 <code>ACC_SYNCHRONIZED </code> 标识，这个标识表明这个方法是一个同步方法。JVM 根据这个标识判断出这个方法是同步方法，然后执行相关同步调用。但是本质上和同步代码块时一样，都是对 <strong>对象监视器 monitor</strong> 的获取。</p><p>​</p><h4 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h4><ul><li>volatile 关键字是线程同步的轻量级实现，性能比 synchronized 好。</li><li>volatile 关键字只能修饰变量，而 synchronized 关键字可以修饰 代码块和方法。</li><li>volatile 只能保证数据的可见性，不能保证数据的原子性，synchronized 关键字二者都可以保证。</li><li>volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 主要用于解决多个线程之间访问资源的同步性。</li></ul><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ul><li><p><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p></li><li><p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。<strong>（synchronized是非公平锁）</strong></p></li></ul><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>​<strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><h3 id="可中断锁和不可中断锁"><a href="#可中断锁和不可中断锁" class="headerlink" title="可中断锁和不可中断锁"></a>可中断锁和不可中断锁</h3><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</li></ul><h2 id="三、多线程下"><a href="#三、多线程下" class="headerlink" title="三、多线程下"></a>三、多线程下</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>​在多线程情况下，通常我们创建的变量可以被所有线程访问并修改。而如果想要每一个线程独有一份变量时，就要使用 JDK 中自带的 ThreadLocal 类， <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p>​如果创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个<strong>变量的本地副本</strong>，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h4 id="ThreadLocal的原理-："><a href="#ThreadLocal的原理-：" class="headerlink" title="**ThreadLocal的原理**："></a>**<u><em>ThreadLocal的原理</em></u>**：</h4><p>Thread类中有有两个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>​ThreadLocalMap 是 ThreadLocal 类的一个静态内部类（其实可以理解为 ThreadLocal 就是对 ThreadLocalMap 做了一个封装），当使用 ThreadLocal 进行 set() 操作时，实际调用的是 ThreadLocalMap 的 set() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br><span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>map.set(<span class="hljs-built_in">this</span>, value);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>createMap(t, value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​可以看到，set() 方法中首先是获取当前的线程，然后再获取当前线程的 threadlocals 变量， 通过调用这个变量的 set () 方法，将当前 ThreadLocal 作为 key，将 set 的值作为 value，存放到 threadLocals 中。</p><p><strong>注意：</strong>每个线程都有自己的变量副本实际上跟 ThreadLocal 关系不大，它仅仅是作为一个工具类。一般在声明 ThreadLocal 类的实例时，一般都声明为 static final ，也就是说，实际上所有的线程都是同一个 ThreadLocal 类实例，在 map.set(this, value) 时，所有的线程的map 的 key 也都是一样的。 <strong><u><em>而真正实现每个线程都有自己的变量副本的是：</em></u></strong>  每创建一个线程，Thread 类中的 threadlocals 变量就会新创建一份，也就是说，每一个线程都有自己的 map， 这样不管 key 是啥，对应当前线程来说，value 都是独一份的，因为 map 都是独一份的。</p><h4 id="ThreadLocal的内存泄漏问题"><a href="#ThreadLocal的内存泄漏问题" class="headerlink" title="ThreadLocal的内存泄漏问题"></a>ThreadLocal的内存泄漏问题</h4><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p><h3 id="线程池详解（ThreadPoolExecutor）"><a href="#线程池详解（ThreadPoolExecutor）" class="headerlink" title="线程池详解（ThreadPoolExecutor）"></a><a href="https://zhuanlan.zhihu.com/p/34405230">线程池详解（ThreadPoolExecutor）</a></h3><p>一、线程池的优点：</p><p>线程池能对资源进行统一管理和分配</p><p>（自述）线程的创建和销毁需要资源开销，使用线程池可以将线程使用后放回线程池，极大的降低了开销。并且，线程的创建需要时间开销，任务不会被立即接收，使用线程池就极大的降低了时间开销，拿来就用</p><p>（标答）</p><ul><li>降低资源消耗（单个线程创建需要资源开销，使用完就直接销毁了，开销比较大）</li><li>提高响应速度</li><li>提高线程的可管理性</li></ul><p>二、线程池的创建：</p><p>所有Executors提供的线程池都是基于这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize, <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)<br></code></pre></td></tr></table></figure><p>1、Executors.newSingleThreadExecutor()</p><ul><li>单个线程的线程池，核心线程数和最大线程数都是1。</li><li>存活时间为0，也就是不销毁。</li><li>任务队列采用LinkedBlockingQueue，无界，也就是永远不会拒绝任务，饱和策略失效。会出现 OOM  错误</li></ul><p>2、Executors.newCachedThreadPool()</p><ul><li>可缓存线程池，核心线程数为0，最大线程数为 Integer.MAX_VALUE。</li><li>存活时间为60s。</li><li>任务队列使用SynchronousQueue，同步队列，容量为0，不存放任务，消费任务和生产任务的线程匹配上时，才起作用</li><li>主线程调用SynchronousQueue的offer()方法放入task, 倘若此时线程池中有空闲的线程尝试读取 SynchronousQueue的task, 即调用了SynchronousQueue的poll(), 那么主线程将该task交给空闲线程.当线程池为空或者没有空闲的线程, 则创建新的线程执行任务.执行完任务的线程倘若在60s内仍空闲, 则会被终止. 因此长时间空闲的CachedThreadPool不会持有任何线程资源</li></ul><p>3、Executors.newFixedThreadPool(int nThread)</p><ul><li>固定核心线程数的线程池，线程数固定为 nThread</li><li>存活时间和最大线程数量 失效</li><li>任务队列使用 LinkedBlockingQueue，无界队列，如果没有空闲线程就一直往里加，直到 OOM。包和策略失效</li></ul><p>4、Executors.newScheduledThreadPool(int corePoolSize)</p><ul><li>核心线程数为 corePoolSize，最大线程数为 Interger.MAX_VALUE </li><li>存活时间为0</li></ul><h4 id="1、execute-和-submit-的区别"><a href="#1、execute-和-submit-的区别" class="headerlink" title="1、execute 和 submit 的区别"></a>1、<a href="https://blog.csdn.net/qing040513/article/details/111667627">execute 和 submit 的区别</a></h4><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="一、数据库基础知识"><a href="#一、数据库基础知识" class="headerlink" title="一、数据库基础知识"></a>一、数据库基础知识</h2><h3 id="什么是数据库，数据库管理系统，数据库系统，数据库管理员"><a href="#什么是数据库，数据库管理系统，数据库系统，数据库管理员" class="headerlink" title="什么是数据库，数据库管理系统，数据库系统，数据库管理员"></a>什么是数据库，数据库管理系统，数据库系统，数据库管理员</h3><p>数据库（DB）：一组数据的集合或者说是信息的集合</p><p>数据库管理系统（DBMS）：用于操纵、管理数据库的大型软件，通常用于建立、使用和维护数据库</p><p>数据库系统（DBS）：包括数据库、数据库管理系统和数据库管理员</p><p>数据库管理员（DBA - Administrator）：负责全面管理和控制数据库系统</p><h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>第一范式1NF ：属性不可再分</p><p>第二范式2NF ：在第一范式的基础上，消除了非主属性对于码的部分函数依赖</p><p>第三范式3NF ：在第二范式的基础上，消除了非主属性对于码的传递函数依赖</p><h3 id="为什么不推荐外键和级联"><a href="#为什么不推荐外键和级联" class="headerlink" title="为什么不推荐外键和级联"></a>为什么不推荐外键和级联</h3><p>级联：如果更新一个属性，同时触发了另一个属性的更新，则称为级联更新</p><p>高并发、分布式不适合使用外键和级联，低并发的单体项目可以考虑使用外键和级联</p><p>不推荐的原因：</p><ul><li>级联更新是强阻塞，可能导致数据库更新风暴</li><li>外键影响数据库的插入速度</li></ul><p>为什么不推荐使用外键：</p><ul><li><strong>增加了复杂性</strong>：需要时刻考虑外键</li><li><strong>增加了额外工作</strong>：当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源</li><li><strong>对分库分表不友好</strong>：因为分库分表下外键是无法生效的</li></ul><h3 id="drop、delete、truncate区别"><a href="#drop、delete、truncate区别" class="headerlink" title="drop、delete、truncate区别"></a>drop、delete、truncate区别</h3><p>drop：<code>drop table_name</code>  直接将整个表结构删掉，当然包括表中的数据</p><p>delete：<code>delete from table_name where ...</code> 根据条件删除表中的行数据</p><p>truncate：<code>truncate table_name</code> 将表清空，但是不影响表结构，相当于 <code>delete from table_name</code></p><p><strong>比较：</strong></p><ul><li>delete属于DML，这个操作可以回滚，在事物提交之后才生效。而drop、truncate属于DDL，操作立刻生效，不能回滚，不触发trigger</li><li>一般情况下 drop &gt; truncate &gt; detele，因为delete命令执行时，还要产生数据库的 binlog 日志</li></ul><h2 id="二、SQL语法"><a href="#二、SQL语法" class="headerlink" title="二、SQL语法"></a>二、SQL语法</h2><h3 id="1、SQL分类："><a href="#1、SQL分类：" class="headerlink" title="1、SQL分类："></a>1、SQL分类：</h3><p>DDL（Data Definition Language）：定义数据库对象，有 CREATE、ALTER、DROP</p><p>DML（Data Management Language）：用于数据库操作，有 INSERT、UPDATE、DELETE、SELECT</p><p>DCL （Data Control Language）：用于对数据访问权进行控制，有 GRANT、REVOKE</p><p>TCL （Transaction Control Language）：用于管理数据库中的事物，有 COMMIT、ROLLBACK</p><h3 id="2、DDL详解"><a href="#2、DDL详解" class="headerlink" title="2、DDL详解"></a>2、DDL详解</h3><h4 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a><strong>数据库：</strong></h4><ul><li>新建数据库：create database database_name</li><li>删除数据库：drop database database_name</li><li>使用数据库：use database_name</li></ul><h4 id="表："><a href="#表：" class="headerlink" title="表："></a><strong>表：</strong></h4><ul><li><p>新建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(<br>id <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment comment <span class="hljs-string">&#x27;自增ID&#x27;</span>,<br>    username <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;username&#x27;</span> comment <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>    password <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;password&#x27;</span> comment <span class="hljs-string">&#x27;密码&#x27;</span>,<br>    <span class="hljs-keyword">primary</span> key(id)<br>) engine<span class="hljs-operator">=</span>InnoDB auto_increment<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8mb4 comment<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除表：drop table user</p></li><li><p>修改表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> age <span class="hljs-type">int</span>(<span class="hljs-number">3</span>);     ##添加一列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> age;    ##删除一列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> modify <span class="hljs-keyword">column</span> age tinyint;     ##修改列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key (id);##添加主键<br></code></pre></td></tr></table></figure></li></ul><h4 id="视图："><a href="#视图：" class="headerlink" title="视图："></a><strong>视图：</strong></h4><p>视图是基于 SQL 结果集的可视化的表，视图是虚构的表，本身不包含数据，当然也就不能对其进行索引操作。对视图的操作和对普通表一样</p><p>视图的作用：</p><ol><li>简化复杂的SQL操作</li><li>只使用实际表的一部分数据</li><li>通过只给用户访问视图的权限，保证数据的安全性</li><li>更改数据格式和表示</li></ol><ul><li>创建视图：create view view_name (sql语句，有结果的)</li><li>删除视图：drop view view_name</li></ul><h4 id="约束："><a href="#约束：" class="headerlink" title="约束："></a><strong>约束</strong>：</h4><p>约束用于规定表中的数据规则，如果存在违反约束的数据行为，行为就会被约束终止。</p><p>约束类型：</p><p>not null 、 unique、primary key、foreign key、default(默认值)、check(符合特定条件)</p><h3 id="3、事物处理"><a href="#3、事物处理" class="headerlink" title="3、事物处理"></a>3、事物处理</h3><p>不能回退 select 语句，也不能回退 create、drop 语句。MySql 默认是隐式提交，每执行一条语句就把这条语句当作一条事务进行提交。当出现 start transaction 语句时，关闭隐式提交，当 commit 或者 rollback 执行后，事务自动关闭，重新恢复隐式提交。</p><p>set autocommit &#x3D; 0 可以取消自动提交，直到 set autocommit &#x3D; 1 才会提交；autocommit针对单个连接而不是服务器。</p><p>指令：start transaction（开启事务）、savepoint（创建保留点）、rollback（事务回滚）、rollback to savepoint（回滚到指定保留点）、commit（事务提交）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开始事务</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><br><span class="hljs-comment">-- 插入操作 A</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;root1&#x27;</span>, <span class="hljs-string">&#x27;root1&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br><br><span class="hljs-comment">-- 创建保留点 updateA</span><br><span class="hljs-keyword">SAVEPOINT</span> updateA;<br><br><span class="hljs-comment">-- 插入操作 B</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;root2&#x27;</span>, <span class="hljs-string">&#x27;root2&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br><br><span class="hljs-comment">-- 回滚到保留点 updateA</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> updateA;<br><br><span class="hljs-comment">-- 提交事务，只有操作 A 生效</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="4、权限控制"><a href="#4、权限控制" class="headerlink" title="4、权限控制"></a>4、权限控制</h3><p>授予用户权限使用 grant，撤销用户权限使用 revoke</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> privilege <span class="hljs-keyword">on</span> privilege_level <span class="hljs-keyword">to</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">revoke</span> privilege <span class="hljs-keyword">on</span> privilege_level <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure><ul><li>privilege 有 select、update、delete等等</li><li>privilege_level 有 整个服务器 （使用 grant all）、整个数据库（使用 on database.*）、特定的表（on database.table）、特定的列、特定的存储过程</li><li>grant、revoke 一次性可以授予&#x2F;撤销多个 权限，用逗号隔开</li><li>grant 的 user 如果已经存在，则是对权限的修改，如果不存在，则新建一个用户。<strong>新建的用户没有任何权限</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">##创建用户<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> myuser identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;mypassword&#x27;</span>;<br><br>##修改用户名<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;newname&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;myuser&#x27;</span>;<br>flush privileges;<br><br>##删除用户<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> newname;<br><br>##查看权限<br><span class="hljs-keyword">show</span> grants <span class="hljs-keyword">for</span> newname;<br><br>##授予权限<br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>, <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> newname;<br><br>##撤销权限<br><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span>, <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> newname;<br></code></pre></td></tr></table></figure><h3 id="5、存储过程"><a href="#5、存储过程" class="headerlink" title="5、存储过程"></a>5、存储过程</h3><p>存储过程可以看作是对一系列 sql 操作的批处理。存储过程可以由 触发器、其他存储过程以及Java、Python等应用程序调用。</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/60afdc9c9a594f079727ec64a2e698a3tplv-k3u1fbpfcp-zoom-1.image" alt="mysql存储过程" style="zoom: 67%;" /><p>​  GetAllProducts 就是一个存储过程，可以被调用</p><p>存储过程的好处：</p><ul><li>代码封装，提供了安全性</li><li>代码复用</li><li>预先编译，性能较高</li></ul><h3 id="6、游标（暂无）"><a href="#6、游标（暂无）" class="headerlink" title="6、游标（暂无）"></a>6、游标（暂无）</h3><h3 id="7、触发器"><a href="#7、触发器" class="headerlink" title="7、触发器"></a>7、触发器</h3><p>触发器是一种与表相关的数据库对象，当触发器所在表上发生某些特定事件时，就会调用该对象。</p><p><strong>优点：</strong></p><ul><li>触发器提供了另一种保证数据完整性的方式</li><li>触发器可以捕获数据库层中业务逻辑的错误</li><li>触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器</li><li>触发器对于审计表中数据的更改非常有用</li></ul><p><strong>缺点：</strong></p><ul><li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么</li><li>可能会增加数据库开销</li><li>触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create trigger &#x27;mytrigger&#x27; <br>after insert on &#x27;user&#x27;<br>for each row<br>begin<br>insert into &#x27;user_log&#x27; (user_id, user_name) values (new.id, &#x27;user&#x27;);<br>end<br><br>##新的行用new，旧的用 old ; 有 before insert、after insert、before update、after update、before delete、 after delete 六种触发时机 <br></code></pre></td></tr></table></figure><h2 id="三、MySQL"><a href="#三、MySQL" class="headerlink" title="三、MySQL"></a>三、MySQL</h2><h3 id="1、MySQL-优点"><a href="#1、MySQL-优点" class="headerlink" title="1、MySQL 优点"></a>1、MySQL 优点</h3><ul><li>开源免费</li><li>成熟稳定，功能完善</li><li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的</li><li>支持分库分表、读写分离、高可用</li><li>文档完善，学习资源丰富</li><li>兼容性好，支持常见的操作系统，支持多种开发语言</li><li>生态完善，社区活跃</li></ul><h3 id="2、MySQL基本架构"><a href="#2、MySQL基本架构" class="headerlink" title="2、MySQL基本架构"></a>2、MySQL基本架构</h3><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/13526879-3037b144ed09eb88.png" alt="img" style="zoom: 67%;" /><p>简单来说，分为两层，Server层和存储引擎层。</p><ul><li>server层有 连接器、查询缓存（MySQL 8 已删除）、分析器、优化器、执行器等。所有跨存储引擎的功能都在这一层实现，比如 存储过程、触发器、视图、函数等。还有一个通用的日志模块 binlog 日志模块。</li><li>存储引擎主要负责数据的存储和获取，采用可以替换的插件式架构。支持 InnoDB、MyISAM、Memory等存储引擎。目前的MySQL版本默认使用 InnoDB，其有自有的日志模块 redolog 模块。</li></ul><p>server层详解</p><ul><li>连接器：和身份验证、权限相关的功能有关，好比一个保安。 在用户登录数据库时，对密码进行验证，验证通过后，在权限表中查询该用户的所有权限，之后在这个连接中一直使用此时查询到的权限进行权限限制。也就是说，只要这次连接没有断开，就算修改了该用户的权限，也不影响此次连接。</li><li>查询缓存：当发现是 select 操作时，MySQL 先校验该查询语句之前是否执行过，如果执行过就返回缓存，没有执行就交给分析器执行后续操作，然后将结果放入缓存。缓存是以 key-value 的格式存储。（<strong>当然，就算是查询缓存也要校验权限</strong>）。 由于表中数据更新相关表的缓存就要全部清空，因此如果是在更新较频繁的场景，查询缓存带来了较大的额外开销。<strong>因此不推荐使用查询缓存，MySQL在 8 版本时已经删除了这个功能</strong></li><li>分析器：对 SQL 语句进行词法分析、语法分析</li><li>优化器：词法分析、语法分析完成后，如何执行才能性能最好效果最好就需要考虑了。优化器的作用就是它认为的最优的执行方案去执行，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</li><li>执行器：优化完成后，具体的执行逻辑已经确定下来了，MySQL就准备开始执行，首先执行前会校验用户有没有权限，如果没有权限，返回错误信息。如果校验通过，则调用存储引擎的接口，返回接口执行的结果。</li></ul><h3 id="3、SQL语句在MySQL中的执行过程"><a href="#3、SQL语句在MySQL中的执行过程" class="headerlink" title="3、SQL语句在MySQL中的执行过程"></a>3、SQL语句在MySQL中的执行过程</h3><p>语句分为两类，一类是查询语句（select），另一类是更新语句（update、insert、delete）</p><p>对于查询语句，执行过程为 连接器 -&gt; 权限校验（前提是缓存命中）-&gt; 查询缓存 (如没有缓存则下一步) -&gt; 分析器 -&gt; 优化器 -&gt; 执行器</p><p>对于更新语句，前半部分操作与查询语句相同，先查询出要修改的数据，然后对数据进行修改，然后调用引擎的接口，写入这一行数据。当然，由于是更新，所以要记录日志。</p><p>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit 状态)</p><p>以 InnoDB 引擎为例：</p><ul><li>先查询到数据，如果有缓存，也是会用到缓存。</li><li>然后拿到查询的数据进行修改，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ul><p><strong>为什么要两个日志?</strong></p><p>因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p><p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。</p><p><strong>为什么redo log 要先进入 prepare 状态,等 binlog 记录后才提交?</strong></p><p>用反证法来说明下为什么要这么做？</p><ul><li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><h3 id="4、MySQL-存储引擎"><a href="#4、MySQL-存储引擎" class="headerlink" title="4、MySQL 存储引擎"></a>4、MySQL 存储引擎</h3><ul><li>show engines 命令可以查询支持的所有引擎</li><li>MySQL 5.5.5 版本以前默认存储引擎是 MyISAM, 之后的默认引擎是 InnoDB</li></ul><h4 id="MySQL存储引擎的架构"><a href="#MySQL存储引擎的架构" class="headerlink" title="MySQL存储引擎的架构"></a>MySQL存储引擎的架构</h4><p>存储引擎采用插件式架构,支持多种存储引擎. 我们甚至可以为不同的表设置不同的存储引擎来适应不同的场景.存储引擎是基于表的,不是基于数据库.</p><h4 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a>MyISAM 和 InnoDB 的区别</h4><ul><li>MyISAM 只支持表级锁，InnoDB支持行级锁和表级锁，默认为行级锁</li><li>MyISAM 不提供事务支持，InnoDB 提供事务支持，实现了 SQL 标准定义的四种隔离级别，具有 commit、rollback 功能，默认为 可重复读（Repeatable-Read），但是可以解决幻读问题（一般可重复读只是解决了 脏读和不可重复读两个问题，没有解决幻读问题），使用 MVCC、Next-Key Lock 实现</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，InnoDB 支持，依赖于 redo log </li><li>MyISAM 不支持 MVCC，InnoDB 支持</li><li>MyISAM 不支持外键，InnoDB 支持</li><li>MyISAM 性能低于 InnoDB </li><li>二者虽都使用 B+ 树作为索引结构，但实现方式不一样</li></ul><h3 id="5、记录存储的行格式"><a href="#5、记录存储的行格式" class="headerlink" title="5、记录存储的行格式"></a>5、记录存储的行格式</h3><p><img src="/lulalula/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/COMPACT.drawio.png" alt="img"></p><p><a href="https://xiaolincoding.com/mysql/base/row_format.html#innodb-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">MySQL 一行记录是怎么存储的？ | 小林coding (xiaolincoding.com)</a></p><h3 id="6、MySQL索引"><a href="#6、MySQL索引" class="headerlink" title="6、MySQL索引"></a>6、MySQL索引</h3><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>为什么选用 B+ 树？而不是 B 树、平衡二叉树、二叉树、Hash</p><p>B+ 树只在叶子节点存储数据，非叶子节点只存索引，相较于B 树的节点既存索引又存数据，B+ 树的非叶子节点可以存储更多的索引，因此 B+ 树更加“矮胖”，查询数据时磁盘 I&#x2F;O 次数少</p><p>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引，因为某节点的索引在子节点中都存在），这些冗余索引让 B+ 树在插入、删除地效率更高，而 B树 在插入删除时会发生复杂的树的变化</p><p>B+ 树的所有叶子节点之间用双向链表进行了连接，有利于范围查询，而 B树要进行范围查询则只能通过遍历实现</p><p>对于平衡二叉树、二叉树等各种各样的二叉类型树，在数据量稍大时，树的高度很高，性能很差</p><p>Hash 只适合等值查询，不适合范围查询</p><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><p>索引就是数据的目录，是帮助存储引擎快速获取数据的一种数据结构</p><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><p>（1）按照<strong>数据结构</strong>分类：B+树索引、Hash索引、Full-Text索引</p><p>Mysql 默认支持的 InnoDB 只支持 B+树索引和 Full-text 索引，不支持 Hash 索引，MyISAM 也是</p><p>（2）按照<strong>物理存储</strong>分类：聚簇索引、二级索引（辅助索引）</p><p>InnoDB下， 聚簇索引是每张表一定有的</p><ul><li>如果有主键，默认使用主键作为聚簇索引的索引键key</li><li>如果没有主键，则使用第一个不包含 null 的 unique 列作为索引键</li><li>如果都没有，则 InnoDB 自动生成一个隐式自增的 id 作为索引键</li></ul><p>其他索引都属于二级索引，二级索引也是 B+ 树，<strong>与聚簇索引的 B+ 树叶子节点存数据不同，二级索引的 B+ 树的叶子节点存的是目标记录的主键值</strong>，在查到主键值时，再进行聚簇索引查询，查到目标记录，这个过程也叫做<strong>回表</strong>。但是如果查询的目标就是主键，则二级索引就可以查得到，就不用再回表，这个叫 <strong>索引覆盖</strong>。</p><p>（3）按照<strong>字段特性</strong>分类：主键索引、唯一索引、普通索引、前缀索引</p><p>唯一索引就是字段值不重复，可以有 null，但是只能有一个</p><p>前缀索引就是以字段的前缀作为索引，目的是减小索引占用的空间，提升效率</p><p>（4）按照<strong>字段数量</strong>分类：单列索引、联合索引</p><p>联合索引存在最左匹配原则，先从最左边的排序，然后右边的依次编序。按照最左优先的方式进行索引的匹配。如果不遵循最左匹配原则，则索引失效。</p><p>比如有一个联合索引 （a，b，c），这几种情况就可以匹配的到：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p>但是如果缺失最左的，用右边的匹配则失效：</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p><strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong>。</p><p><strong>索引下推优化</strong>：</p><p>在联合索引查询时，对于联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。（注意，是减少回表次数，但是仍然要回表判断b）</li></ul><h4 id="什么时候需要-不需要索引（针对字段）"><a href="#什么时候需要-不需要索引（针对字段）" class="headerlink" title="什么时候需要&#x2F;不需要索引（针对字段）"></a>什么时候需要&#x2F;不需要索引（针对字段）</h4><p>索引并不一定总是好的，因为 </p><ul><li>索引需要占用物理空间 </li><li>索引创建、维护需要成本</li><li>降低增删改的效率，因为在增删改时 B+ 树为了保证索引的有序，需要动态维护</li></ul><p>适合索引的场景：</p><ul><li>字段有唯一性限制</li><li>经常作为 where 查询条件的字段</li><li>经常用于 group by 、order by 的字段，这样在查询的时候就不需要再去做一次排序了，因为B+树就是有序的</li></ul><p>不需要索引的场景：</p><ul><li>where、group by、order by 使用不到的字段</li><li>字段中存在大量重复的，比如性别，创建索引没有意义</li><li>表数据太少的</li><li>经常更新的字段不需要索引，因为每次更新都要维护索引</li></ul><h4 id="索引优化方法"><a href="#索引优化方法" class="headerlink" title="索引优化方法"></a>索引优化方法</h4><ul><li>前缀索引优化</li></ul><p>使用某个字段的前缀作为索引，这样可以减小索引字段的大小，一个索引页中的索引就会变多，从而查询效率就会提高</p><p>不过有局限性：order by 无法使用前缀索引、无法把前缀索引用作覆盖索引（因为就算查到了，前缀也只是部分数据，还是得回表查完整数据）</p><ul><li>覆盖索引优化</li></ul><p>意思就是尽量使查询的字段可以在二级索引中直接获得，避免回表</p><p>比如只需要查询商品的名称、价格，可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p><ul><li>主键索引最好是自增的</li></ul><p>因为B+ 树的索引本身是有序的，在插入操作中，如果主键索引是自增的，则直接插入到后面就行，但是如果不是自增的，则可能插在中间，造成页分裂（不详解了）</p><ul><li>索引字段长度尽量短</li><li>索引最好设置为 not null</li></ul><p>① 索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化</p><p>② NULL 值是一个没意义的值，但是它会占用物理空间（行格式 NULL 值列表有关）</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ul><li>对索引使用左或者左右模糊匹配    like ‘%aa’   或者  like ‘%AA%’</li><li>对索引使用函数</li><li>对索引进行表达式计算</li><li>联合索引非最左匹配</li><li>where 语句中的 or</li><li>对索引进行隐式类型转换：<strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//phone本身是varchar   id是int<br>//失效  因为phone每次比较前会转换为数字，相当于对phone进行了函数计算<br>select * from t_user where phone = 1300000001;<br>//不失效   因为字符串会转为数字 &#x27;1&#x27; 会转为数字 1<br>select * from t_user where id = &#x27;1&#x27;;<br></code></pre></td></tr></table></figure><h4 id="count-、count-1-、count-主键-、count-字段-性能"><a href="#count-、count-1-、count-主键-、count-字段-性能" class="headerlink" title="count(*)、count(1)、count(主键)、count(字段)性能"></a>count(*)、count(1)、count(主键)、count(字段)性能</h4><p>count(*) &#x3D; count(1) &gt; count(主键) &gt; count(字段)</p><p>count(*) 就是 count(0) </p><p>count(1) 只需要读取记录，但是不会读取记录中的字段的值。而count(主键)需要读字段的值，所以性能稍差。count(1)不排除字段为null</p><p>count(字段) 字段是非索引，是普通字段，所以不会使用索引查询，而是全表扫描</p><h3 id="7、MySQL日志"><a href="#7、MySQL日志" class="headerlink" title="7、MySQL日志"></a>7、MySQL日志</h3><p>MySql</p><h3 id="8、MySQL事务"><a href="#8、MySQL事务" class="headerlink" title="8、MySQL事务"></a>8、MySQL事务</h3><p>事务是由MySQL 的引擎来实现的，常见的InnoDB就是支持事务的，但是 MyISAM不支持事务</p><h4 id="开启事务的两种命令"><a href="#开启事务的两种命令" class="headerlink" title="开启事务的两种命令"></a>开启事务的两种命令</h4><ul><li>begin &#x2F; start transaction ：并不代表事务真正启动了，直到执行这个命令之后执行了具体的 SQL，事务才是真正的启动 </li><li>start transaction with consistent snapshot：立即启动事务</li></ul><h4 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><ul><li>原子性（Atomicity）：事务要么一次性全部执行完，要么都不执行。如果执行中间发生错误，事务回滚</li><li>一致性（Consistency）：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。换一种解释，<strong>事务操作前后的结果应与所抽象的客观世界真实状况保持一致</strong>。比如说转账，转完后就应该一方减少一方增加</li><li>隔离性（Isolation）：数据库允许多个并发事务同时操作数据库，多个并发事务操作同一数据时，互相不会产生干扰，也就是并发事务被“隔离”开了</li><li>持久性（Durability）：事务处理结束后，对数据库的修改就是永久的， 即使系统故障也不会丢</li></ul><p>InnoDB通过不同技术保证这四个特性：</p><ol><li>原子性通过 undo log（回滚日志）来保证</li><li>持久性通过 redo log（重做日志）来保证</li><li>隔离性通过MVCC（Multi-version Concurrency Control，多版本并发控制）或者锁机制来实现</li><li>一致性通过 原子性 + 持久性 + 隔离性 来保证</li></ol><h4 id="并发事务导致的问题"><a href="#并发事务导致的问题" class="headerlink" title="并发事务导致的问题"></a>并发事务导致的问题</h4><ul><li>脏读（dirty read）：A 事务修改了数据，但是事务还未提交，B此时读到了A修改后的数据，结果A发生了错误，回滚了，那么B之前读到的数据就是错误的，也就是脏读</li><li>不可重复读（non-repeatable read）：A 事务读取了数据，然后B对这个数据进行了修改，提交了事务，A再次读这个数据时，发现与之前读的不同了</li><li>幻读（phantom read）：A 事务查询了符合某个条件的多条记录，接着 B 事务增加了一条满足这个条件的记录，A 再次查询时，发现记录数和之前不一致了</li></ul><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>读未提交（read uncommitted）：一个事务还没有提交，它做的变更其他事务就可以看到</p><p>读提交（read committed）：一个事务只有提交了，它做的变更其他事务才可以看到</p><p>可重复读（repeatable read）：一个事务开始了，在执行期间读到的数据都与开始时读到的数据一致。<strong>InnoDB默认的隔离级别</strong></p><p>串行化（serializable）：会对记录加上读写锁，如果有事务在操作这条记录，其他事务就需要等待，直到占有锁的事务结束</p><h4 id="四种隔离级别的实现"><a href="#四种隔离级别的实现" class="headerlink" title="四种隔离级别的实现"></a>四种隔离级别的实现</h4><p>读未提交：因为可以读到未提交事务修改的数据，所以直接读最新的数据就可以</p><p>串行化：通过加锁操作来实现</p><p>读提交、可重复读：通过 Read View 实现，区别在于创建 Read View 的时机不同。<strong>Read View 可以看作是一个数据快照，定格某一时刻的数据状态</strong>。    读提交是在每条语句执行之前创建 Read View，也就是说，一个事务中可以创建多个 Read View；可重复读是在事务启动时创建 Read View，然后整个事务期间就使用这一个 Read View。</p><h4 id="Read-View-在-MVCC-中如何工作"><a href="#Read-View-在-MVCC-中如何工作" class="headerlink" title="Read View 在 MVCC 中如何工作"></a>Read View 在 MVCC 中如何工作</h4><p>Read View 有四个字段：</p><ul><li>creator_trx_id（创建这个快照的事务 id）</li><li>m_ids（所有未提交活跃的事务 id）</li><li>min_trx_id（所有活跃的事务中最小的 id）</li><li>max_trx_id（所有活跃的事务中最大的 id + 1，也就是准备给下一个事务分配的id）</li></ul><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:50%;" /><p>在之前了解的记录存储的行格式中，有两个字段 </p><ul><li><p>trx_id：修改这条记录的事务 id </p></li><li><p>roll_pointer：每次对记录进行修改时，就会把旧版本的记录写入到 undo 日志中（回滚日志），然后 roll_pointer 就是指向上一个旧版本的记录，通过这个指针，就可以实现回滚操作</p></li></ul><p>举个例子，原本有条记录是被事务 id 为 50 的事务修改的，则此时的行格式为</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230720104114543.png" alt="image-20230720104114543" style="zoom: 33%;" /><p>此时有一个事务 id 为51的事务A对记录做了修改，则变为：</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230720104153167.png" alt="image-20230720104153167" style="zoom:33%;" /><p>可以很明确的看到 roll_pointer 的作用</p><p><em><strong>Read View 如何工作就是依靠 自己的四个字段和记录中的 trx_id 和 roll_pointer</strong></em></p><p>当发现 <strong>trx_id 小于 Read View 中的 min_trx_id</strong> 时，说明这条记录是被<strong>已经提交的事务修改</strong>的，所以这个版本的记录对当前事务是<strong>可见</strong>的。</p><p>当发现 <strong>min_trx_id &#x3D;&lt; trx_id &lt; max_trx_id</strong> 时，如果 <strong>trx_id 在 m_ids 中</strong>，说明这条记录是未提交事务修改的， 对当前事务<strong>不可见</strong>；如果<strong>不在 m_ids 中</strong>，则说明是<strong>已提交事务修改</strong>的，则这个版本的记录对当前事务是<strong>可见</strong>的。</p><p>当发现 <strong>max_trx_id &#x3D;&lt; trx_id</strong> 时，说明这条记录是 <strong>Read View 创建以后新启动的事务修改</strong>的，则这个版本记录对当前事务<strong>不可见</strong>。</p><p>具体举例细节看：<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">事务隔离级别是怎么实现的？ | 小林coding (xiaolincoding.com)</a>    讲的非常详细</p><h4 id="MySQL可重复读隔离级别并没有完全解决幻读问题"><a href="#MySQL可重复读隔离级别并没有完全解决幻读问题" class="headerlink" title="MySQL可重复读隔离级别并没有完全解决幻读问题"></a>MySQL可重复读隔离级别并没有完全解决幻读问题</h4><p>InnoDB 引擎默认的隔离级别是可重复读，但是在很大程度上避免了幻读现象，主要是通过两种解决方案：</p><ul><li>快照读（普通 select 语句）：通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，Read View 是在事务开始时创建，整个事务运行期间都使用同一个，所以就算有事务插入或者删除了记录，当前事务也感知不到</li><li>当前读（select ··· for update 等语句）：通过 next-key lock（记录锁 + 间隙锁）方式解决幻读。因为在执行 select···for update 语句时，会加上 next-key lock ，其他事务在锁范围内插入删除数据就会被阻塞，无法成功，会生成一个插入意向锁。</li></ul><p>但是这两种并不能完全解决幻读问题，具体看  <a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF">MySQL 可重复读隔离级别，完全解决幻读了吗？</a></p><h3 id="9、MySQL-锁"><a href="#9、MySQL-锁" class="headerlink" title="9、MySQL 锁"></a>9、MySQL 锁</h3><p>根据加锁的范围，MySQL 锁可以分为 全局锁、表级锁、行级锁</p><h4 id="MySQL有哪些锁"><a href="#MySQL有哪些锁" class="headerlink" title="MySQL有哪些锁"></a>MySQL有哪些锁</h4><h5 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h5><ol><li>全局锁的开启： flush tables with read lock             释放全局锁：unlock tables</li><li>全局锁一旦开启，整个数据库就处于只读状态了，此时再执行各种 DDL（drop、alter），DML（insert、delete、update）等就会被阻塞。</li><li>全局锁的应用场景：用于全库逻辑备份，这样在备份过程中，不会因为数据或者表结构的更新而导致备份与预期不一致</li><li>全局锁的缺点：加锁时，整个数据库处于只读状态，如果有很多数据，备份时间会很长，这样可能会严重影响业务</li><li>MySQL 默认支持的 InnoDB 引擎，支持可重复读隔离级别，在备份数据前，开启事务，会创建一个 Read View，由于整个事务执行期间，都只会使用这同一个 Read View，所以就算其他事务做了修改，对当前事务也没有影响。而且由于 MVCC 的支持，备份期间仍然可以对数据进行更新操作。</li></ol><ul><li><strong>InnoDB 可以使用这种方式来进行备份操作，因为它的隔离级别是可重复读，支持 MVCC</strong></li><li><strong>但是 MyISAM 不支持事务，就只能使用全局锁。</strong></li></ul><h5 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h5><p>表级锁有以下几种：表锁、元数据锁、意向锁、AUTO-INC锁</p><h6 id="（1）表锁"><a href="#（1）表锁" class="headerlink" title="（1）表锁"></a>（1）表锁</h6><p>表锁有 共享锁（读锁）、独占锁（写锁）</p><p><strong>表锁除了会限制别的线程以外，也会限制本线程接下来的操作</strong></p><p>尽量避免在使用 InnoDB 引擎时使用表锁，因为表锁的颗粒度太大，而 InnoDB 支持行锁</p><h6 id="（2）元数据锁（MDL）"><a href="#（2）元数据锁（MDL）" class="headerlink" title="（2）元数据锁（MDL）"></a>（2）元数据锁（MDL）</h6><p>MDL 不需要显式的使用，在对数据库进行操作时，会自动给这个表加上 MDL</p><ul><li>对一张表进行 CRUD 时，加的是 MDL 读锁</li><li>对一张表结构进行改变时，加的是 MDL 写锁</li></ul><p><strong>MDL 是为了保证当用户执行 CRUD 时，防止其他线程修改表的结构</strong></p><p>MDL 读锁和 MDL 写锁冲突</p><p> MDL 在事务结束时才会释放，应该尽量避免长事务</p><p><em><strong>如果有线程进行 CRUD，加了 MDL 读锁，其他线程执行 CRUD 不受影响。但是当此时有其他线程修改表结构，申请MDL 写锁失败时，后续执行任何操作都会被阻塞。原因在于，不论是 MDL 读锁还是写锁，申请时都会形成一个队列，而申请写锁的优先级更高，尽管后续申请的读锁与此时加的读锁不冲突。但是仍会阻塞。</strong></em></p><h6 id="（3）意向锁"><a href="#（3）意向锁" class="headerlink" title="（3）意向锁"></a>（3）意向锁</h6><ul><li>在使用 InnoDB 的表里对某些记录加上<strong>共享锁（行级）</strong>之前，需要在表级先加上一个<strong>意向共享锁</strong></li><li>对某些记录加上<strong>独占锁（行级）</strong>之前，需要在表级先加上一个<strong>意向独占锁</strong></li></ul><p>但是，一般的 select 都是利用 MVCC 实现一致性读，是无锁的。</p><p>所以意向锁主要针对 update、insert、update 操作。但是也可以手动对 select 操作加上意向锁</p><p><strong>意向锁是表级锁，而共享锁和独占锁是行级锁，因此不会产生冲突。<em>意向锁之间也不会产生冲突</em>， 意向锁只会和共享表锁、独占表锁差生冲突</strong></p><p><strong>意向锁存在的目的是为了快速判断表中是否有记录被加锁。如果没有意向锁，在对一张表加独占表锁（表级）之前，需要遍历所有的记录，看有没有记录加了独占锁（行级）。而有了意向锁之后，在记录加独占锁之前，先加了意向独占锁，后续线程只需要看有没有意向锁就可以。极大提升了效率。</strong></p><h6 id="（4）AUTO-INC锁"><a href="#（4）AUTO-INC锁" class="headerlink" title="（4）AUTO-INC锁"></a>（4）AUTO-INC锁</h6><p>表的主键一般都设置为 AUTO_INCREMENT，之后在插入数据时可以不指定主键值，数据库会自动给其赋递增的值，这就是通过 AUTO-INC 锁实现的。</p><p><strong>AUTO-INC锁是特殊的表锁机制</strong>，锁不是在事务结束时才释放，而是执行完插入操作就立即释放。</p><p>当一个事务持有 AUTO-INC 锁时，其他事务的插入操作会被阻塞，当有大量插入操作时，会严重影响性能。</p><p>因此，后来 InnoDB 提供了一种更轻量级的锁来实现自增，<strong>在插入数据时，在自增字段加上轻量级锁，一旦字段自增值赋值完成就立即释放，而不用等到插入操作完成后再释放。</strong></p><p><strong>当使用轻量级锁时，并且 binlog_format &#x3D; row 时，既能提升并发性，又不会出现数据一致性问题</strong>。</p><h5 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h5><p>InnoDB 支持行级锁，而 MyISAM 不支持</p><p>普通 select 语句使用快照读，所以不会加锁，如果要手动加锁则使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ··· lock <span class="hljs-keyword">in</span> share mode              <span class="hljs-operator">/</span><span class="hljs-operator">/</span>共享锁<br><span class="hljs-keyword">select</span> ··· <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>                      <span class="hljs-operator">/</span><span class="hljs-operator">/</span>独占锁<br></code></pre></td></tr></table></figure><p>行级锁有四种：</p><ul><li>Record Lock：记录锁，锁住某一条记录</li><li>Gap Lock：间隙锁，锁定一个范围，左右边界都不包含，也就是说不锁住记录</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁住范围的同时锁住右边界的记录</li><li>插入意向锁（先不管）：一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，将其状态置为等待状态，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</li></ul><p>注意几点：</p><ul><li>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥，<strong>因为间隙锁的目的就是为了防止插入记录而造成幻读</strong></li><li><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。因为要考虑 next-key lock 中记录也加锁</li><li>插入意向锁并不是真正的意向锁，<strong>意向锁是表级锁，而插入意向锁是行级锁</strong>。同时，事务生成的插入意向锁状态为等待状态，意味着事务并未真正获得这个锁，只是创建了。</li><li>两个事务不能在同一时间内，一个拥有间隙锁，一个拥有这个间隙范围内的插入共享锁</li></ul><h4 id="MySQL是如何加锁的"><a href="#MySQL是如何加锁的" class="headerlink" title="MySQL是如何加锁的"></a>MySQL是如何加锁的</h4><p><strong>MySQL 加锁的对象是索引，加锁的基本单位是 next-key lock</strong></p><p>不过在不同情况下，next-key lock 可能会退化为 record lock 或者 gap lock</p><p>详见<a href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#mysql-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84">MySQL 是怎么加锁的？</a></p><h4 id="update没加索引会锁全表？"><a href="#update没加索引会锁全表？" class="headerlink" title="update没加索引会锁全表？"></a>update没加索引会锁全表？</h4><p><strong>如果没加索引，或者索引失效，而导致了全表扫描，此时，会给所有记录加上 next-key lock，看起来就像是给全表加了锁，但实际上并不是表级锁。</strong></p><p>如何避免？</p><ul><li>可以将 MySQL 里的 <code>sql_safe_updates</code> 参数设置为 1，开启安全更新模式。</li><li>如果 where 里的字段是索引，但是优化器选择了全表扫描，此时就可以使用 force index（[ index_name ]） 告诉优化器强制使用某个索引</li></ul><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>死锁的四个条件：资源互斥、持有且等待、不可剥夺、循环等待</p><p>破坏其中任何一个条件死锁就不会成立</p><p>一般使用的手段是：</p><ul><li>设置事务等待锁的超时时间：事务等待锁超过一定时间后，就进行回滚，手中的锁就释放掉了。在 InnoDB 中，默认是50秒</li><li>开启主动死锁检测：主动死锁检测在发现死锁发生时，手动回滚死锁链条中的某一个事务，让其他事务执行</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="一、什么是Spring？Spring的作用是什么？"><a href="#一、什么是Spring？Spring的作用是什么？" class="headerlink" title="一、什么是Spring？Spring的作用是什么？"></a>一、什么是Spring？Spring的作用是什么？</h2><p>​（1）Spring是一个轻量级的开源框架（轻量：jar包少），是为解决企业应用开发的复杂性而提出的。一般说的Spring框架都是指 Spring Framework，是多模块的集合。框架就是将一些基础的东西封装起来，开箱即用，同时提供了拓展性，可以很好的集成其他组件框架。</p><p>​比如说 Spring 支持 IOC（Inversion Of Control ，控制反转）和 AOP（Aspect-Oriented Programming，面向切面编程）、可以很方便的对数据库进行访问、可以很方便集成第三方组件（邮件、任务、调度等）、对单元测试友好、支持RESTful Java 应用程序的开发。</p><p>​Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。</p><p>​（2）Core Container 是 Spring的核心模块，也就是基础模块，主要提供 IOC 依赖注入等功能的支持。Spring的其他所有基本都依赖于核心模块。Core Container 中有四个：</p><ul><li><p>spring-core：Spring 框架基本的核心工具类</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230714102519947.png" alt="image-20230714102519947" style="zoom: 67%;" /></li><li><p>spring-beans：提供对有关 bean 创建、配置和管理等功能的支持</p><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230714102832977.png" alt="image-20230714102832977" style="zoom:50%;" /></li><li><p>spirng-context：提供国际化、事件传播、资源加载等功能的支持</p></li></ul><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230714102945652.png" alt="image-20230714102945652" style="zoom: 67%;" /><ul><li>spring-expression：提供对 表达式语言 Spring Expression Language（SpEL）的支持，只依赖于 spring-core 模块，可以直接使用</li></ul><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230714103606917.png" alt="image-20230714103606917" style="zoom: 67%;" /><p>​</p><p>​</p><h2 id="二、Spring-IOC"><a href="#二、Spring-IOC" class="headerlink" title="二、Spring IOC"></a>二、Spring IOC</h2><h3 id="1、什么是IOC"><a href="#1、什么是IOC" class="headerlink" title="1、什么是IOC"></a>1、什么是IOC</h3><p>IOC 是一种设计思想（并非 Spring 独有），而不是一个具体的技术实现。该思想就是将原本在程序中手动创建对象的控制权，交由类似 Spring 这样的框架来管理。这样，程序员无需再考虑什么时候应该创建对象，应该如何创建对象，需要的时候直接从 IOC 容器中拿就行。   IOC 容器实际上是一个 map，value就是各种对象，key就是该对象的唯一标识。</p><p><strong>为什么叫控制反转？</strong></p><ul><li>控制：指的是对象操作（实例化、初始化、管理、销毁等）的权利</li><li>反转：将这个权力交给外部环境（Spring 框架等）</li></ul><p>在实际开发过程中，对象之间的依赖关系十分复杂，如果完全由程序员把控，则十分消耗时间精力。将对象之间的依赖关系交由 IOC 容器来管理，并且由 IOC 容器完成对象的注入，可以极大程度上简化开发。IOC 容器就像一个对象工厂，我们只需要配置好配置文件或者注解，完全不用考虑对象是什么时候创建的是怎样创建的，IOC 容器会帮我们完成这一切，在需要使用对象的时候，容器也会帮我们注入好。</p><h3 id="2、什么是-Spring-Bean"><a href="#2、什么是-Spring-Bean" class="headerlink" title="2、什么是 Spring Bean"></a>2、什么是 Spring Bean</h3><p>简单来说，就是那些交给 IOC 容器进行管理的对象。 我们需要告诉 IOC 容器帮我们管理哪些对象，通过配置元数据来定义，可以是 XML、注解或者配置类。</p><h3 id="3、-Component-和-Bean-的区别"><a href="#3、-Component-和-Bean-的区别" class="headerlink" title="3、@Component 和 @Bean 的区别"></a>3、@Component 和 @Bean 的区别</h3><ul><li>@Component 注解作用于类，@Bean 注解作用于方法</li><li>@Component 注解是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中。 （通过 @ComponentScan 注解来指明要扫描的路径），从指定的扫描路径开始扫描，找出标识了@Component注解的类（也就是需要装配到容器中的）。         @Bean 注解作用于方法，一般是在配置类的方法上使用，表明该方法的返回值对象需要交给容器管理。该方法 Spring 只会调用一次。</li><li>@Bean注解比 @Component 注解的自定义性更强，很多地方都只能只用 @Bean 。 比如 @Component 注解只能在自己编写的类上进行使用，对第三方库的类就没法使用，而 @Bean 可以。</li></ul><h3 id="4、注入Bean的注解"><a href="#4、注入Bean的注解" class="headerlink" title="4、注入Bean的注解"></a>4、注入Bean的注解</h3><p>@Autowired</p><ul><li>是 Spring 内置的注解，默认注入为 byType（根据类型），但是当容器中有多个同类型的 Bean 时（一个接口多个实现类，注入时写的是接口），就会转为 byName。如果 byName 还是没找到，报错。</li><li>可以和 @Qualifier 注解搭配使用，@Qualifier 注解有一个 value 属性，当 @Autowired 根据 type 找到多个 Bean 时，再根据 @Qualifier 的 value 进行 byName 查找。  （<strong>推荐使用</strong>）</li></ul><p>@Resource</p><ul><li>@Resource 是 JDK 提供的注解，默认注入方式为 byName，如果根据 byName 匹配不到相关的 Bean，则转为 byType</li><li>@Resource 有两个属性 name 和 type，如果仅指定了 name，则根据名字来找。 如果仅指定了 type，则根据类型来找。</li></ul><h3 id="5、Bean-的作用域"><a href="#5、Bean-的作用域" class="headerlink" title="5、Bean 的作用域"></a>5、Bean 的作用域</h3><p>常见的作用域有 singleton、prototype</p><ul><li>singleton：IOC 容器在创建的时候就会同时会创建一个该 bean 实例（如果 lazy-init &#x3D; true 则代表懒加载，在使用时才会创建 bean），并且只会创建这一个（单例），当后续使用时，拿到的都是同一个bean。默认情况不特殊指定都是 singleton</li><li>prototype：每次从 IOC 容器中获取时，都会返回一个新的 bean 实例，每次拿到的都是不同的。</li><li>request：每次 HTTP 请求都会新建一个 bean ，该 bean 只在本次 HTTP 请求中有效。该作用域仅适用于使用 web 的 Spring WebApplicationContext环境</li><li>session：同一个 Http Session 共享同一个 bean，该 bean 只在本次 session 会话期间有限。该作用域仅适用于使用 web 的 Spring WebApplicationContext环境</li><li>application：每个 web 应用在启动时创建一个 bean，在应用结束之前一直有效。该作用域仅适用于使用 web 的 Spring WebApplicationContext环境</li></ul><p>**<u>controller方法中的 HttpSession、HttpRequest 参数注入，应该就是 session 和 request 作用域</u>**（不确定）</p><h3 id="6、Bean-是否线程安全"><a href="#6、Bean-是否线程安全" class="headerlink" title="6、Bean 是否线程安全"></a>6、Bean 是否线程安全</h3><p>Bean 是否线程安全取决于<strong>作用域</strong>和<strong>状态</strong>，对于 prototype 作用域的 bean 来说，每次获取的都是新的 bean，就不存在资源竞争，因此是线程安全的。</p><p>而对于 singleton 作用域的 bean 来说，如果它是无状态的（即不包含可变的成员变量），则是线程安全的（比如Service）。如果是有状态的则线程不安全。</p><p>对于 singleton 作用域、有状态的 bean，解决其线程安全问题一般有两种办法：1、尽量避免在 bean 中有可变的成员变量    2、在类中定义一个 <code>ThreadLocal</code> 成员变量，使用 ThreadLocal 保存可变的成员变量（推荐）</p><p>**<u><em>controller 是单例</em></u>**，所以是线程不安全的。尽量避免在 controller 中使用可变的成员变量。单例 controller 可以支持多线程并发访问，单例与多线程并无关系。</p><h3 id="7、Bean-的生命周期"><a href="#7、Bean-的生命周期" class="headerlink" title="7、Bean 的生命周期"></a>7、Bean 的生命周期</h3><ul><li>实例化</li><li>属性赋值</li><li>如果实现了*Aware接口，调用相应方法</li><li>如果有的话，调用 BeanPostProcessor 对象的 postProcessBeforeInitialization() 方法</li><li>如果实现了 Init ializingBean 接口，则执行 afterPropertiesSet() 方法</li><li>如果 Bean 配置了 init-method，则调用自定义的初始化方法 init-method</li><li>调用 BeanPostProcessor 对象的 postProcessAfterInitialization() 方法</li><li>使用 Bean</li><li>销毁 Bean 时，如果实现了 DisposableBean 接口，则执行 destroy() 方法</li><li>销毁 Bean 时，如果配置了 destroy-method，则执行指定方法</li></ul><p><img src="/lulalula/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/b5d264565657a5395c2781081a7483e1.jpg" alt="Spring Bean 生命周期"></p><h2 id="三、Spring-AOP"><a href="#三、Spring-AOP" class="headerlink" title="三、Spring  AOP"></a>三、Spring  AOP</h2><h3 id="1、对AOP的理解"><a href="#1、对AOP的理解" class="headerlink" title="1、对AOP的理解"></a>1、对AOP的理解</h3><p>AOP（Aspect-Oriented Programming）面向切面编程，能够将那些与业务无关的，但是业务模块共同调用的逻辑或责任（例如 事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块之间的耦合度，同时十分重要的是，有利于拓展和维护。</p><p>Spring AOP 对于要代理的对象，如果该对象实现了某个接口，则使用JDK动态代理；如果该对象没有实现接口，则使用Cglib代理（代理对象继承被代理对象）</p><h3 id="2、Spring-AOP-和-AspectJ-的区别"><a href="#2、Spring-AOP-和-AspectJ-的区别" class="headerlink" title="2、Spring AOP 和 AspectJ 的区别"></a>2、Spring AOP 和 AspectJ 的区别</h3><ul><li>Spring AOP 属于运行时增强，通过创建代理类实现功能织入；而 AspectJ 是编译时增强，基于字节码操作，在运行前进行织入（分为编译时织入、编译后织入、加载时织入），需要 AspectJ 编译器 ajc 的支持。   编译时增强效率更高。</li><li>因为织入方式的不同，两者支持的 Jointpoint 也是不同的。像 final 方法、静态方法这些，是不能通过代理实现织入的，而 AspectJ 支持，因为它是在运行前进行织入，操作的是字节码。</li></ul><h3 id="3、AspectJ-定义的通知类型"><a href="#3、AspectJ-定义的通知类型" class="headerlink" title="3、AspectJ 定义的通知类型"></a>3、AspectJ 定义的通知类型</h3><ul><li>Before（前置通知）：目标对象的目标方法调用前触发</li><li>After（后置通知）：目标对象的目标方法调用之后触发</li><li>AfterReturning（返回通知）：目标对象的目标方法正确返回之后触发</li><li>AfterThrowing（异常通知）：目标对象的目标方法抛出 &#x2F; 触发异常之后触发（与AfterReturning互斥）</li><li>Around（环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li></ul><h3 id="4、多个切面的执行顺序"><a href="#4、多个切面的执行顺序" class="headerlink" title="4、多个切面的执行顺序"></a>4、多个切面的执行顺序</h3><p>通过 @Order 注解配置，值越小优先级越高</p><h2 id="四、Spring-MVC"><a href="#四、Spring-MVC" class="headerlink" title="四、Spring MVC"></a>四、Spring MVC</h2><h3 id="1、对-Spring-MVC的理解"><a href="#1、对-Spring-MVC的理解" class="headerlink" title="1、对 Spring MVC的理解"></a>1、对 Spring MVC的理解</h3><p>MVC 是一种设计模式，将业务逻辑、数据、显示分离来组织代码，可以帮助进行更简洁的 Web 层的开发，天生与 Spring 框架集成。</p><h3 id="2、Spring-MVC-的工作原理（流程）"><a href="#2、Spring-MVC-的工作原理（流程）" class="headerlink" title="2、Spring MVC 的工作原理（流程）"></a>2、Spring MVC 的工作原理（流程）</h3><p>先明确 SpringMVC 的重要的组件</p><ul><li>DispatcherServlet 前端控制器：核心的中心处理器，负责接受请求、转发请求、响应结果。相当于转发器，核心组件，减少其他组件的耦合度</li><li>HandlerMapping 处理器映射器：根据 uri 去查找能处理本次请求的 handler，并将请求涉及到的拦截器和 handler 一起封装</li><li>HandlerAdapter 处理器适配器：根据 HandlerMapping 映射到的 handler，适配执行对应的 handler。handler 会返回一个 ModelAndView 对象</li><li>Handler : 程序员自己编写的请求处理器，实际处理请求</li><li>ViewResolver 视图解析器：根据 Handler 返回的逻辑视图&#x2F;视图进行解析，解析并渲染得到真正的视图，并传递给 DispatcherServlet 用于响应返回。</li></ul><p><strong>执行流程：</strong></p><ul><li>客户端发送请求，DispatcherServlet 拦截请求</li><li>DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 uri 去匹配查找能够真正处理请求的 Handler（即 Controller 控制器），并将请求涉及到的拦截器 和 Handler 一块封装，返回给 DispatcherServlet</li><li>DispatcherServlet 调用 HandlerAdapter 适配器执行 Handler</li><li>Handler 完成对请求的处理后，会返回一个 ModelAndView 对象给 DispatcherServlet， ModelAndView 就是 数据模型和对应视图的信息，View 是逻辑上的视图</li><li>DispatcherServlet 将 ModelAndView 传给 ViewResolver 进行视图解析，ViewResolver 根据逻辑的 View 查找具体的 View，返回实际的 View</li><li>DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）</li><li>DispatcherServlet 将 View 响应给用户</li></ul><h3 id="3、统一异常处理"><a href="#3、统一异常处理" class="headerlink" title="3、统一异常处理"></a>3、统一异常处理</h3><p>使用  @ControllerAdvice 和 @ExceptionHandler 两个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(BaseException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="hljs-title function_">handleResourceNotFoundException</span><span class="hljs-params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@ControllerAdvice 表明这是一个统一异常处理类     @ExceptionHandler 指明处理的哪种异常</p><p>这种异常处理方式是给所有的或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被 @ExceptionHandler 注解修饰的方法进行处理。   匹配相关的处理方法时，选择匹配程度最高的方法</p><h2 id="五、Spring的三级缓存和循环依赖"><a href="#五、Spring的三级缓存和循环依赖" class="headerlink" title="五、Spring的三级缓存和循环依赖"></a>五、Spring的三级缓存和循环依赖</h2><p>好文：<a href="https://zhuanlan.zhihu.com/p/610322151">彻底搞懂Spring之三级缓存解决循环依赖问题 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/ljcgit/article/details/115727194">Spring为什么需要使用三级缓存？_singletonfactories_蜡笔没了小新git的博客-CSDN博客</a></p><h3 id="1、三级缓存"><a href="#1、三级缓存" class="headerlink" title="1、三级缓存"></a>1、三级缓存</h3><ul><li>一级缓存（ConcurrentHashMap）：singletonObjects，存放完整的 bean 实例，也就是已经实例化和初始化好的实例</li><li>二级缓存（HashMap）：earlySingletonObjects，如果没有AOP代理，存放的是属性未填充的半成品 bean 实例；如果有AOP代理，则存放的是代理的 bean 实例 beanProxy，原来的 bean 还是半成品</li><li>三级缓存（HashMap）：singletonFactories，存放的是 bean 封装后的 ObjectFactory，有一个 getEarlyBeanReference() 方法，如果 bean 被代理，返回的是代理对象，否则返回原 bean 实例</li></ul><p>缓存其实就是一个 map</p><p><img src="/lulalula/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/v2-d78848d4c07fd077da0c896087e90885_1440w.webp" alt="img"></p><h3 id="2、三级缓存的设计是为了解决循环依赖"><a href="#2、三级缓存的设计是为了解决循环依赖" class="headerlink" title="2、三级缓存的设计是为了解决循环依赖"></a>2、三级缓存的设计是为了解决循环依赖</h3><p>循环依赖的解决：</p><ol><li>对象A要创建到Spring<a href="https://link.zhihu.com/?target=https://cloud.tencent.com/product/tke?from=10680">容器</a>中，从一级缓存singletonObject获取A，不存在，开始实例化A，最终在三级缓存singletonObjectFactory添加(A，A的函数式接口创建方法)，这时候A有了自己的内存地址</li><li>设置属性B，B也从一级缓存singletonObject获取B，不存在，开始实例化B，最终在三级缓存singletonObjectFactory添加(B，B的函数式接口创建方法)，这时候B有了自己的内存地址</li><li>B中开始给属性A赋值，此时会找到三级缓存中的A，并将A放入二级缓存中。删除三级缓存</li><li>B初始化完成，从三级缓存singletonObjectFactory直接put到一级缓存singletonObject，并删除二级和三级缓存的自己</li><li>A成功得到B，A完成初始化动作，从二级缓存中移入一级缓存，并删除二级和三级缓存的自己</li><li>最终A和B都进入一级缓存中待用户使用</li></ol><img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/v2-91760e98daa2e93b0d63e123657e5bb7_1440w.webp" alt="img" style="zoom: 67%;" /><h3 id="3、为什么不能去掉三级缓存"><a href="#3、为什么不能去掉三级缓存" class="headerlink" title="3、为什么不能去掉三级缓存"></a>3、为什么不能去掉三级缓存</h3><p>因为 AOP 的缘故，懒得看了，后续有需求再看<a href="https://zhuanlan.zhihu.com/p/610322151">彻底搞懂Spring之三级缓存解决循环依赖问题 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/ljcgit/article/details/115727194">Spring为什么需要使用三级缓存？_singletonfactories_蜡笔没了小新git的博客-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/lulalula/2023/11/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/lulalula/2023/11/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><p><img src="/lulalula/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/image-20231109115759797.png" alt="image-20231109115759797"></p><img src="/lulalula/2023/11/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/image-20231109115759797.png" class="" title="This is an example image">]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/lulalula/2023/11/08/hello-world/"/>
    <url>/lulalula/2023/11/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
