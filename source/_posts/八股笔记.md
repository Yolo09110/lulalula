[TOC]



# [字符集](https://javaguide.cn/database/character-set.html#%E5%8F%82%E8%80%83)



# JavaSE



## 一、Java基础-上



### 1、基础概念与常识



#### Java语言的特点

**简单易学、面向对象、平台无关性、支持多线程、编译与解释并存**、可靠性、安全性、支持网络编程

注：平台无关性目前已经不是Java最大的优势了，因为docker等技术也可以容易的实现跨平台



#### JVM

Java虚拟机是运行Java字节码的虚拟机。因为有了字节码和虚拟机，才有了**一次编译随处运行**。



#### JDK和JRE

JDK（Java Development Kit）是功能齐全的Java SDK（SoftWare Development Kit），提供给开发者使用，能够创建和编译 Java 程序。 包含了JRE，以及 编译 Java 源码的编译器 javac，以及文档注释工具 javadoc，调试器 jdb，反编译工具 javap 等等。

JRE（Java Runtime Environment）是Java运行时环境，它是运行编译后Java程序所需的所有内容的集合，主要包括 JVM，Java基础类库（Class Library）。仅包含 Java 应用程序的运行时环境和必要的类库。

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jdk-include-jre.png" alt="JDK 包含 JRE" style="zoom: 67%;" />



#### 字节码

​		可以被JVM理解的代码就叫字节码（即.class文件）。它不面向任何特定处理器，只面向虚拟机。Java通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言的可移植性。

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java-code-to-machine-code.png" alt="Java程序转变为机器代码的过程" style="zoom:67%;" />

​		.java文件首先经过编译器进行编译，得到.class字节码文件，然后.class字节码文件被JVM类加载器加载到内存中，然后通过解释器逐行解释运行。这种逐行解释运行速度较慢。而且有些方法和代码块是经常被调用的（热点代码），所以后面引进了 JIT编译器（just-in-time compilation），而JIT属于运行时编译，当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 **Java 是编译与解释共存的语言** 。	

​                     	<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程" style="zoom: 67%;" /> 



#### JDK、JRE、JVM关系

![JDK、JRE、JVM、JIT 这四者的关系](%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jdk-jre-jvm-jit.png)



#### 编译型语言和解释型语言

​		编译型语言通过编译器一次性将源代码编译为可被该平台执行的机器代码，执行效率高，但是与开发平台密切相关。开发效率低。如C、C++、Go、Rust

​		解释型语言通过解释器将代码一行一行进行解释运行，执行效率低，但是可移植，平台无关。开发效率高。如python、JavaScript

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/compiled-and-interpreted-languages.png" alt="编译型语言和解释型语言" style="zoom: 67%;" />

而Java是编译与解释并存。因为Java程序首先要经过javac进行编译得到 .class字节码文件，然后由解释器 进行逐行解释运行。



### 2、基本语法



#### 自增自减运算符

a = ++b  ：先 b = b + 1 然后再 a = b

a = b++  ：先 a = b，然后再 b = b + 1

自增自减运算并不是原子运算



#### 移位运算

- 左移 <<    向左移位，高位丢弃，不溢出情况下相当于 乘 2 
- 带符号右移 >>  向右移位，高位用符号位补齐，低位丢弃。相当于原数除以 2
- 无符号右移 >>>  向右移位，忽略符号位，高位补0，低位丢弃
- **由于float和double比较特殊，因此不能移位操作**，能移位操作的只有int 和 long。
- 对于 short、byte、char类型的移位，**移位前都会转为int类型**
- 因为 int 只有 32位，long只有64位， 因此，在移位时，如果移位位数大于32 或 64 ，就会先进行取余操作。



### 3、基本数据类型



#### 八种基本数据类型

boolean（理论上只占1位，实际会考虑计算机的高效存储因素）、byte（1个子节）、short、char（两个字节）、int、float（4个字节）、long、double（8个字节）

**Java的基本数据类型所占存储空间大小不会像其他语言随着机器硬件的改变而改变**，因此，这也是Java更具移植性的原因之一。



#### byte、char、short 进行 + 运算和 += 运算

在进行+运算时，会被强转为int

```java
byte c = 128;		//会报错，128已经超过了byte表示范围
byte a = 10;
byte b = 11;
a = a + b;    //报错，因为 a + b 运算a和b会被强转为int，所以相加结果为int，但是左边的变量a仍为byte

a += b;		  //正确， += 会将左右两边的都强转
```



#### 包装类型和基本数据类型的区别

每种基本数据类型都对应着包装类型

- 从用途上：除了定义一些常量和局部变量外，很少使用到基本数据类型。像方法参数、对象属性这些基本都是用包装类型。并且，**基本数据类型不能用于泛型**
- 从存储方式上：基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被static修饰）存放下Java虚拟机的堆中。包装类属于对象实例，而几乎所有的对象实例都放在堆中。
- 占用空间：基本数据类型所占的空间大小远远小于包装类
- 默认值：包装类型不赋值就是null，而基本数据类型有初始值不为null。比如 int 类型默认初始值为0；

**注意**：成员变量才有初始值，局部变量不会赋初始值，如果不赋值使用会报错。

- 比较方式：对于基本数据类型来说， == 比较的就是值想不想同。而对于包装类型来说，比较的是对象的内存空间地址是否相同。因此，如果两个包装类要比较数值是否相同，**需要使用equals**。



******注意：基本数据类型存放在栈中这个说法是错误的。作为成员变量时，存放在堆中。



#### 包装类型的缓存机制

​		除了`Float`、`Double`两个包装类外，其他的包装类都有缓存。

​		什么是缓存呢？就是说，这些包装类在加载过程中，已经创建了一些对应值的对象，缓存了起来。当下次使用时，如果在范围内则直接调的是缓存中的内容，而不是新创建。如果超过了范围，就需要新创建。

​		`Byte`、`Short`、`Long`、`Integer`这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据。`Character`默认创建了数值在 **[0,127]** 范围的缓存数据。`Boolean` 直接返回 `True` or `False`。

​		看一下相关源码：

`Boolean`:

```java
public static final Boolean TRUE = new Boolean(true);

public static final Boolean FALSE = new Boolean(false);

public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}
```

`Integer`:

```java
public static Integer valueOf(int i) {
    //IntegerCache是Integer的一个静态内部类
	if (i >= IntegerCache.low && i <= IntegerCache.high)
    	return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

//IntegerCache的其中的静态代码块的重点代码
if (archivedCache == null || size > archivedCache.length) {
     Integer[] c = new Integer[size];
     int j = low;
     for(int i = 0; i < c.length; i++) {
     	c[i] = new Integer(j++);
     }
     archivedCache = c;
}
```



举例说明缓存的存在以及超出范围就新建

```java
Integer i1 = 222;
Integer i2 = 222;
System.out.println(i1 == i2);

//输出false，因为超出了缓存的范围，需要新建

Integer i1 = 22;
Integer i2 = 22;
System.out.println(i1 == i2);

//输出true，因为22在范围内，返回的都是缓存中的对象

Float i1 = 22f;
Integer i2 = 22f;
System.out.println(i1 == i2);

//输出false，因为Float包装类没有缓存
```



#### 自动装箱和自动拆箱

装箱：将基本数据类型用对应的包装类包装起来

拆箱：将包装类型转换为基本数据类型

​	举例：

```java
Integer i = 10; 	//自动装箱
int n = i; 			//自动拆箱
```

自动装箱其实是调用了 包装类的 `valueOf()`方法，而自动拆箱则是调用了包装类的`xxxValue()`方法。

​	因此上边的例子实际是：

```java
Integer i = Integer.valueOf(10);
int n = Integet.intValue(i);
```

注意：**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**



#### 浮点数精度丢失问题

计算机是二进制的，计算机在表示一个数时，需要将它转换为二进制，转换过程中，有可能转换的二进制是无限长的，而存储宽度是有限的，因此存储时只能被截断，这样就导致损失一部分精度。

例如：

```java
float f1 = 0.9f - 0.8f;
float f2 = 0.8f - 0.7f;
System.out.println(f1);			//0.099999964
System.out.println(f2);			//0.100000024
System.out.println(f1 == f2);			//false
```



要解决这个问题，就可以使用`BigDecimal`这个类。不会造成精度的损失。

##### BigDecimal 的创建

推荐使用它的`BigDecimal(String val)`构造方法或者 `BigDecimal.valueOf(double val)` 静态方法来创建对象。

```java
BigDecimal bigDecimal = new BigDecimal("0.22222222222222");
BigDecimal dd = BigDecimal.valueOf(0.2222222);
```

##### BigDecimal的加减乘除

```java
        BigDecimal d1 = new BigDecimal("0.22222222222222");
        BigDecimal d2 = BigDecimal.valueOf(0.2222222);

        System.out.println(d1.add(d2));		//0.44444442222222
        System.out.println(d1.subtract(d2));		//2.222222E-8
        System.out.println(d1.multiply(d2));		//0.049382711111110617284
        System.out.println(d1.divide(d2));		//1.0000001

//注意：在除运算时，最好使用带三个参数的divide
//scale代表保留的位数， roundingMode表示保留规则，包括向上取整、向下取整等
public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) {
    return divide(divisor, scale, roundingMode.oldMode);
}
```

##### BigDecimal的大小比较

最好使用 `compareTo()` ，不要使用 `equals()` 。  这是因为 `equals()` 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 `compareTo()` 方法比较的时候会忽略精度。

```java
BigDecimal a = new BigDecimal("1");
BigDecimal b = new BigDecimal("1.0");
System.out.println(a.equals(b));	//false
System.out.println(a.compareTo(b));		//0    0代表相等，1代表大于，-1代表小于
```



#### 超过`long`整型的数

64位`long`是最大的整型，但是也可能超过这个范围

```java
long l = Long.MAX_VALUE;
System.out.println(l + 1); // -9223372036854775808
System.out.println(l + 1 == Long.MIN_VALUE); // true
```

超过`long`的就可以用`BigInteger`表示，`BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据。

相对于常规整数类型的运算来说，`BigInteger` 运算的效率会相对较低。



### 4、变量

#### 局部变量和成员变量的区别

**语法形式上**：成员变量是属于类的，而局部变量是方法中或者代码块中定义的变量或是方法的参数。成员变量可以使用`public`、`private`、`static`等修饰符修饰，而局部变量不可以。二者都可以使用final修饰。

**存储方式**：没有被`static`修饰的成员变量存放在堆中，因为对象就存放在堆中。没有被`static`修饰的局部变量存放在栈中。被`static`的修饰的成员变量不属于对象，而属于类，因此类加载时静态成员变量就一块加载了，存放在方法区，被`static`修饰的局部变量也一样。

**生存时间**：成员变量随着类的创建而存在，随着类的销毁而销毁。局部变量随着方法的调用而自动生成，随着方法的调用结束而结束。

**默认值**：成员变量有默认值（除了被`final`修饰的成员变量需要自行赋值），局部变量没有默认值。



#### 字符型常量和字符串常量

```java
public class StringExample {
    // 字符型常量
    public static final char LETTER_A = 'A';

    // 字符串常量
    public static final String GREETING_MESSAGE = "Hello, world!";
    public static void main(String[] args) {
        System.out.println("字符型常量占用的字节数为："+Character.BYTES);
        System.out.println("字符串常量占用的字节数为："+GREETING_MESSAGE.getBytes().length);
    }
}

输出：2   	13
```

字符型常量占用两个字节。而字符串常量占若干个，String源码中存放字符串的为`byte[] value`，因此对于除汉字以外的字符串，每一位占一个子节。**而一个汉字占3个字节**

字符常量相当于一个整型值（ASCII），可以参加表达式运算。而字符串常量代表一个地址值（该字符串在内存中的地址）。



### 5、方法

#### 重载和重写

**重载**：发生在同一个类中（子类继承父类的方法也算），**方法名必须相同，参数列表必须不同**。返回值类型和访问修饰符可以不同。

**重写**：子类与父类之间。方法名必须相同，参数列表必须相同。重写方法返回值类型、抛出异常大小必须小于等于父类中被重写方法的。访问修饰符必须大于等于被重写方法的。     总结就是：**两同两小一大**

​		这里的返回值类型小是指，如果返回值类型是引用类型，则子类重写方法的返回值一定要是父类原方法的子类或者相同。如果为基本数据类型或者void，则重写方法的返回值类型不能变。

​		如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `private`、`static` 修饰的方法能够被再次声明。  ************重点：判断是不是重写要看父类中的方法是否对子类可见，如果是private，说明子类不可见，则子类就可以重新声明一个。  

```java
class Person {
	public void eat() {
    	System.out.println("bbb");
    }
}

class Student extends Person {
	public void eat() {
    	System.out.println("aaa");
    }
}

@Test
public void test2() {
	Person s = new Student();
	s.eat();
}

//像这种父类引用指向子类对象时。如果是重写，则编译看左运行看右，如果不是重写，是重新声明，则编译执行都看左。
```



#### 可变长参数

```java
public static void method2(String arg1, String... args) {
   //......
}
注意：可变长参数只能放在参数列表最后。
```

可变长参数实际编译后实际是转化为了一个数组



## 二、基础知识-中

### 1、面向对象基础



#### 面向过程和面向对象的区别

- 面向过程是按照解决问题的流程，拆分成一个个方法，通过方法的执行解决问题。
- 面向对象是先在问题中抽象出相关对象，然后通过执行对象的方法来解决问题。

**面向对象的优点**：易复用、易扩展、易维护

​	面向过程性能优于面向对象这句话并不准确，性能差异不是来自于语言采用的编程范式，而是来自于执行机制。比如说 `C` 和 `Java` , `Java` 在对象创建上需要花费较多时间，但是 `C` 在分配内存上也需要花费时间，而且由于 `Java` 目前在底层编译上优化很大，性能差距并不大。  真正引起差距的是， `Java` 首先是要编译生成字节码文件，然后字节码文件是逐行解释运行。而 `C` 是直接编译成机器语言，一次性执行。



#### 对象引用和对象实体

- 一个对象引用可以指向一个或者零个对象实体。
- 多个对象引用可以指向一个对象实体。



#### 面向对象的三大特征

**封装：** 封装是指将对象的状态信息（即属性）隐藏起来，不允许外部直接访问操作。但是可以提供一些接口（即方法）来操作属性。

**继承**：不同的对象，可能会有一些共同点，比方上男生、女生都首先是人，因此就可以定义一个父类来体现这些共同点。而每一个子类又有各自的特点，比如说男生力气大，女生脾气大等等，就可以在子类中再添加各自的一些属性和方法。

继承需要注意的是：

- 子类继承了父类所有的属性和方法（构造器不可以继承），子类不能选择性的继承，包括`private`也是继承了的，只不过子类不能访问，只是拥有而已。
- 子类拥有自己特有的属性和方法，并且子类可以用自己的方式实现父类中的方法（也就是重写或者重新声明）。

**多态：**顾名思义，表示一个对象有多个状态，具体表现为父类的引用指向子类的实例。

需要注意的：

- 引用类型调用的方法究竟是子类的还是父类的，必须在运行期间才能确定。（因此才有运行看作还是看右）
- 引用类型调用的方法父类中一定要有，不能只存在子类中。（因为编译一定是看左的）
- 关于究竟执行的是谁的方法，分为两种，一种是该方法是子类继承自父类的并进行了重写，则调用的是子类的方法，即**运行看右**。另一种是该方法子类没有进行重写或者是该方法为 `static`子类没法进行重写（子类只是重新声明了），则调用的是父类的方法，即**运行看左**。



#### 抽象类和接口的区别和共同点

接口：接口中所有的方法都是默认 `public abstract`，不能有方法体。所有的成员变量都是`public static final`，必须初始化。在`JDK8`之后，有了默认方法`default`和静态方法`static`，可以有方法体。在`JDK9`后，方法可以为`private`，有方法体。

抽象类：抽象类和普通类的区别就是不能实例化，抽象方法只能在抽象类内，其他没有任何区别。

**相同点**：

不能实例化、都可以包含抽象方法、都可以有默认方法（default）

**不同点**：

- 接口主要是对类的行为进行约束，也就是说，接口是一种规范。实现了哪个接口，就必须符合它的规范。抽象类主要用于代码复用，强调的是所属关系。（抽象类很少用）
- 接口是多继承，抽象类单继承
- 接口中的成员变量默认是`public static final`的，不能被修改且必须有初始值。抽象类的成员变量可以是任何类型，默认是`default`，可以不赋初始值。



#### 引用拷贝、浅拷贝、深拷贝

- 引用拷贝：两个不同的引用指向同一个对象
- 浅拷贝：在堆中复制新建了一个对象，但是如果原对象的属性中有引用类型（内部对象），则复制新建的是该引用的地址。也就是说，复制得到的对象和原对象使用的是同一个内部对象。
- 深拷贝：内部对象也进行复制新建，复制得到的对象和原对象使用的内部对象不是同一个。

```java
//浅拷贝
public class Address implements Cloneable{
    private String name;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Address clone() {
        try {
            return (Address) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}

public class Person implements Cloneable {
    private Address address;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Person clone() {
        try {
            Person person = (Person) super.clone();
            return person;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}


//深拷贝
@Override
public Person clone() {
    try {
        Person person = (Person) super.clone();
        person.setAddress(person.getAddress().clone());
        return person;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```

![浅拷贝、深拷贝、引用拷贝示意图](%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/shallow&deep-copy.png)



### 2、Object类



#### Object类的方法（11个）

`getClass()`:	返回当前运行时对象的`Class`对象

`clone()`:	创建并返回当前对象的一份拷贝（浅拷贝）

`equals()`:	只能用于引用类型，没有重写就是判断两个引用类型是否相等（比较的是地址）

`wait()`: 	有三个  暂停线程的执行。**注意：**这个方法会释放锁，`sleep()`不会释放锁

`notify()`:	唤醒在此对象监视器（锁）上等待的一个线程

`notifyAll()`:	唤醒所有在此对象监视器上等待的线程

`hashCode()`:	返回对象的哈希码，主要用于散列表中（HashSet、HashMap、HashTable...）

`toString()`:	返回类的名字实例的哈希码的 16 进制的字符串，建议所有的子类都重写

`finalize()`: 	实例被垃圾回收器回收时触发的操作。JDK9以后已经标为 `@Deprecated`

```java
/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class<?> getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * naitive 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable { }
```



#### equals 和 == 的区别

- == 比较基本数据类型时，比较的是值是否相同。比较引用类型数据时，比较的是地址是否相同
- equals只能用于引用类型数据的比较，没有重写时比较的是地址，等同于==。重写则按照自己的意愿。比如 `String`的equals方法进行了重写，比较的是字符串的值是否相同。

当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。



#### hashCode()的作用

`hashCode()`的作用是获取对象的哈希码（int整数），也叫散列码。主要用于散列表的使用（HashSet、HashMap等）。**在其他情况下，哈希码没有任何用。**

​	散列表存储的是键值对(key-value)，它的特点是：**能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）**。



为什么要有哈希码呢？ 是因为，在散列表中添加对象时，会先计算对象的哈希码，根据此找到放置的位置，并且将此哈希码和其他已经加入对象的哈希码进行比较。如果没有相同的，则说明该对象散列表中还不存在，可以直接加入。如果有相同的，则再用`equals()`比较两个对象，如果相同，则说明重复了，就不再加入。如果不相等，说明发生了哈希碰撞，也就是不同的对象生成了相同的哈希码，这样的话就重新找其他位置进行插入。



既然`hashCode()`、`equals()`的作用都是比较两个对象是否相等，并且`equals()`比哈希码还更准确，为什么还要存在`hashCode()`呢？   

**原因就是：**使用`hashCode()`的话效率会更高。如果只使用equals，那么需要跟每一个元素进行比较，而使用哈希只需要比较一次（因为只需要一次就能找到是否有相等的，这是散列表的特点），虽然哈希并不准确，但是就算哈希出了问题，那么再调用一次equals就行，这样仍然比全部使用equals效率高得多。



#### equals和hashCode为什么要同时重写？

- equals判断相等的哈希码一定相等。哈希码相等的equals比较不一定相等

原因就是，如果重写了equals而不重写hashCode，那么在比较两个对象时，尽管他们equals比较是相等的，但是由于哈希的原因，在添加到散列表时，会认为是两个不同的对象。

​	比方说，现在散列表中要存Person对象，我们希望存的每一项年龄都是不同的，因此我们重写了equals方法用来比较Person对象的年龄，但是由于仍然是不同的对象，他们的哈希码还是不同的，在添加到散列表中时，尽管年龄相等，equals比较相等，但是哈希码不同。这样就产生了问题。



### 3、String

***JDK9以后，存储字符串使用byte数组代替了之前的char数组***

#### String、StringBuilder、StringBuffer的区别

- `String`是不可变的，表面原因是因为它使用`final`关键字修饰的`byte`数组来存储字符串，是一个常量所以不可变。但是有个问题，`final`对引用类型数据不可变是说指向的内存地址不可变，不是该内存地址里边的数据不可变，因此`final`只是表面原因。   **深层原因**在于：存储字符串的`byte`数组不仅是`final`的，而且还是`private`的，`String`这个类也没有提供可以修改数组内容的接口，所以才不可变。同时，`String`类也是`final`的，不可以被继承，也消除掉了子类继承后破坏`String`不可变这一因素。 这才是`String`不可变的真正原因。
- `StringBuilder`和`StringBuffer`同继承于抽象类`AbstractStringBuilder`，而`AbstractStringBuilder`类中用来存储字符串的`byte`数组没有用`private`、`final`修饰，因此是可变的。
- `String`是不可变的，可以理解为常量，自然就是线程安全的。`StringBuffer`中的绝大多数方法使用了`synchronized`关键字修饰，也就是加了同步锁，其余的部分方法没有加同步锁，但是调用这些方法的方法加了同步锁（）。因此`StringBuffer`是线程安全的。而`StringBuilder`的方法没有加同步锁，不是线程安全的。![image-20230515150901846](%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230515150901846.png)
- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`



#### 字符串拼接用"+"还是StringBuilder？

*JDK9以前：*

​		使用 **+** 号拼接字符串底层，是新建一个`StringBuilder`对象，调用该对象的`append()`方法进行，拼接完成后调用`toString()`方法得到一个`String`对象。并且，如果是在循环中拼接字符串，每循环一次就会新建一个`StringBuilder`对象，之前新建的不会复用。

```java
String[] arr = {"he", "llo", "world"};
String s = "";
for (int i = 0; i < arr.length; i++) {
    s += arr[i];
}
System.out.println(s);
```

​		对应的字节码：

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20220422161320823.png" alt="img" style="zoom: 50%;" />



*JDK9及以后：*

​		字符串相加 “+” 改为了用动态方法 `makeConcatWithConstants()` 来实现，而不是大量的 `StringBuilder` 了。这个改进是 JDK9 的 JEP 280 提出的，这也意味着 JDK 9 之后，可以放心使用“+” 进行字符串拼接了。

​		

#### 字符串常量池

JVM为了提升性能和减少内存消耗，专门针对字符串开辟了一块区域，叫做字符串常量池。JDK7以前，字符串常量池放在持久代PermGen中，<u>由于持久代垃圾回收GC效率太低</u>，只有在整堆收集（Full GC）的时候才会被执行GC，导致大量等待被回收的字符串对象得不到回收，因此，在JDK及以后，将字符串常量池移动到了堆中。



字符串新建时的过程：

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/u=2116635709,3666027563&fm=253&fmt=auto&app=138&f=JPEG.jpeg" alt="img" style="zoom:67%;" />

**注意：**字符串常量池中的是对象以及对象的引用（也有说只存的是引用）。

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/07a5bac4ce1743bcb6f856c903eb20b4.png" alt="img" style="zoom: 50%;" />





#### String的`intern()`方法

`String`的`intern()`方法，是一个本地native方法，作用是将指定字符串对象的引用保存在常量池中，可以分为两种情况：

- 一种是常量池中已经有了该字符串的引用，则直接返回
- 一种是没有，则在字符串常量池中创建一个新的引用指向该字符串对象（不同的JDK实现细节不同，有的是直接拷贝一份到字符串常量池，有的是移动到字符串常量池中，堆中的删除）

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/8e7ba3fe541d4970a5221097edaed7a0.png" alt="img" style="zoom:50%;" />



#### String类型的变量和常量做“+”运算时发生了什么？

[Java中，关于String类型的变量和常量做“+”运算时发生了什么？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/35014775)



## 三、基础知识-下



### 1、异常

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图" style="zoom: 50%;" />

#### Exception和Error

二者有共同的父类`Throwable`，`Throwable`有也仅有两个重要的子类`Exception`和`Error`。

- Exception：程序本身可以处理的异常，可以使用catch捕获。Exception又分为受检异常和不受检异常，

- Error：程序无法处理的错误。例如虚拟机错误（Virtual Machine Error）、内存不够错误（OutOfMemoryError）等

#### 受检异常和不受检异常

​		IOException及其子类、SQLException、ClassNotFoundException是受检异常。RuntimeException及其子类全为不受检异常。 受检异常是指必须使用catch捕获或者使用throws抛给上层调用者。如果不这样则报错。

![img](%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/checked-exception.png)



#### Throwable中的主要方法

`String getMessage()`: 返回异常发生时的简要描述

`String toString()`: 返回异常发生时的详细信息

`String getLocalizedMessage()`: 返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同



#### try-catch-finally需要注意的

- finally中的语句是一定要执行的，除非虚拟机停止运行、程序所在线程死亡、CPU关闭等情况。（也就是还没执行到finally就把电拔了）
- try后如果没有catch，则必须有finally
- 如果try中有return语句，则执行return语句时，将return的内容存到一个临时变量中，然后去执行finally中的语句，执行完之后再return
- 如果try和finally中都有return语句，则以finally中的为主



#### try-with-resources

**<u>*使用范围*</u>**：任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象（JDK7之后才能使用）

对于FileInputStream类似的输入输出流或者其他文件操作类使用完后需要关闭，即调用close方法。之前我们都是在finally语句中close，这并不推荐。

推荐使用try-with-resources。代码更简单，并且不用手动close

```java
//读取文本文件的内容  之前的写法
Scanner scanner = null;
try {
    scanner = new Scanner(new File("D://read.txt"));
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (scanner != null) {
        scanner.close();
    }
}



//使用try-with-resources
try (Scanner scanner = new Scanner(new File("test.txt"))) {
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException fnfe) {
    fnfe.printStackTrace();
}



//多个资源需要关闭时，用封号隔开
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
    int b;
    while ((b = bin.read()) != -1) {
        bout.write(b);
    }
}
catch (IOException e) {
    e.printStackTrace();
}
```



#### 异常需要注意的事项

- 异常不要定义为静态变量，这样会导致栈信息混乱。建议每次都是手动new

- 抛出的异常信息一定要有意义。

- 建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出`NumberFormatException`而不是其父类`IllegalArgumentException`。

- 使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。

  

### 2、反射

***<u>类加载过程：</u>***

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/20170513133210763.png" alt="img" style="zoom:50%;" />

**（使用反射的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码），Class对象代表着类相关的信息）**

反射机制就是运行时可以分析获取类中的属性方法构造器等的能力。通过反射，可以获得这个类的所有信息和细节，包括私有等。



#### 使用反射的场景

Spring、SpringMVC等框架，注解等



#### 反射的优缺点

- 优点：可以让代码更灵活，提高了程序的灵活性和拓展性，降低耦合。
- 缺点：增加了安全风险，比如无视了泛型参数的安全检查（安全检查在编译阶段）。某种意义上说破坏了封装性，同时，性能也要差点，因为  因为是运行时操作，编译器不能做优化；要操作的方法和属性有一个查找过程； invoke方法时，参数需要进行处理，比如说装箱、拆箱等等。



#### 获取Class对象的四种方法

<u>***注意：对于一个类只有一个Class对象，不管获取多少次都是同一个***</u>

```java
//1、知道具体的类
Class clazz1 = TargetClass.class;

//2、知道对象
Class clazz2 = targetClass.getClass();

//3、知道类的全路径
Class clazz3 = Class.forName("com.aqoo.TargetClass");

//4、通过类加载器(通过类加载器将类加载到内存中)
ClassLoader classLoader = ClassLoader.getSystemClassLoader();
classLoader.loadClass("com.aqoo.TargetClass");

//只有一个Class对象
Solution s = new Solution();

Class clazz1 = Solution.class;
Class clazz2 = s.getClass();
Class clazz3 = Class.forName("com.aqoo.exer.Solution");
Class clazz4 = ClassLoader.getSystemClassLoader().loadClass("com.aqoo.exer.Solution");

System.out.println(clazz1 == clazz2 && clazz2 == clazz3 && clazz3 == clazz4);   //true
```



#### 反射的一些基本操作

```java
//构造方法相关
//clazz.newInstance()已经Deprecated
//尽量使用  getConstructor().newInstance();
clazz.newInstance();        	//相当于调用无参构造
clazz.getDeclaredConstructor(String.class, int.class);        //获取构造方法
con.newInstance("张三",18);      //实例化对象
con.getName()     				//获取构造方法的名称
con.getParameterCount()       	//获取构造方法的参数数量
con.getParameterTypes()       	//获取构造方法的参数类型


//方法相关
    
Method method = c1.getDeclaredMethod("charAt", int.class);             //获取方法对象
char c = (char) method.invoke("object", 2);      //调用方法，相当于"askdhjsad".charAt(2);

//属性相关
getDeclaredField(String name);                 //获取域属性对象
getName()                                      //获取属性名称
getType()                                      //获取属性类型的字节码文件
setAccessible(true)                            //设置暴力破解，获取对私有属性的使用
field.set(per, "huawei");                      //相当于设置 per.name = "huawei"
String str = (String) field.get(per);          //相当于 str = per.name

```



### 3、注解

#### 什么是注解

<u>***官方文档解释：***</u> 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。

简单点说，注解就是一张标签，贴到哪说明此处有这个特点或者特征。比如说`@Deprecated`贴到哪，说明被贴的这个方法过时了。



#### 注解的定义

```java
public @interface TestAnnotation {
    //注解只能由属性，也就是成员变量，没有方法。
    //注解的成员变量以“无形参的方法”形式来声明，方法名定义了成员变量的名字，返回值定义了成员变量的类型。
    //如果成员变量没有默认值，则在使用该注解时必须给其赋值。
    String name();
    int id();
    //默认值用default定义
    String sex() default "man";
}
```

自定义的注解要能工作，必须还依靠元注解，什么是元注解呢？**元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。** 也就是说，你要贴的这个标签，本身自己也要被贴“标签”，也就是一些限制定义之类的。 



#### 元注解

元注解有5个。分别是 `@Retention` `@Documented` `@Target` `@Inherited` `@Repeatable`



`@Retention` 作用是标识目标注解的存活期。取值有：

- RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。
- RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。
- RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。



`@Documented` 顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。



`@Target` 指定了注解运用的地方。

- ElementType.ANNOTATION_TYPE 可以给一个注解进行注解
- ElementType.CONSTRUCTOR 可以给构造方法进行注解
- ElementType.FIELD 可以给属性进行注解
- ElementType.LOCAL_VARIABLE 可以给局部变量进行注解
- ElementType.METHOD 可以给方法进行注解
- ElementType.PACKAGE 可以给一个包进行注解
- ElementType.PARAMETER 可以给一个方法内的参数进行注解
- ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举



`@Inherited` 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。



`@Repeatable `暂时不搞



#### 注解的解析方式

常见的解析方法有两种：

- **编译期直接扫描**：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。



#### 注解与反射



注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解

```java
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {}
```

然后通过 getAnnotation() 方法来获取 Annotation 对象。

```java
public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {}
```

或者是 getAnnotations() 方法。

```java
public Annotation[] getAnnotations() {}
```

前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。

如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。



### 4、IO流





## 四、集合

### 1、Comparable 和 Comparator 的区别

`Comparable` 接口和 `Comparator` 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：

- Comparable 接口是 java.lang 包下的，有方法 compareTo(Object o)
- Comparator 接口是 java.util 包下的，有方法 compare(Object o1, Object o2)



举例：

```java
//Comparable
public  class Person implements Comparable<Person> {
    private int age;
    /**
     * T重写compareTo方法实现按年龄来排序
     */
    @Override
    public int compareTo(Person o) {
        if (this.age > o.getAge()) {
            return 1;
        }
        if (this.age < o.getAge()) {
            return -1;
        }
        return 0;
    }
}


//Comparator
Collections.sort(arrayList, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
});
```



### 2、集合概述

Java集合，也叫容器，主要是由两大接口派生而来。一个是存储单一元素的`Collection`接口，另一个是存储键值对的`Map`接口。对于 Collection 接口，有三个子接口，分别是 List、Set 和 Queue

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java-collection-hierarchy.png" alt="Java 集合框架概览" style="zoom: 50%;" />

<u>***注：***</u>只列举了部分继承实现关系



- List用于存储有序可重复元素
- Set用于存储无序不可重复元素
- Map用于存储键值对<key, value> ，key存储是Set类型，value是Collection。因此，map的key是无序不重复的，而value可以为null、重复。
- Queue 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。比如说先进先出，后进先出等



### 3、List

List接口下主要几个实现类是 ArrayList、LinkedList（同时也实现了Deque接口，经常当作栈来使用）、Vector（Vector有个子类Stack）

#### （1）ArrayList



继承自 AbstractList，实现了 List、RandomAccess、Cloneable、Serializable接口。线程不安全

- Random接口是一个标记接口，没有任何方法和成员变量。作用仅仅是表明实现了该接口的类是可随机访问的。也就是可以根据下标访问的
- 实现了Cloneable 接口，覆盖了 clone() 方法，是可克隆的
- 实现了Serializable接口，表明可序列化



底层存储是 Object[] ，使用transient修饰，不进行持久化。默认初始容量大小为10，当使用无参构造new一个ArrayList对象时，底层实际创建的是一个空数组，直到添加第一个元素时，才创建一个长度为 10 的数组。当使用有参构造new时，会根据指定的长度创建

```java
//初始容量
private static final int DEFAULT_CAPACITY = 10;

//空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

//无参构造
public ArrayList() {
	this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

//有参构造
public ArrayList(int initialCapacity) {
	if (initialCapacity > 0) {
		this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
    } else {
            throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
    }
}
```



##### 扩容机制：

ArrayList 扩容采用的是移位操作，每次容量增大1.5倍左右

```java
private Object[] grow(int minCapacity) {
        int oldCapacity = elementData.length;
        if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            int newCapacity = ArraysSupport.newLength(oldCapacity,
                    minCapacity - oldCapacity, /* minimum growth */
                    oldCapacity >> 1           /* preferred growth */);
            return elementData = Arrays.copyOf(elementData, newCapacity);
        } else {
            return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
        }
}


public static int newLength(int oldLength, int minGrowth, int prefGrowth) {
        // preconditions not checked because of inlining
        // assert oldLength >= 0
        // assert minGrowth > 0

        int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow
        if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {
            return prefLength;
        } else {
            // put code cold in a separate method
            return hugeLength(oldLength, minGrowth);
        }
    }


```



其实，ArrayList的扩容底层还是数组复制，源码中大量使用了 

```java
 /**
    *   复制数组 System类的方法
    * @param src 源数组
    * @param srcPos 源数组中的起始位置
    * @param dest 目标数组
    * @param destPos 目标数组中的起始位置
    * @param length 要复制的数组元素的数量
    */

public static native void arraycopy(Object src, int srcPos, Object dest, int destPos,  int length);
```

和

```java
Arrays.copyOf(T[] original, int newLength)
```

而Arrays.copyOf() 底层又使用的是 System.arraycopy()

arraycopy 是一个 native 方法，实现数组复制。而 Arrays.copyOf() 在它的基础上 内部新建了数组，拷贝后进行了返回。



##### ArrayList 插入和删除的时间复杂度

对于插入：

- 头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。
- 尾部插入：当 `ArrayList` 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。
- 指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。

对于删除：

- 头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。
- 尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。
- 指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。



##### ArrayList 和 Array(数组) 的区别：

- Array是固定长度，一旦创建就不能再改变长度。而ArrayList可以动态扩容
- ArrayList可以可以使用泛型确保类型安全。Array不可以
- ArrayList 只能存储对象，如果是基本数据类型则会被自动装箱。而 Array 可以直接存储基本数据类型，也可以存储对象。
- Array 创建后，就只能存储该类型数据。而 ArrayList没有指定泛型时可以存储任意类型数据
- ArrayList 支持添加删除遍历等多种操作，有丰富的 api，而Array只能依照下标操作元素
- ArrayList 创建时不需要指定 大小，而Array需要



#### （2）Vector和Stack

- Stack继承自Vector，是一个先进后出的栈
- Vector 和 Stack 都是线程安全的，都是使用 synchronized 关键字进行同步处理
- 目前二者已经几乎被淘汰，性能较差



#### （3）LinkedList

- 底层使用双向链表（JDK6 之前为双向循环链表，JDK7 取消了循环）
- LinkedList不能实现 RandomAccess接口，因为它是链表实现，不能随机快速访问
- LinkedList 不保证线程安全
- 我们在项目中一般是不会使用到 `LinkedList` 的，需要用到 `LinkedList` 的场景几乎都可以使用 `ArrayList` 来代替，并且，性能通常会更好！



##### 插入和删除时间复杂度

- 头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。
- 尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。
- 指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。



### 4、Set

#### 无序性和不可重复性

- 无序性不等于随机性，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。
- 不可重复性是指添加的元素按照 `equals()` 判断时 ，返回 false才能加入，需要同时重写 `equals()` 方法和 `hashCode()` 方法。

#### 比较HashSet、LinkedHashSet、TreeSet

- 都是Set接口的实现类，都能保证元素唯一，并且都不是线程安全的
- LinkedHashSet 是 HashSet 的子类
- HashSet 底层是哈希表，（HashMap实现）。`LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。LinkedHashSet 并没有自己的独有的方法，都是继承自 HashSet、Object 和 实现Set接口。`TreeSet` 底层数据结构是红黑树（TreeMap实现），元素是有序的，排序的方式有自然排序和定制排序。

- 底层数据结构不同又导致这三者的应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。



### 5、Queue

#### Queue和Deque的区别（二者都是接口）

- Queue是单端列表，只能从一端插入另一端删除，一般遵循先进先出原则（FIFO）。
- Queue扩展了Collection接口，根据 **因为容量问题而导致操作失败后处理方式的不同**，可以分为两类方法：一类是抛出异常，另一类是返回特殊值。

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230523092849060.png" alt="image-20230523092849060" style="zoom:67%;" />



- Deque是双端队列，在队列的两端均可以插入或删除元素。
- Deque扩展了Queue接口，增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230523093107089.png" alt="image-20230523093107089" style="zoom:67%;" />

- **Deque还可以模拟栈，使用 push、pop**



#### ArrayDeque与LinkedList的区别

- ArrayDeque实现了 Deque 接口，继承了 AbstractCollection。LinkedList 实现了 Deque接口和List接口，继承了AbstractSequentialList。  （AbstractCollection也是AbstractSequentialList的间接父类）
- ArrayDeque基于可变长的数组和双指针（head、tail）实现，也就是说可以动态扩容（底层也有一个grow方法）。 LinkedList使用双向链表实现（JDK7及以后取消了循环）
- ArrayDeque 不支持 null 数据存储。LinkedList支持
- ArrayDeque 是JDK6 时才引入的。LinkedList 是 JDK1.2就有
- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。

**从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。**



#### PriorityQueue

`PriorityQueue` 是在 JDK1.5 中被引入的, 其与 `Queue` 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。

- PriorityQueue 底层使用二叉堆实现，使用可变长数组来存储数据
- PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(log n) 的时间复杂度内插入元素和删除堆顶元素
- `PriorityQueue` 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。
- `PriorityQueue` 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。



#### 什么是 BlockingQueue？

`BlockingQueue` （阻塞队列）是一个接口，继承自 `Queue`。`BlockingQueue`阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。

`BlockingQueue` 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。

![BlockingQueue](%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/blocking-queue.png)

Java 中常用的阻塞队列实现类有以下几种：

- `ArrayBlockingQueue`：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。
- `LinkedBlockingQueue`：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为`Integer.MAX_VALUE`。和`ArrayBlockingQueue`类似， 它也支持公平和非公平的锁访问机制。
- `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列。元素必须实现`Comparable`接口或者在构造函数中传入`Comparator`对象，并且不能插入 null 元素。
- `SynchronousQueue`：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，`SynchronousQueue`通常用于线程之间的直接传递数据。
- `DelayQueue`：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。



### 6、Map（重点）

#### （1）HashMap

##### 重要变量介绍

- `DEFAULT_INITIAL_CAPACITY` Table数组的初始化长度： `1 << 4    2^4=16`（为什么要是 2的n次方？）
- `MAXIMUM_CAPACITY` Table数组的最大长度： `1<<30   2^30=1073741824`
- `DEFAULT_LOAD_FACTOR` 负载因子：默认值为`0.75`。 当元素的总个数>当前数组的长度 * 负载因子。数组会进行扩容，扩容为原来的两倍（todo：为什么是两倍？） **<u>答</u>：**跟位置散列有关 [为什么长度一定是2的幂]()
- `TREEIFY_THRESHOLD` 链表树化阙值： 默认值为 `8` 。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。
- `UNTREEIFY_THRESHOLD` 红黑树链化阙值： 默认值为 `6` 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。
- `MIN_TREEIFY_CAPACITY = 64` 最小树化阈值，当Table所有元素超过该值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。

##### 哈希冲突

​		JDK8之前，HashMap底层使用 数组加链表组合，也就是**链表散列**。HashMap 通过 key 的 `hashcode` 经过扰动函数处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。（因为计算出来的位置是同一个，所以在数组同一个位置采用链表串起来）

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jdk1.7_hashmap.png" alt="jdk1.8 之前的内部结构-HashMap" style="zoom:67%;" />

​		所谓扰动函数指的就是 HashMap 的 `hash` 方法。使用 `hash` 方法也就是扰动函数是为了防止一些实现比较差的 `hashCode()` 方法 换句话说使用扰动函数之后可以减少碰撞。

​		而JDK8之后，HashMap 底层变为了数组 + 链表 / 红黑树。在哈希冲突发生时，先判断链表长度是否大于阈值（默认是8），如果没有大于阈值，就直接加在链表后。如果大于了阈值，首先判断数组的长度是否大于64，如果小于64先进行数组扩容，然后将链表转换为红黑树。



##### [为什么长度一定是2的幂]()

跟HashMap通过key确定在数组中的位置机制有关。

HashMap在根据key通过hashCode()计算得到hash时，因为计算到的hash很大，一定会超过数组长度，因此需要处理保证最后的结果在 长度大小范围内。比如说长度为16，那么计算出最终的存储位置就应该是 0 — 15。一般我们考虑是取余操作。 但是HashMap底层的实现是 `(n - 1) & hash`，n表示数组长度，这样的话，就一定要保证 `n-1`的值所有位是1（这样的话n一定是2的幂），这样才能保证 hash 处理后可能落在 0 — n-1 所有的位置。

**举个栗子来反证一下：**
我们现在 数组的长度为 15 减一为 14 ，二进制表示 `0000 1110` 进行相与时候，最后一位永远是0，这样就可能导致，不能够完完全全的进行数组的使用。违背了我们最开始的想要对数组进行**最大限度的无序使用**的原则，因为HashMap为了能够存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表⻓度⼤致相同。

 

##### put和get操作



put方法

- 对key的hashCode()做hash运算，计算index;
- 如果没碰撞直接放到bucket⾥；
- 如果碰撞了，以链表的形式存在buckets后；
- 如果碰撞导致链表过⻓(⼤于等于TREEIFY_THRESHOLD)，就把链表转换成红⿊树(JDK1.8中的改动)；
- 如果节点已经存在就替换old value(保证key的唯⼀性)
- 如果bucket满了(超过load factor*current capacity)，就要resize



get方法

- 对key的hashCode()做hash运算，计算index;
- 如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回；
- 如果有冲突，则通过key.equals(k)去查找对应的Entry;
- 若为树，则在树中通过key.equals(k)查找，O(logn)；
- 若为链表，则在链表中通过key.equals(k)查找，O(n)。



##### HashMap 的线程不安全

​		JDK1.7 及之前版本的 `HashMap` 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 `HashMap`，因为多线程下使用 `HashMap` 还是会存在数据覆盖的问题。并发环境下，推荐使用 `ConcurrentHashMap` 。

​		数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。JDK 1.8 后，在 `HashMap` 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有数据覆盖的风险。

举个例子：

- 两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。
- 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。
- 随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。



##### [HashMap 的 7 种遍历方式与性能分析](https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw)



#### (2) HashMap 和 HashTable 的区别

- 线程是否安全：HashMap线程不安全，HashTable 线程安全，方法都用synchronized修饰。**要线程安全就使用ConcurrentHashMap**，HashTable效率太低

- 效率：因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它

- 对 null key 和 null value 的支持：HashMap 可以存储 null 的键和值，HashTable不可以

- 初始容量和扩容：

  ​		HashMap 不指定容量时，默认为**16**，指定容量时，将给定的容量扩充为**2的幂**。当数组中存储的数量大于 容量 * 负载因子（默认为0.75）时，容量变为2倍。 

  ​		HashTable 不指定参数时，默认为**11**，给定容量时，直接使用给定的参数。每次扩容为 当前容量 * 2 + 1（2n + 1）。

- 底层数据结构： HashMap 底层使用 数组 + 链表/红黑树。 



#### (3) HashMap 和 HashSet

`HashSet` 底层就是基于 `HashMap` 实现的。（`HashSet` 的源码非常非常少，因为除了 `clone()`、`writeObject()`、`readObject()`是 `HashSet` 自己不得不实现之外，其他方法都是直接调用 `HashMap` 中的方法。

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230523154053230.png" alt="image-20230523154053230" style="zoom: 50%;" />

HashSet 在add一个对象时，其实调用的是 HashMap的 map.put(e, PRESENT)   **注：e为add的对象，PRESENT是一个private的静态常量，也就是说，HashSet存储其实是将要存储的对象作为键，所有的键共用一个值**



#### (4) HashMap 和 TreeMap

`TreeMap` 和`HashMap` 都继承自`AbstractMap` ，但是需要注意的是`TreeMap`它还实现了`NavigableMap`接口和`SortedMap` 接口。

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/treemap_hierarchy.png" alt="TreeMap 继承关系图" style="zoom:67%;" />

实现 `NavigableMap` 接口让 `TreeMap` 有了对集合内元素的搜索的能力。

实现`SortedMap`接口让 `TreeMap` 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。



#### (5) ConcurrentHashMap（线程安全）

ConcurrentHashMap继承了AbstractMap，实现了ConcurrentMap接口

- 底层数据结构：JDK1.7 采用 分段数组 + 链表实现， JDK8及以后跟HashMap一样，采用数组 + 链表 / 红黑树实现。
-  **<u>实现线程安全的方式</u>**：JDK1.7时，对整个桶数组进行了分段分割（segment，分段锁），每一把锁只锁容器中的一部分数据，多线程访问不同段的数据时，不会存在锁竞争，提高了并发效率。`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成。`Segment` 继承了 `ReentrantLock`,所以 `Segment` 是一种可重入锁，扮演锁的角色。`Segment` 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。      JDK1.8时，摒弃了 segment思想，直接用 Node数组 + 链表 / 红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS来操作。锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。

​	<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构" style="zoom:50%;" />JDK1.7

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构" style="zoom: 50%;" />             JDK1.8



# 并发编程

## 一、多线程上

### 什么是进程

进程是静态程序的一次动态执行，是系统运行程序的最基本单位。系统运行一个程序即是进程从创建到运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。



### 什么是线程

线程与进程相似，是比进程更小的一个执行单位。一个进程运行过程中会产生多个线程。多个线程共享堆和方法区（JDK8之后的元空间），每个线程都有**自己**的 虚拟机栈、本地方法栈（**保证线程中的局部变量不被别的线程访问到**）、程序计数器。因此系统在产生一个线程或者在多个线程之间切换时，代价相较于进程会小很多。也因此线程也被称为**轻量级进程**。



### 线程和进程的关系及优缺点

- 关系：一个进程中有多个线程，多个线程共享一个进程的堆和方法区，但是各自有各自的虚拟机栈、本地方法栈、程序计数器。 进程和线程的最大不同在于，每一个进程都是相对独立的，而线程不一定，因为同一进程中的多个线程极有可能相互影响。
- 线程的优缺点：线程执行开销小，但不利于资源的管理和保护
- 进程的优缺点：进程执行开销大，但有利于资源的管理和保护



### 程序计数器的作用

- 字节码解释器通过修改程序计数器来依次读取指令，通过修改程序计数器来实现代码的流程控制，如顺序执行、循环、选择等
- 多线程线程切换时，程序计数器记录当前线程的执行的位置，当再次切换回来时，可以明确上次运行的位置

因此，程序技术器一定是线程私有的



### 同步和异步的区别

- 同步：发出一个调用之后，在没有得到结果之前，该调用不可返回，一直等待
- 异步：发出一个调用之后，不用等待结果，都直接返回



### 如何理解线程不安全

线程不安全指的是，在多线程环境中，对于同一份数据，多个线程同时执行可能导致数据的混乱、错误或者丢失。

线程安全指的是，在多线程环境中，对于同一份数据，能保证它的一致性、准确性。



### 线程的生命周期和状态

在Java中，线程有6种状态：

1、NEW：初始状态，线程被创建但是没被调用 start()

2、RUNNABLE：运行状态，线程被调用start()。 **<u>*注意：*</u>**这里与操作系统的状态划分有区别，<u>RUNNABLE里边包含了就绪和运行。</u>

3、BLOCKED：阻塞状态，需要等待锁的释放

4、WAITING：等待状态，表示线程在等待其他线程做出一些特定动作

5、TIMED_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待

6、TERMINATED：终止状态，表示该线程已经运行完毕

- 当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。
- **TIMED_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。
- 当线程进入 `synchronized` 方法/块或者调用 `wait` 后（被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态。
- 线程在执行完了 `run()`方法之后将会进入到 **TERMINATED（终止）** 状态。

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/640.png" alt="Java 线程状态变迁图" style="zoom: 50%;" />

**为什么 JVM 没有区分这两种状态呢？** （摘自：[Java 线程运行怎么有第六种状态？ - Dawell 的回答open in new window](https://www.zhihu.com/question/56494969/answer/154053599) ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。



### 什么是线程上下文切换

上下文：运行条件和状态

​		线程在执行时，会有自己的上下文，比如程序计数器、栈信息等。在线程切换时，需要保留该线程的上下文，留待下次切换回来时恢复现场。并加载下一个将要占用CPU的线程的上下文。这就是所谓的上下文切换。上下文切换要占用CPU、内存的资源。

​		线程在占用CPU执行时，会有以下几种情况放弃CPU，前三种存在上下文切换：

- 时间片用完
- 主动让出CPU，调用了sleep() 或者 wait() 方法
- 调用了阻塞类型的中断，如请求IO
- 被终止或者运行结束（这种情况不发生上下文切换）



### 产生死锁的四个必要条件

- 互斥条件：该资源任何一时刻只能被一个线程占用
- 请求与保持条件：一个线程因请求资源阻塞，不释放已获得资源
- 不可剥夺条件：线程在为执行完时，已获得的资源不能被其他线程强行剥夺
- 循环等待条件：若干线程形成了一种头尾相接的循环等待资源关系



### 预防和避免死锁

预防死锁：

- 破坏请求与保持条件：一次性申请所有资源
- 破坏不可剥夺条件：线程请求其他资源时发现获取不到，就释放手中已经获取的资源
- 破坏循环等待条件：按照特定顺序申请资源

避免死锁：

​		避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。**安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。



### sleep() 和 wait()对比

共同点：二者都可以暂停线程的执行

不同点：

- sleep() 没有释放锁， wait() 释放了锁
- sleep() 是 Thread类的静态方法，而wait() 是 Object 类的方法
- sleep() 通常用于暂停线程， wait() 通常用于线程间通信/交互
- sleep() 执行后会自动苏醒， wait() 执行后不会自动苏醒，直到其他线程调用了同一对象上的 notify() 方法或者 notifyAll()。如果是 wait(long timeout)，则在timeout时间后也会自动苏醒



为什么wait() 方法是 Object类的方法，而sleep是 Thread类的静态方法？

解答：每个对象都可以作为对象锁，因为 wait() 方法是暂停当前获得对象锁的线程，并且自动释放对象锁，是通过对作为锁的对象做操作，因此 wait() 方法要是每一个对象都有的方法。而 sleep() 方法仅仅是暂停当前线程，没有释放锁，所以只跟当前线程有关，不涉及对象锁，作为Thread的方法就够用。



### join()

A线程中执行另一线程B的 join 方法，则A线程会等待B线程执行完毕才接着往下执行      join（long）这个重载方法则可以指定一个等待时间，超过等待时间则A不再等待B执行完毕



### 守护线程

Java 程序入口就是 JVM 启动 main 线程，main 线程又启动其他线程，直到所有非守护线程都执行结束，JVM 才退出。

**但是**，有一类线程并不自动结束，比如定时任务线程

```java 
class TimerThread extends Thread {
    @Override
    public void run() {
        while (true) {
            System.out.println(LocalTime.now());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}
```

这种线程就会一直执行下去，无法退出。此时就需要有一种“专用的“线程，不需要“引起”JVM注意，也就是，不论这个线程退不退出，JVM 都可以退出。 **守护线程就出现了，**守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。因此，JVM退出时，不必关心守护线程是否已结束。

如何创建守护线程呢？方法和普通线程一样，只是在调用`start()`方法前，调用`setDaemon(true)`把该线程标记为守护线程：

```java
Thread t = new MyThread();
t.setDaemon(true);
t.start();
```

在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。    守护线程用来做定时任务是最好的例子



## 二、多线程下



### 中断线程

[中断线程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554)

对目标线程调用`interrupt()`方法可以请求中断一个线程，目标线程通过检测`isInterrupted()`标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到`InterruptedException`；

目标线程检测到`isInterrupted()`为`true`或者捕获了`InterruptedException`都应该立刻结束自身线程；

通过标志位判断需要正确使用`volatile`关键字；	

`volatile`关键字解决了共享变量在线程间的可见性问题。



### volatile 关键字

volatile关键字用来修饰变量，被volatile修饰说明此变量是共享并且不稳定的，每次使用这个变量都要从主存中读取。这一关键字保证了变量的可见性。



<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jmm.png" alt="img" style="zoom:50%;" />             **未被volatile修饰**



<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/jmm2.png" alt="JMM(Java 内存模型)强制在主存中进行读取" style="zoom: 50%;" />			**被volatile修饰**



**volatile可以保证数据的可见性，但是不能保证数据的原子性**



​		除了保证数据的原子性外，volatile还可以防止 JVM 的指令重排序，如果某变量被volatile修饰，在对该变量进行读写时，会插入特定的内存屏障，来静止指令重排序

> **<u>注：</u>**指令重排序是指，为了提升效率，提高CPU利用率，将指令的执行顺序进行修改。（有可能导致结果的不一致）；       内存屏障就是一组同步屏障指令，是一个同步点，在此同步点之前的所有操作结束后才能进行此点之后的操作             
>
> ​		指令重排序就是一种来源于生活的优化思想，这种思想在生活中处处可见，就像平常咱们做菜，咱们会选择在炒第一个菜的同时就在洗第二个菜了， 咱们会把熟得最慢的菜放到最开始（比如煲汤），因为在等待这些菜熟的过程中（IO等待）咱们(CPU)还可以做其它事情，这就是一种时间上的优化，在计算机领域也是一样，它也会根据指令的类别做一些优化，目的就是把CPU的资源利用起来，这样就能就能提升整个计计算机的效率。



举例：**双重校验锁实现对象单例（线程安全）**

```java
//懒汉式
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}

```

​		uniqueInstance 变量被 volatile 修饰了，因此就保证了这个变量的可见性，以及禁止了关于这个变量的指令重排序。    `uniqueInstance = new Singleton();` 这条语句并不是原子操作，其实分为三步操作：

- 1、为 uniqueInstance 分配内存
- 2、初始化 uniqueInstance
- 3、将uniqueInstance 指向分配的内存地址

​		这三步顺序执行是正确的，但是由于**JVM 有指令重排序**，执行顺序就有可能变成 1 - 3 - 2；假设线程1此时完成了 1 和 3 操作就切换为了线程2，此时线程2 进行判断，发现 uniqueInstance **不为 null**，则**直接返回**了 uniqueInstance，但此时 uniqueInstance **实际上并未初始化**。



### 乐观锁和悲观锁

​		1、悲观锁：总是假设最坏的情况，即共享资源每次被访问的时候都有可能出现问题（比如共享数据被修改），所以每次对共享资源进行操作时都会上锁，其他线程想获取该资源就会被阻塞。也就是说，共享资源任何一个时刻只能被一个线程使用，其他线程阻塞，直到该线程释放资源。  **synchronized、ReentrantLock等独占锁就是悲观锁思想的实现**。

> ​		高并发场景下，激烈的锁竞争会导致大量线程阻塞，大量阻塞线程会导致系统切换上下文，增加系统性能开销。而且，悲观锁还会导致死锁等情况发生。

​		2、乐观锁：总是假设最好的情况，即共享资源每次访问都不会产生问题，线程可以不断执行，无需加锁也无需等待。只是在提交的时候判断相关资源是否被其他线程修改过（**具体实现有版本号机制、CAS算法**）

> ​		高并发场景下，由于乐观锁没有加锁，线程不存在阻塞，并且不会造成死锁等问题，在性能上往往比悲观锁实现更好。但是，如果冲突发生比较频繁（大量写的情况），就可能频繁失败和重试，同样影响性能。



理论上来说：

- 悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如`LongAdder`），也是可以考虑使用乐观锁的，要视实际情况而定。
- 乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考`java.util.concurrent.atomic`包下面的原子变量类）。



### 乐观锁的实现（版本号机制和CAS算法）

CAS算法使用的多一点



1、版本号机制

​		在数据表中加入一个数据版本号 version，表示数据被修改的次数，当数据被修改时，version加一。线程A要更新共享数据时，在读取数据时也会读取版本号，在提交更新时，先判断版本号和数据库中的版本号值是否一致，一致就提交更新，如果不一致，则重试所有操作，直到更新成功。

举例：

> ​	假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ `balance` ）为 $100 。
>
> 1. 操作员 A 此时将其读出（ `version`=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。
> 2. 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ `version`=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。
> 3. 操作员 A 完成了修改工作，将数据版本号（ `version`=1 ），连同帐户扣除后余额（ `balance`=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 `version` 更新为 2 。
> 4. 操作员 B 完成了操作，也将版本号（ `version`=1 ）试图向数据库提交数据（ `balance`=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。



2、CAS算法

​		CAS 全称 Compare And Swap，CAS思想很简单，就是用一个预期值和要更新的变量值进行比较，相等才会更新。**CAS操作是一个原子操作，底层依赖于一条CPU的原子指令**



CAS涉及3个操作数：

1. V：要更新的变量值（Var）
2. E：预期值（Expected）
3. N：拟更新的新值（New）

当且仅当 V == E 时，CAS通过原子操作用新值 N 来更新 V 的值。如果不相等，则说明其他线程修改了当前变量，当前线程就放弃更新。



**举一个简单的例子**：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。

1. i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。
2. i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。

当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。



### 乐观锁存在的问题

1、ABA问题： 

​		即A线程获取到V，B线程修改了共享变量，V变成了 V1，后又有一个线程修改了共享变量，使V1又变回了V。那么此时对于A线程来说，它是感受不到发生的变化的，但实际上共享变量已经被操作过了。

2、循环时间长开销大：

​		CAS经常使用自旋操作来进行操作，即不成功就一直循环直到成功。如果时间长不成功，一直重试，会给 CPU 带来非常大的执行开销。

3、只能保证一个共享变量的原子操作：

​		CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了`AtomicReference`类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference`类把多个共享变量合并成一个共享变量来操作。



### synchronized关键字

​		synchronized 是 Java 的一个关键字，主要解决多个线程之间访问资源的同步性，可以保证被其修饰的方法或者代码块在任何一时刻只能由一个线程操作。



#### synchronized的用法

synchronized关键字主要有三个使用方式：

- 修饰实例方法
- 修饰静态方法
- 修饰代码块



1、修饰实例方法（锁当前对象实例）

```java
public synchronized void method(){
    //balabalaba.....
}
```

给当前对象实例加锁，在进入方法之前，要先获得当前对象实例的锁



2、修饰静态方法（锁所在类）

```java
public static synchronized void method(){
    //balabala...
}
```

因为静态方法是类方法，所以是给所在类加锁，在进入方法之前，先要获得所在类的锁



3、修饰代码块

```java
synchronized(this) {
    //balabala...
    //表示进入同步代码库前要获得 给定对象的锁
}

synchronized(Object.class) {
    //balabala...
    // 表示进入同步代码前要获得 给定 Class 的锁
}
```



**总结：**

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁；
- `synchronized` 关键字加到实例方法上是给对象实例上锁；
- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能。



**构造方法不能使用 synchronized 关键字修饰。**

构造方法本身就属于线程安全的，不存在同步的构造方法一说。



#### synchronized底层原理

​		1、synchronized关键字同步代码块时，实际使用的是 monitorenter 和 monitorexit 这两个指令。 其中，monitorenter 指令指明代码块开始的位置， monitorexit 指令指明代码块结束的位置。 一个monitorenter 指令一般会匹配两个 monitorexit 指令，目的是不论是正常结束还是异常结束都能正确释放锁。

​		当执行 monitorenter 指令时，线程试图获取锁也就是获取**<u>对象监视器</u>** monitor 的使用权



> 在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 `ObjectMonitor`对象。
>
> 另外，`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。

​		

​		在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。

​		对象锁的的拥有者线程才可以执行 `monitorexit` 指令来释放锁。在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。



​		2、synchronized修饰方法时，并没有 monitorenter 和 monitorexit 指令。取而代之的是 `ACC_SYNCHRONIZED ` 标识，这个标识表明这个方法是一个同步方法。JVM 根据这个标识判断出这个方法是同步方法，然后执行相关同步调用。但是本质上和同步代码块时一样，都是对 **对象监视器 monitor** 的获取。

​		

#### synchronized 和 volatile 的区别

- volatile 关键字是线程同步的轻量级实现，性能比 synchronized 好。
- volatile 关键字只能修饰变量，而 synchronized 关键字可以修饰 代码块和方法。
- volatile 只能保证数据的可见性，不能保证数据的原子性，synchronized 关键字二者都可以保证。
- volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 主要用于解决多个线程之间访问资源的同步性。



### 公平锁和非公平锁

- **公平锁** : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。

- **非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。**（synchronized是非公平锁）**



### 可重入锁

​		**可重入锁** 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。



### 可中断锁和不可中断锁

- **可中断锁**：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。`ReentrantLock` 就属于是可中断锁。
- **不可中断锁**：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 就属于是不可中断锁。



## 三、多线程下



### ThreadLocal

​		在多线程情况下，通常我们创建的变量可以被所有线程访问并修改。而如果想要每一个线程独有一份变量时，就要使用 JDK 中自带的 ThreadLocal 类， **`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

​		如果创建了一个`ThreadLocal`变量，那么访问这个变量的每个线程都会有这个**变量的本地副本**，这也是`ThreadLocal`变量名的由来。他们可以使用 `get()` 和 `set()` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。



#### **<u>*ThreadLocal的原理*</u>**：

Thread类中有有两个变量：

```java
ThreadLocal.ThreadLocalMap threadLocals = null;
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
```

​		ThreadLocalMap 是 ThreadLocal 类的一个静态内部类（其实可以理解为 ThreadLocal 就是对 ThreadLocalMap 做了一个封装），当使用 ThreadLocal 进行 set() 操作时，实际调用的是 ThreadLocalMap 的 set() 方法：

```java
public void set(T value) {
	Thread t = Thread.currentThread();
	ThreadLocalMap map = getMap(t);
	if (map != null) {
		map.set(this, value);
	} else {
		createMap(t, value);
	}
}
```

​		可以看到，set() 方法中首先是获取当前的线程，然后再获取当前线程的 threadlocals 变量， 通过调用这个变量的 set () 方法，将当前 ThreadLocal 作为 key，将 set 的值作为 value，存放到 threadLocals 中。

**注意：**每个线程都有自己的变量副本实际上跟 ThreadLocal 关系不大，它仅仅是作为一个工具类。一般在声明 ThreadLocal 类的实例时，一般都声明为 static final ，也就是说，实际上所有的线程都是同一个 ThreadLocal 类实例，在 map.set(this, value) 时，所有的线程的map 的 key 也都是一样的。 **<u>*而真正实现每个线程都有自己的变量副本的是：*</u>**  每创建一个线程，Thread 类中的 threadlocals 变量就会新创建一份，也就是说，每一个线程都有自己的 map， 这样不管 key 是啥，对应当前线程来说，value 都是独一份的，因为 map 都是独一份的。



#### ThreadLocal的内存泄漏问题

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用，而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。

这样一来，`ThreadLocalMap` 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。



### [线程池详解（ThreadPoolExecutor）](https://zhuanlan.zhihu.com/p/34405230)

一、线程池的优点：

线程池能对资源进行统一管理和分配

（自述）线程的创建和销毁需要资源开销，使用线程池可以将线程使用后放回线程池，极大的降低了开销。并且，线程的创建需要时间开销，任务不会被立即接收，使用线程池就极大的降低了时间开销，拿来就用

（标答）

- 降低资源消耗（单个线程创建需要资源开销，使用完就直接销毁了，开销比较大）
- 提高响应速度
- 提高线程的可管理性

二、线程池的创建：

所有Executors提供的线程池都是基于这个：

```java
new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler)
```

1、Executors.newSingleThreadExecutor()

- 单个线程的线程池，核心线程数和最大线程数都是1。
- 存活时间为0，也就是不销毁。
- 任务队列采用LinkedBlockingQueue，无界，也就是永远不会拒绝任务，饱和策略失效。会出现 OOM  错误

2、Executors.newCachedThreadPool()

- 可缓存线程池，核心线程数为0，最大线程数为 Integer.MAX_VALUE。
- 存活时间为60s。
- 任务队列使用SynchronousQueue，同步队列，容量为0，不存放任务，消费任务和生产任务的线程匹配上时，才起作用
- 主线程调用SynchronousQueue的offer()方法放入task, 倘若此时线程池中有空闲的线程尝试读取 SynchronousQueue的task, 即调用了SynchronousQueue的poll(), 那么主线程将该task交给空闲线程.当线程池为空或者没有空闲的线程, 则创建新的线程执行任务.执行完任务的线程倘若在60s内仍空闲, 则会被终止. 因此长时间空闲的CachedThreadPool不会持有任何线程资源

3、Executors.newFixedThreadPool(int nThread)

- 固定核心线程数的线程池，线程数固定为 nThread
- 存活时间和最大线程数量 失效
- 任务队列使用 LinkedBlockingQueue，无界队列，如果没有空闲线程就一直往里加，直到 OOM。包和策略失效

4、Executors.newScheduledThreadPool(int corePoolSize)

- 核心线程数为 corePoolSize，最大线程数为 Interger.MAX_VALUE 
- 存活时间为0

#### 1、[execute 和 submit 的区别](https://blog.csdn.net/qing040513/article/details/111667627)



### Future



### AQS





# 数据库

## 一、数据库基础知识

### 什么是数据库，数据库管理系统，数据库系统，数据库管理员

数据库（DB）：一组数据的集合或者说是信息的集合

数据库管理系统（DBMS）：用于操纵、管理数据库的大型软件，通常用于建立、使用和维护数据库

数据库系统（DBS）：包括数据库、数据库管理系统和数据库管理员

数据库管理员（DBA - Administrator）：负责全面管理和控制数据库系统



### 数据库范式

第一范式1NF ：属性不可再分

第二范式2NF ：在第一范式的基础上，消除了非主属性对于码的部分函数依赖

第三范式3NF ：在第二范式的基础上，消除了非主属性对于码的传递函数依赖



### 为什么不推荐外键和级联

级联：如果更新一个属性，同时触发了另一个属性的更新，则称为级联更新

高并发、分布式不适合使用外键和级联，低并发的单体项目可以考虑使用外键和级联

不推荐的原因：

- 级联更新是强阻塞，可能导致数据库更新风暴
- 外键影响数据库的插入速度



为什么不推荐使用外键：

- **增加了复杂性**：需要时刻考虑外键
- **增加了额外工作**：当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源
- **对分库分表不友好**：因为分库分表下外键是无法生效的



### drop、delete、truncate区别

drop：`drop table_name`  直接将整个表结构删掉，当然包括表中的数据

delete：`delete from table_name where ...` 根据条件删除表中的行数据

truncate：`truncate table_name` 将表清空，但是不影响表结构，相当于 `delete from table_name`

**比较：**

- delete属于DML，这个操作可以回滚，在事物提交之后才生效。而drop、truncate属于DDL，操作立刻生效，不能回滚，不触发trigger
- 一般情况下 drop > truncate > detele，因为delete命令执行时，还要产生数据库的 binlog 日志



## 二、SQL语法

### 1、SQL分类：

DDL（Data Definition Language）：定义数据库对象，有 CREATE、ALTER、DROP

DML（Data Management Language）：用于数据库操作，有 INSERT、UPDATE、DELETE、SELECT

DCL （Data Control Language）：用于对数据访问权进行控制，有 GRANT、REVOKE

TCL （Transaction Control Language）：用于管理数据库中的事物，有 COMMIT、ROLLBACK



### 2、DDL详解

#### **数据库：**

- 新建数据库：create database database_name
- 删除数据库：drop database database_name
- 使用数据库：use database_name



#### **表：**

- 新建表

  ```sql
  create table user(
  	id int(10) unsigned not null auto_increment comment '自增ID',
      username varchar(20) not null default 'username' comment '用户名',
      password varchar(20) default 'password' comment '密码',
      primary key(id)
  ) engine=InnoDB auto_increment=2 default charset=utf8mb4 comment='用户表';
  ```

- 删除表：drop table user

- 修改表：

  ```sql
  alter table user add age int(3);     ##添加一列
  alter table user drop column age;    ##删除一列
  alter table user modify column age tinyint;     ##修改列
  alter table user add primary key (id);			##添加主键
  ```



#### **视图：**

视图是基于 SQL 结果集的可视化的表，视图是虚构的表，本身不包含数据，当然也就不能对其进行索引操作。对视图的操作和对普通表一样

视图的作用：

1. 简化复杂的SQL操作
2. 只使用实际表的一部分数据
3. 通过只给用户访问视图的权限，保证数据的安全性
4. 更改数据格式和表示



- 创建视图：create view view_name (sql语句，有结果的)
- 删除视图：drop view view_name



#### **约束**：

约束用于规定表中的数据规则，如果存在违反约束的数据行为，行为就会被约束终止。

约束类型：

not null 、 unique、primary key、foreign key、default(默认值)、check(符合特定条件)



### 3、事物处理

不能回退 select 语句，也不能回退 create、drop 语句。MySql 默认是隐式提交，每执行一条语句就把这条语句当作一条事务进行提交。当出现 start transaction 语句时，关闭隐式提交，当 commit 或者 rollback 执行后，事务自动关闭，重新恢复隐式提交。

set autocommit = 0 可以取消自动提交，直到 set autocommit = 1 才会提交；autocommit针对单个连接而不是服务器。

指令：start transaction（开启事务）、savepoint（创建保留点）、rollback（事务回滚）、rollback to savepoint（回滚到指定保留点）、commit（事务提交）

```sql
-- 开始事务
START TRANSACTION;

-- 插入操作 A
INSERT INTO `user`
VALUES (1, 'root1', 'root1', 'xxxx@163.com');

-- 创建保留点 updateA
SAVEPOINT updateA;

-- 插入操作 B
INSERT INTO `user`
VALUES (2, 'root2', 'root2', 'xxxx@163.com');

-- 回滚到保留点 updateA
ROLLBACK TO updateA;

-- 提交事务，只有操作 A 生效
COMMIT;
```



### 4、权限控制

授予用户权限使用 grant，撤销用户权限使用 revoke

```sql
grant privilege on privilege_level to user
revoke privilege on privilege_level from user
```

- privilege 有 select、update、delete等等
- privilege_level 有 整个服务器 （使用 grant all）、整个数据库（使用 on database.*）、特定的表（on database.table）、特定的列、特定的存储过程
- grant、revoke 一次性可以授予/撤销多个 权限，用逗号隔开
- grant 的 user 如果已经存在，则是对权限的修改，如果不存在，则新建一个用户。**新建的用户没有任何权限**



```sql
##创建用户
create user myuser identified by 'mypassword';

##修改用户名
update user set user = 'newname' where user = 'myuser';
flush privileges;

##删除用户
drop user newname;

##查看权限
show grants for newname;

##授予权限
grant select, insert on *.* to newname;

##撤销权限
revoke select, insert on *.* from newname;
```



### 5、存储过程

存储过程可以看作是对一系列 sql 操作的批处理。存储过程可以由 触发器、其他存储过程以及Java、Python等应用程序调用。

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/60afdc9c9a594f079727ec64a2e698a3tplv-k3u1fbpfcp-zoom-1.image" alt="mysql存储过程" style="zoom: 67%;" />

​												  	GetAllProducts 就是一个存储过程，可以被调用		

存储过程的好处：

- 代码封装，提供了安全性
- 代码复用
- 预先编译，性能较高



### 6、游标（暂无）

### 7、触发器

触发器是一种与表相关的数据库对象，当触发器所在表上发生某些特定事件时，就会调用该对象。

**优点：**

- 触发器提供了另一种保证数据完整性的方式
- 触发器可以捕获数据库层中业务逻辑的错误
- 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器
- 触发器对于审计表中数据的更改非常有用

**缺点：**

- 从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么
- 可能会增加数据库开销
- 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证



示例：

```mysql
create trigger 'mytrigger' 
after insert on 'user'
for each row
begin
	insert into 'user_log' (user_id, user_name) values (new.id, 'user');
end

##新的行用new，旧的用 old ; 有 before insert、after insert、before update、after update、before delete、 after delete 六种触发时机 
```



## 三、MySQL



### 1、MySQL 优点

- 开源免费
- 成熟稳定，功能完善
- 事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的
- 支持分库分表、读写分离、高可用
- 文档完善，学习资源丰富
- 兼容性好，支持常见的操作系统，支持多种开发语言
- 生态完善，社区活跃



### 2、MySQL基本架构

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/13526879-3037b144ed09eb88.png" alt="img" style="zoom: 67%;" />

简单来说，分为两层，Server层和存储引擎层。

- server层有 连接器、查询缓存（MySQL 8 已删除）、分析器、优化器、执行器等。所有跨存储引擎的功能都在这一层实现，比如 存储过程、触发器、视图、函数等。还有一个通用的日志模块 binlog 日志模块。
- 存储引擎主要负责数据的存储和获取，采用可以替换的插件式架构。支持 InnoDB、MyISAM、Memory等存储引擎。目前的MySQL版本默认使用 InnoDB，其有自有的日志模块 redolog 模块。

server层详解

- 连接器：和身份验证、权限相关的功能有关，好比一个保安。 在用户登录数据库时，对密码进行验证，验证通过后，在权限表中查询该用户的所有权限，之后在这个连接中一直使用此时查询到的权限进行权限限制。也就是说，只要这次连接没有断开，就算修改了该用户的权限，也不影响此次连接。
- 查询缓存：当发现是 select 操作时，MySQL 先校验该查询语句之前是否执行过，如果执行过就返回缓存，没有执行就交给分析器执行后续操作，然后将结果放入缓存。缓存是以 key-value 的格式存储。（**当然，就算是查询缓存也要校验权限**）。 由于表中数据更新相关表的缓存就要全部清空，因此如果是在更新较频繁的场景，查询缓存带来了较大的额外开销。**因此不推荐使用查询缓存，MySQL在 8 版本时已经删除了这个功能**
- 分析器：对 SQL 语句进行词法分析、语法分析
- 优化器：词法分析、语法分析完成后，如何执行才能性能最好效果最好就需要考虑了。优化器的作用就是它认为的最优的执行方案去执行，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。
- 执行器：优化完成后，具体的执行逻辑已经确定下来了，MySQL就准备开始执行，首先执行前会校验用户有没有权限，如果没有权限，返回错误信息。如果校验通过，则调用存储引擎的接口，返回接口执行的结果。



### 3、SQL语句在MySQL中的执行过程

语句分为两类，一类是查询语句（select），另一类是更新语句（update、insert、delete）

对于查询语句，执行过程为 连接器 -> 权限校验（前提是缓存命中）-> 查询缓存 (如没有缓存则下一步) -> 分析器 -> 优化器 -> 执行器

对于更新语句，前半部分操作与查询语句相同，先查询出要修改的数据，然后对数据进行修改，然后调用引擎的接口，写入这一行数据。当然，由于是更新，所以要记录日志。

更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)

以 InnoDB 引擎为例：

- 先查询到数据，如果有缓存，也是会用到缓存。
- 然后拿到查询的数据进行修改，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
- 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。
- 更新完成。

**为什么要两个日志?**

因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。

**为什么redo log 要先进入 prepare 状态,等 binlog 记录后才提交?**

用反证法来说明下为什么要这么做？

- **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。
- **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。



### 4、MySQL 存储引擎

- show engines 命令可以查询支持的所有引擎
- MySQL 5.5.5 版本以前默认存储引擎是 MyISAM, 之后的默认引擎是 InnoDB

#### MySQL存储引擎的架构

存储引擎采用插件式架构,支持多种存储引擎. 我们甚至可以为不同的表设置不同的存储引擎来适应不同的场景.存储引擎是基于表的,不是基于数据库.



#### MyISAM 和 InnoDB 的区别

- MyISAM 只支持表级锁，InnoDB支持行级锁和表级锁，默认为行级锁
- MyISAM 不提供事务支持，InnoDB 提供事务支持，实现了 SQL 标准定义的四种隔离级别，具有 commit、rollback 功能，默认为 可重复读（Repeatable-Read），但是可以解决幻读问题（一般可重复读只是解决了 脏读和不可重复读两个问题，没有解决幻读问题），使用 MVCC、Next-Key Lock 实现
- MyISAM 不支持数据库异常崩溃后的安全恢复，InnoDB 支持，依赖于 redo log 
- MyISAM 不支持 MVCC，InnoDB 支持
- MyISAM 不支持外键，InnoDB 支持
- MyISAM 性能低于 InnoDB 
- 二者虽都使用 B+ 树作为索引结构，但实现方式不一样



### 5、记录存储的行格式

![img](%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/COMPACT.drawio.png)

[MySQL 一行记录是怎么存储的？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/base/row_format.html#innodb-行格式有哪些)



### 6、MySQL索引

#### B+树

为什么选用 B+ 树？而不是 B 树、平衡二叉树、二叉树、Hash

B+ 树只在叶子节点存储数据，非叶子节点只存索引，相较于B 树的节点既存索引又存数据，B+ 树的非叶子节点可以存储更多的索引，因此 B+ 树更加“矮胖”，查询数据时磁盘 I/O 次数少

B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引，因为某节点的索引在子节点中都存在），这些冗余索引让 B+ 树在插入、删除地效率更高，而 B树 在插入删除时会发生复杂的树的变化

B+ 树的所有叶子节点之间用双向链表进行了连接，有利于范围查询，而 B树要进行范围查询则只能通过遍历实现

对于平衡二叉树、二叉树等各种各样的二叉类型树，在数据量稍大时，树的高度很高，性能很差

Hash 只适合等值查询，不适合范围查询

#### 什么是索引

索引就是数据的目录，是帮助存储引擎快速获取数据的一种数据结构

#### 索引的分类

（1）按照**数据结构**分类：B+树索引、Hash索引、Full-Text索引

Mysql 默认支持的 InnoDB 只支持 B+树索引和 Full-text 索引，不支持 Hash 索引，MyISAM 也是

（2）按照**物理存储**分类：聚簇索引、二级索引（辅助索引）

InnoDB下， 聚簇索引是每张表一定有的

- 如果有主键，默认使用主键作为聚簇索引的索引键key
- 如果没有主键，则使用第一个不包含 null 的 unique 列作为索引键
- 如果都没有，则 InnoDB 自动生成一个隐式自增的 id 作为索引键 

其他索引都属于二级索引，二级索引也是 B+ 树，**与聚簇索引的 B+ 树叶子节点存数据不同，二级索引的 B+ 树的叶子节点存的是目标记录的主键值**，在查到主键值时，再进行聚簇索引查询，查到目标记录，这个过程也叫做**回表**。但是如果查询的目标就是主键，则二级索引就可以查得到，就不用再回表，这个叫 **索引覆盖**。

（3）按照**字段特性**分类：主键索引、唯一索引、普通索引、前缀索引

唯一索引就是字段值不重复，可以有 null，但是只能有一个

前缀索引就是以字段的前缀作为索引，目的是减小索引占用的空间，提升效率

（4）按照**字段数量**分类：单列索引、联合索引

联合索引存在最左匹配原则，先从最左边的排序，然后右边的依次编序。按照最左优先的方式进行索引的匹配。如果不遵循最左匹配原则，则索引失效。

比如有一个联合索引 （a，b，c），这几种情况就可以匹配的到：

- where a=1；
- where a=1 and b=2 and c=3；
- where a=1 and b=2；

但是如果缺失最左的，用右边的匹配则失效：

- where b=2；
- where c=3；
- where b=2 and c=3；

**联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配**。



**索引下推优化**：

在联合索引查询时，对于联合索引（a, b），在执行 `select * from table where a > 1 and b = 2` 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？

- 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。
- 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， **可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**。（注意，是减少回表次数，但是仍然要回表判断b）



#### 什么时候需要/不需要索引（针对字段）

索引并不一定总是好的，因为 

- 索引需要占用物理空间 
- 索引创建、维护需要成本
- 降低增删改的效率，因为在增删改时 B+ 树为了保证索引的有序，需要动态维护 



适合索引的场景：

- 字段有唯一性限制
- 经常作为 where 查询条件的字段
- 经常用于 group by 、order by 的字段，这样在查询的时候就不需要再去做一次排序了，因为B+树就是有序的

不需要索引的场景：

- where、group by、order by 使用不到的字段
- 字段中存在大量重复的，比如性别，创建索引没有意义
- 表数据太少的
- 经常更新的字段不需要索引，因为每次更新都要维护索引



#### 索引优化方法

- 前缀索引优化

使用某个字段的前缀作为索引，这样可以减小索引字段的大小，一个索引页中的索引就会变多，从而查询效率就会提高

不过有局限性：order by 无法使用前缀索引、无法把前缀索引用作覆盖索引（因为就算查到了，前缀也只是部分数据，还是得回表查完整数据）

- 覆盖索引优化

意思就是尽量使查询的字段可以在二级索引中直接获得，避免回表

比如只需要查询商品的名称、价格，可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。

- 主键索引最好是自增的

因为B+ 树的索引本身是有序的，在插入操作中，如果主键索引是自增的，则直接插入到后面就行，但是如果不是自增的，则可能插在中间，造成页分裂（不详解了）

- 索引字段长度尽量短
- 索引最好设置为 not null

① 索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化

② NULL 值是一个没意义的值，但是它会占用物理空间（行格式 NULL 值列表有关）



#### 索引失效情况

- 对索引使用左或者左右模糊匹配    like '%aa'   或者  like '%AA%'
- 对索引使用函数
- 对索引进行表达式计算
- 联合索引非最左匹配
- where 语句中的 or
- 对索引进行隐式类型转换：**MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。

```mysql
//phone本身是varchar   id是int
//失效  因为phone每次比较前会转换为数字，相当于对phone进行了函数计算
select * from t_user where phone = 1300000001;
//不失效   因为字符串会转为数字 '1' 会转为数字 1
select * from t_user where id = '1';
```



#### count(*)、count(1)、count(主键)、count(字段)性能

count(*) = count(1) > count(主键) > count(字段)

count(*) 就是 count(0) 

count(1) 只需要读取记录，但是不会读取记录中的字段的值。而count(主键)需要读字段的值，所以性能稍差。count(1)不排除字段为null

count(字段) 字段是非索引，是普通字段，所以不会使用索引查询，而是全表扫描



### 7、MySQL日志

MySql



### 8、MySQL事务

事务是由MySQL 的引擎来实现的，常见的InnoDB就是支持事务的，但是 MyISAM不支持事务



#### 开启事务的两种命令

- begin / start transaction ：并不代表事务真正启动了，直到执行这个命令之后执行了具体的 SQL，事务才是真正的启动 
- start transaction with consistent snapshot：立即启动事务



#### 事务的特性

- 原子性（Atomicity）：事务要么一次性全部执行完，要么都不执行。如果执行中间发生错误，事务回滚
- 一致性（Consistency）：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。换一种解释，**事务操作前后的结果应与所抽象的客观世界真实状况保持一致**。比如说转账，转完后就应该一方减少一方增加
- 隔离性（Isolation）：数据库允许多个并发事务同时操作数据库，多个并发事务操作同一数据时，互相不会产生干扰，也就是并发事务被“隔离”开了
- 持久性（Durability）：事务处理结束后，对数据库的修改就是永久的， 即使系统故障也不会丢

InnoDB通过不同技术保证这四个特性：

1. 原子性通过 undo log（回滚日志）来保证
2. 持久性通过 redo log（重做日志）来保证
3. 隔离性通过MVCC（Multi-version Concurrency Control，多版本并发控制）或者锁机制来实现
4. 一致性通过 原子性 + 持久性 + 隔离性 来保证



#### 并发事务导致的问题

- 脏读（dirty read）：A 事务修改了数据，但是事务还未提交，B此时读到了A修改后的数据，结果A发生了错误，回滚了，那么B之前读到的数据就是错误的，也就是脏读
- 不可重复读（non-repeatable read）：A 事务读取了数据，然后B对这个数据进行了修改，提交了事务，A再次读这个数据时，发现与之前读的不同了
- 幻读（phantom read）：A 事务查询了符合某个条件的多条记录，接着 B 事务增加了一条满足这个条件的记录，A 再次查询时，发现记录数和之前不一致了



#### 事务的隔离级别

读未提交（read uncommitted）：一个事务还没有提交，它做的变更其他事务就可以看到

读提交（read committed）：一个事务只有提交了，它做的变更其他事务才可以看到

可重复读（repeatable read）：一个事务开始了，在执行期间读到的数据都与开始时读到的数据一致。**InnoDB默认的隔离级别**

串行化（serializable）：会对记录加上读写锁，如果有事务在操作这条记录，其他事务就需要等待，直到占有锁的事务结束



#### 四种隔离级别的实现

读未提交：因为可以读到未提交事务修改的数据，所以直接读最新的数据就可以

串行化：通过加锁操作来实现

读提交、可重复读：通过 Read View 实现，区别在于创建 Read View 的时机不同。**Read View 可以看作是一个数据快照，定格某一时刻的数据状态**。    读提交是在每条语句执行之前创建 Read View，也就是说，一个事务中可以创建多个 Read View；可重复读是在事务启动时创建 Read View，然后整个事务期间就使用这一个 Read View。



#### Read View 在 MVCC 中如何工作

Read View 有四个字段：

- creator_trx_id（创建这个快照的事务 id）
- m_ids（所有未提交活跃的事务 id）
- min_trx_id（所有活跃的事务中最小的 id）
- max_trx_id（所有活跃的事务中最大的 id + 1，也就是准备给下一个事务分配的id）

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:50%;" />



在之前了解的记录存储的行格式中，有两个字段 

- trx_id：修改这条记录的事务 id 

- roll_pointer：每次对记录进行修改时，就会把旧版本的记录写入到 undo 日志中（回滚日志），然后 roll_pointer 就是指向上一个旧版本的记录，通过这个指针，就可以实现回滚操作

举个例子，原本有条记录是被事务 id 为 50 的事务修改的，则此时的行格式为

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230720104114543.png" alt="image-20230720104114543" style="zoom: 33%;" />

此时有一个事务 id 为51的事务A对记录做了修改，则变为：

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230720104153167.png" alt="image-20230720104153167" style="zoom:33%;" />

可以很明确的看到 roll_pointer 的作用



***Read View 如何工作就是依靠 自己的四个字段和记录中的 trx_id 和 roll_pointer***

当发现 **trx_id 小于 Read View 中的 min_trx_id** 时，说明这条记录是被**已经提交的事务修改**的，所以这个版本的记录对当前事务是**可见**的。

当发现 **min_trx_id =< trx_id < max_trx_id** 时，如果 **trx_id 在 m_ids 中**，说明这条记录是未提交事务修改的， 对当前事务**不可见**；如果**不在 m_ids 中**，则说明是**已提交事务修改**的，则这个版本的记录对当前事务是**可见**的。

当发现 **max_trx_id =< trx_id** 时，说明这条记录是 **Read View 创建以后新启动的事务修改**的，则这个版本记录对当前事务**不可见**。



具体举例细节看：[事务隔离级别是怎么实现的？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-在-mvcc-里如何工作的)    讲的非常详细



#### MySQL可重复读隔离级别并没有完全解决幻读问题

InnoDB 引擎默认的隔离级别是可重复读，但是在很大程度上避免了幻读现象，主要是通过两种解决方案：

- 快照读（普通 select 语句）：通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，Read View 是在事务开始时创建，整个事务运行期间都使用同一个，所以就算有事务插入或者删除了记录，当前事务也感知不到
- 当前读（select ··· for update 等语句）：通过 next-key lock（记录锁 + 间隙锁）方式解决幻读。因为在执行 select···for update 语句时，会加上 next-key lock ，其他事务在锁范围内插入删除数据就会被阻塞，无法成功，会生成一个插入意向锁。

但是这两种并不能完全解决幻读问题，具体看  [MySQL 可重复读隔离级别，完全解决幻读了吗？](https://xiaolincoding.com/mysql/transaction/phantom.html#第一个发生幻读现象的场景)



### 9、MySQL 锁

根据加锁的范围，MySQL 锁可以分为 全局锁、表级锁、行级锁

#### MySQL有哪些锁

##### 全局

1. 全局锁的开启： flush tables with read lock	             释放全局锁：unlock tables
2. 全局锁一旦开启，整个数据库就处于只读状态了，此时再执行各种 DDL（drop、alter），DML（insert、delete、update）等就会被阻塞。
3. 全局锁的应用场景：用于全库逻辑备份，这样在备份过程中，不会因为数据或者表结构的更新而导致备份与预期不一致
4. 全局锁的缺点：加锁时，整个数据库处于只读状态，如果有很多数据，备份时间会很长，这样可能会严重影响业务
5. MySQL 默认支持的 InnoDB 引擎，支持可重复读隔离级别，在备份数据前，开启事务，会创建一个 Read View，由于整个事务执行期间，都只会使用这同一个 Read View，所以就算其他事务做了修改，对当前事务也没有影响。而且由于 MVCC 的支持，备份期间仍然可以对数据进行更新操作。

- **InnoDB 可以使用这种方式来进行备份操作，因为它的隔离级别是可重复读，支持 MVCC**
- **但是 MyISAM 不支持事务，就只能使用全局锁。**



##### 表级锁

表级锁有以下几种：表锁、元数据锁、意向锁、AUTO-INC锁



###### （1）表锁

表锁有 共享锁（读锁）、独占锁（写锁）

**表锁除了会限制别的线程以外，也会限制本线程接下来的操作**

尽量避免在使用 InnoDB 引擎时使用表锁，因为表锁的颗粒度太大，而 InnoDB 支持行锁



###### （2）元数据锁（MDL）

MDL 不需要显式的使用，在对数据库进行操作时，会自动给这个表加上 MDL

- 对一张表进行 CRUD 时，加的是 MDL 读锁
- 对一张表结构进行改变时，加的是 MDL 写锁

**MDL 是为了保证当用户执行 CRUD 时，防止其他线程修改表的结构**

MDL 读锁和 MDL 写锁冲突

 MDL 在事务结束时才会释放，应该尽量避免长事务



***如果有线程进行 CRUD，加了 MDL 读锁，其他线程执行 CRUD 不受影响。但是当此时有其他线程修改表结构，申请MDL 写锁失败时，后续执行任何操作都会被阻塞。原因在于，不论是 MDL 读锁还是写锁，申请时都会形成一个队列，而申请写锁的优先级更高，尽管后续申请的读锁与此时加的读锁不冲突。但是仍会阻塞。***



###### （3）意向锁

- 在使用 InnoDB 的表里对某些记录加上**共享锁（行级）**之前，需要在表级先加上一个**意向共享锁**
- 对某些记录加上**独占锁（行级）**之前，需要在表级先加上一个**意向独占锁**

但是，一般的 select 都是利用 MVCC 实现一致性读，是无锁的。

所以意向锁主要针对 update、insert、update 操作。但是也可以手动对 select 操作加上意向锁

**意向锁是表级锁，而共享锁和独占锁是行级锁，因此不会产生冲突。*意向锁之间也不会产生冲突*， 意向锁只会和共享表锁、独占表锁差生冲突**



**意向锁存在的目的是为了快速判断表中是否有记录被加锁。如果没有意向锁，在对一张表加独占表锁（表级）之前，需要遍历所有的记录，看有没有记录加了独占锁（行级）。而有了意向锁之后，在记录加独占锁之前，先加了意向独占锁，后续线程只需要看有没有意向锁就可以。极大提升了效率。**



###### （4）AUTO-INC锁

表的主键一般都设置为 AUTO_INCREMENT，之后在插入数据时可以不指定主键值，数据库会自动给其赋递增的值，这就是通过 AUTO-INC 锁实现的。

**AUTO-INC锁是特殊的表锁机制**，锁不是在事务结束时才释放，而是执行完插入操作就立即释放。

当一个事务持有 AUTO-INC 锁时，其他事务的插入操作会被阻塞，当有大量插入操作时，会严重影响性能。



因此，后来 InnoDB 提供了一种更轻量级的锁来实现自增，**在插入数据时，在自增字段加上轻量级锁，一旦字段自增值赋值完成就立即释放，而不用等到插入操作完成后再释放。**

**当使用轻量级锁时，并且 binlog_format = row 时，既能提升并发性，又不会出现数据一致性问题**。



##### 行级锁

InnoDB 支持行级锁，而 MyISAM 不支持

普通 select 语句使用快照读，所以不会加锁，如果要手动加锁则使用：

```sql
select ··· lock in share mode              //共享锁
select ··· for update                      //独占锁
```

行级锁有四种：

- Record Lock：记录锁，锁住某一条记录
- Gap Lock：间隙锁，锁定一个范围，左右边界都不包含，也就是说不锁住记录
- Next-Key Lock：Record Lock + Gap Lock 的组合，锁住范围的同时锁住右边界的记录
- 插入意向锁（先不管）：一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，将其状态置为等待状态，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

注意几点：

- 间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥，**因为间隙锁的目的就是为了防止插入记录而造成幻读**
- **next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。因为要考虑 next-key lock 中记录也加锁
- 插入意向锁并不是真正的意向锁，**意向锁是表级锁，而插入意向锁是行级锁**。同时，事务生成的插入意向锁状态为等待状态，意味着事务并未真正获得这个锁，只是创建了。
- 两个事务不能在同一时间内，一个拥有间隙锁，一个拥有这个间隙范围内的插入共享锁



#### MySQL是如何加锁的

**MySQL 加锁的对象是索引，加锁的基本单位是 next-key lock**

不过在不同情况下，next-key lock 可能会退化为 record lock 或者 gap lock

详见[MySQL 是怎么加锁的？](https://xiaolincoding.com/mysql/lock/how_to_lock.html#mysql-是怎么加行级锁的)



#### update没加索引会锁全表？

**如果没加索引，或者索引失效，而导致了全表扫描，此时，会给所有记录加上 next-key lock，看起来就像是给全表加了锁，但实际上并不是表级锁。**

如何避免？

- 可以将 MySQL 里的 `sql_safe_updates` 参数设置为 1，开启安全更新模式。
- 如果 where 里的字段是索引，但是优化器选择了全表扫描，此时就可以使用 force index（[ index_name ]） 告诉优化器强制使用某个索引



#### 避免死锁	

死锁的四个条件：资源互斥、持有且等待、不可剥夺、循环等待

破坏其中任何一个条件死锁就不会成立

一般使用的手段是：

- 设置事务等待锁的超时时间：事务等待锁超过一定时间后，就进行回滚，手中的锁就释放掉了。在 InnoDB 中，默认是50秒
- 开启主动死锁检测：主动死锁检测在发现死锁发生时，手动回滚死锁链条中的某一个事务，让其他事务执行



### 

# Spring

## 一、什么是Spring？Spring的作用是什么？

​		（1）Spring是一个轻量级的开源框架（轻量：jar包少），是为解决企业应用开发的复杂性而提出的。一般说的Spring框架都是指 Spring Framework，是多模块的集合。框架就是将一些基础的东西封装起来，开箱即用，同时提供了拓展性，可以很好的集成其他组件框架。

​		比如说 Spring 支持 IOC（Inversion Of Control ，控制反转）和 AOP（Aspect-Oriented Programming，面向切面编程）、可以很方便的对数据库进行访问、可以很方便集成第三方组件（邮件、任务、调度等）、对单元测试友好、支持RESTful Java 应用程序的开发。

​		Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。

​		（2）Core Container 是 Spring的核心模块，也就是基础模块，主要提供 IOC 依赖注入等功能的支持。Spring的其他所有基本都依赖于核心模块。Core Container 中有四个：

- spring-core：Spring 框架基本的核心工具类

  <img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230714102519947.png" alt="image-20230714102519947" style="zoom: 67%;" />

- spring-beans：提供对有关 bean 创建、配置和管理等功能的支持

  <img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230714102832977.png" alt="image-20230714102832977" style="zoom:50%;" />

- spirng-context：提供国际化、事件传播、资源加载等功能的支持

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230714102945652.png" alt="image-20230714102945652" style="zoom: 67%;" />

- spring-expression：提供对 表达式语言 Spring Expression Language（SpEL）的支持，只依赖于 spring-core 模块，可以直接使用

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/image-20230714103606917.png" alt="image-20230714103606917" style="zoom: 67%;" />

​		

​		

## 二、Spring IOC

### 1、什么是IOC

IOC 是一种设计思想（并非 Spring 独有），而不是一个具体的技术实现。该思想就是将原本在程序中手动创建对象的控制权，交由类似 Spring 这样的框架来管理。这样，程序员无需再考虑什么时候应该创建对象，应该如何创建对象，需要的时候直接从 IOC 容器中拿就行。   IOC 容器实际上是一个 map，value就是各种对象，key就是该对象的唯一标识。

**为什么叫控制反转？**

- 控制：指的是对象操作（实例化、初始化、管理、销毁等）的权利
- 反转：将这个权力交给外部环境（Spring 框架等）

在实际开发过程中，对象之间的依赖关系十分复杂，如果完全由程序员把控，则十分消耗时间精力。将对象之间的依赖关系交由 IOC 容器来管理，并且由 IOC 容器完成对象的注入，可以极大程度上简化开发。IOC 容器就像一个对象工厂，我们只需要配置好配置文件或者注解，完全不用考虑对象是什么时候创建的是怎样创建的，IOC 容器会帮我们完成这一切，在需要使用对象的时候，容器也会帮我们注入好。



### 2、什么是 Spring Bean

简单来说，就是那些交给 IOC 容器进行管理的对象。 我们需要告诉 IOC 容器帮我们管理哪些对象，通过配置元数据来定义，可以是 XML、注解或者配置类。



### 3、@Component 和 @Bean 的区别

- @Component 注解作用于类，@Bean 注解作用于方法
- @Component 注解是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中。 （通过 @ComponentScan 注解来指明要扫描的路径），从指定的扫描路径开始扫描，找出标识了@Component注解的类（也就是需要装配到容器中的）。         @Bean 注解作用于方法，一般是在配置类的方法上使用，表明该方法的返回值对象需要交给容器管理。该方法 Spring 只会调用一次。
- @Bean注解比 @Component 注解的自定义性更强，很多地方都只能只用 @Bean 。 比如 @Component 注解只能在自己编写的类上进行使用，对第三方库的类就没法使用，而 @Bean 可以。

### 4、注入Bean的注解

@Autowired

- 是 Spring 内置的注解，默认注入为 byType（根据类型），但是当容器中有多个同类型的 Bean 时（一个接口多个实现类，注入时写的是接口），就会转为 byName。如果 byName 还是没找到，报错。
- 可以和 @Qualifier 注解搭配使用，@Qualifier 注解有一个 value 属性，当 @Autowired 根据 type 找到多个 Bean 时，再根据 @Qualifier 的 value 进行 byName 查找。  （**推荐使用**）

@Resource

- @Resource 是 JDK 提供的注解，默认注入方式为 byName，如果根据 byName 匹配不到相关的 Bean，则转为 byType
- @Resource 有两个属性 name 和 type，如果仅指定了 name，则根据名字来找。 如果仅指定了 type，则根据类型来找。

### 5、Bean 的作用域

常见的作用域有 singleton、prototype

- singleton：IOC 容器在创建的时候就会同时会创建一个该 bean 实例（如果 lazy-init = true 则代表懒加载，在使用时才会创建 bean），并且只会创建这一个（单例），当后续使用时，拿到的都是同一个bean。默认情况不特殊指定都是 singleton
- prototype：每次从 IOC 容器中获取时，都会返回一个新的 bean 实例，每次拿到的都是不同的。
- request：每次 HTTP 请求都会新建一个 bean ，该 bean 只在本次 HTTP 请求中有效。该作用域仅适用于使用 web 的 Spring WebApplicationContext环境
- session：同一个 Http Session 共享同一个 bean，该 bean 只在本次 session 会话期间有限。该作用域仅适用于使用 web 的 Spring WebApplicationContext环境
- application：每个 web 应用在启动时创建一个 bean，在应用结束之前一直有效。该作用域仅适用于使用 web 的 Spring WebApplicationContext环境

**<u>controller方法中的 HttpSession、HttpRequest 参数注入，应该就是 session 和 request 作用域</u>**（不确定）



### 6、Bean 是否线程安全

Bean 是否线程安全取决于**作用域**和**状态**，对于 prototype 作用域的 bean 来说，每次获取的都是新的 bean，就不存在资源竞争，因此是线程安全的。

而对于 singleton 作用域的 bean 来说，如果它是无状态的（即不包含可变的成员变量），则是线程安全的（比如Service）。如果是有状态的则线程不安全。

对于 singleton 作用域、有状态的 bean，解决其线程安全问题一般有两种办法：1、尽量避免在 bean 中有可变的成员变量    2、在类中定义一个 `ThreadLocal` 成员变量，使用 ThreadLocal 保存可变的成员变量（推荐）

**<u>*controller 是单例*</u>**，所以是线程不安全的。尽量避免在 controller 中使用可变的成员变量。单例 controller 可以支持多线程并发访问，单例与多线程并无关系。



### 7、Bean 的生命周期

- 实例化
- 属性赋值
- 如果实现了*Aware接口，调用相应方法
- 如果有的话，调用 BeanPostProcessor 对象的 postProcessBeforeInitialization() 方法
- 如果实现了 Init ializingBean 接口，则执行 afterPropertiesSet() 方法
- 如果 Bean 配置了 init-method，则调用自定义的初始化方法 init-method
- 调用 BeanPostProcessor 对象的 postProcessAfterInitialization() 方法
- 使用 Bean
- 销毁 Bean 时，如果实现了 DisposableBean 接口，则执行 destroy() 方法
- 销毁 Bean 时，如果配置了 destroy-method，则执行指定方法

![Spring Bean 生命周期](%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/b5d264565657a5395c2781081a7483e1.jpg)

## 三、Spring  AOP

### 1、对AOP的理解

AOP（Aspect-Oriented Programming）面向切面编程，能够将那些与业务无关的，但是业务模块共同调用的逻辑或责任（例如 事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块之间的耦合度，同时十分重要的是，有利于拓展和维护。



Spring AOP 对于要代理的对象，如果该对象实现了某个接口，则使用JDK动态代理；如果该对象没有实现接口，则使用Cglib代理（代理对象继承被代理对象）



### 2、Spring AOP 和 AspectJ 的区别

- Spring AOP 属于运行时增强，通过创建代理类实现功能织入；而 AspectJ 是编译时增强，基于字节码操作，在运行前进行织入（分为编译时织入、编译后织入、加载时织入），需要 AspectJ 编译器 ajc 的支持。   编译时增强效率更高。
- 因为织入方式的不同，两者支持的 Jointpoint 也是不同的。像 final 方法、静态方法这些，是不能通过代理实现织入的，而 AspectJ 支持，因为它是在运行前进行织入，操作的是字节码。



### 3、AspectJ 定义的通知类型

- Before（前置通知）：目标对象的目标方法调用前触发
- After（后置通知）：目标对象的目标方法调用之后触发
- AfterReturning（返回通知）：目标对象的目标方法正确返回之后触发
- AfterThrowing（异常通知）：目标对象的目标方法抛出 / 触发异常之后触发（与AfterReturning互斥）
- Around（环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法

### 4、多个切面的执行顺序

通过 @Order 注解配置，值越小优先级越高



## 四、Spring MVC

### 1、对 Spring MVC的理解

MVC 是一种设计模式，将业务逻辑、数据、显示分离来组织代码，可以帮助进行更简洁的 Web 层的开发，天生与 Spring 框架集成。

### 2、Spring MVC 的工作原理（流程）

先明确 SpringMVC 的重要的组件

- DispatcherServlet 前端控制器：核心的中心处理器，负责接受请求、转发请求、响应结果。相当于转发器，核心组件，减少其他组件的耦合度
- HandlerMapping 处理器映射器：根据 uri 去查找能处理本次请求的 handler，并将请求涉及到的拦截器和 handler 一起封装
- HandlerAdapter 处理器适配器：根据 HandlerMapping 映射到的 handler，适配执行对应的 handler。handler 会返回一个 ModelAndView 对象
- Handler : 程序员自己编写的请求处理器，实际处理请求
- ViewResolver 视图解析器：根据 Handler 返回的逻辑视图/视图进行解析，解析并渲染得到真正的视图，并传递给 DispatcherServlet 用于响应返回。

**执行流程：**

- 客户端发送请求，DispatcherServlet 拦截请求
- DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 uri 去匹配查找能够真正处理请求的 Handler（即 Controller 控制器），并将请求涉及到的拦截器 和 Handler 一块封装，返回给 DispatcherServlet
- DispatcherServlet 调用 HandlerAdapter 适配器执行 Handler
- Handler 完成对请求的处理后，会返回一个 ModelAndView 对象给 DispatcherServlet， ModelAndView 就是 数据模型和对应视图的信息，View 是逻辑上的视图
- DispatcherServlet 将 ModelAndView 传给 ViewResolver 进行视图解析，ViewResolver 根据逻辑的 View 查找具体的 View，返回实际的 View
- DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）
- DispatcherServlet 将 View 响应给用户

### 3、统一异常处理

使用  @ControllerAdvice 和 @ExceptionHandler 两个注解

```java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    @ExceptionHandler(BaseException.class)
    public ResponseEntity<?> handleAppException(BaseException ex, HttpServletRequest request) {
      //......
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity<ErrorReponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
      //......
    }
}
```

@ControllerAdvice 表明这是一个统一异常处理类     @ExceptionHandler 指明处理的哪种异常

这种异常处理方式是给所有的或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被 @ExceptionHandler 注解修饰的方法进行处理。   匹配相关的处理方法时，选择匹配程度最高的方法



## 五、Spring的三级缓存和循环依赖

好文：[彻底搞懂Spring之三级缓存解决循环依赖问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/610322151)

[Spring为什么需要使用三级缓存？_singletonfactories_蜡笔没了小新git的博客-CSDN博客](https://blog.csdn.net/ljcgit/article/details/115727194)

### 1、三级缓存

- 一级缓存（ConcurrentHashMap）：singletonObjects，存放完整的 bean 实例，也就是已经实例化和初始化好的实例
- 二级缓存（HashMap）：earlySingletonObjects，如果没有AOP代理，存放的是属性未填充的半成品 bean 实例；如果有AOP代理，则存放的是代理的 bean 实例 beanProxy，原来的 bean 还是半成品
- 三级缓存（HashMap）：singletonFactories，存放的是 bean 封装后的 ObjectFactory，有一个 getEarlyBeanReference() 方法，如果 bean 被代理，返回的是代理对象，否则返回原 bean 实例

缓存其实就是一个 map

![img](%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/v2-d78848d4c07fd077da0c896087e90885_1440w.webp)



### 2、三级缓存的设计是为了解决循环依赖

循环依赖的解决：

1. 对象A要创建到Spring[容器](https://link.zhihu.com/?target=https%3A//cloud.tencent.com/product/tke%3Ffrom%3D10680)中，从一级缓存singletonObject获取A，不存在，开始实例化A，最终在三级缓存singletonObjectFactory添加(A，A的函数式接口创建方法)，这时候A有了自己的内存地址
2. 设置属性B，B也从一级缓存singletonObject获取B，不存在，开始实例化B，最终在三级缓存singletonObjectFactory添加(B，B的函数式接口创建方法)，这时候B有了自己的内存地址
3. B中开始给属性A赋值，此时会找到三级缓存中的A，并将A放入二级缓存中。删除三级缓存
4. B初始化完成，从三级缓存singletonObjectFactory直接put到一级缓存singletonObject，并删除二级和三级缓存的自己
5. A成功得到B，A完成初始化动作，从二级缓存中移入一级缓存，并删除二级和三级缓存的自己
6. 最终A和B都进入一级缓存中待用户使用

<img src="%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0.assets/v2-91760e98daa2e93b0d63e123657e5bb7_1440w.webp" alt="img" style="zoom: 67%;" />

### 3、为什么不能去掉三级缓存

因为 AOP 的缘故，懒得看了，后续有需求再看[彻底搞懂Spring之三级缓存解决循环依赖问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/610322151)

[Spring为什么需要使用三级缓存？_singletonfactories_蜡笔没了小新git的博客-CSDN博客](https://blog.csdn.net/ljcgit/article/details/115727194)
