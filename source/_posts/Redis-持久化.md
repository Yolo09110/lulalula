---
title: Redis-持久化
date: 2023-12-09 11:36:49
category: Redis
---

## 一、持久化介绍

### 1、什么是持久化

Redis 是内存 K-V 数据库，数据是在内存中的，如果系统宕机或者关机，数据就丢失了；为了使开机后数据还在，就需要将数据保存到可永久保存的存储介质中，这就是持久化

### 2、持久化方式

Redis 有两种持久化方式，一种是 RDB（Redis DataBase），一种是AOF（Append Only File）；Redis 默认开启的是 RDB，而AOF 需要手动开启；

- RDB 是全量的二进制格式数据快照，记录某个时刻的全部数据，后续通过加载 RDB 文件恢复数据；
- AOF中记录的是修改数据的命令，并且是以追加方式进行的，本质就是记录操作日志；后续通过加载 AOF 文件重放命令来恢复数据

因此，RDB 的持久化文件 .rdb 是人不可读的，而 AOF 的持久化文件是人可读的

RDB和AOF的区别：

- 恢复速度方面：RDB 是数据快照，可以直接恢复；AOF 是执行日志，需要重放操作进行恢复；因此 RDB 要快很多
- 体积方面：RDB 存放的是二进制紧凑型的数据；AOF 存放的是每条修改指令；相同数据量下，RDB 文件所占用空间更小
- 数据完整性：AOF 是记录每一条修改命令，RDB 每隔一段时间记录一次，AOF 恢复数据通常会更完整

### 3、选用什么？

对于用于缓存并且不是海量访问的情况，可以不使用缓存

RDB 默认开启，AOF 选择性开启；

因为 RDB 是全量快照，所以需要隔一段时间进行，不然消耗CPU资源太多；而 AOF 是增量型的，每次操作都会记录，并且根据设置选择刷盘的频率时间；

所以，对于丢失数据不可忍的场景，应该使用 AOF；其他场景可以使用 RDB

AOF 不建议单独开启，如果要开启 AOF，建议和 RDB 一同开启；一同开启后，恢复时，只会加载 AOF 文件，如果存在则进行恢复。如果不存在，不会使用 RDB 文件，而是创建一个空库；

这样的原因是：

如果用户开启了 AOF，说明对数据丢失的容忍性很小，对数据的完整度要求很高；

RDB 全量快照可能在几分钟前，那么就会丢失掉最近几分钟的数据，系统默认这样是不行的；

但是，RDB 文件还是在的，如果数据确定丢失了找不回来，那么可以通过 RDB 恢复，代价是丢失几分钟的数据

为什么 RDB 是几分钟做一次持久化？

RDB 因为保存的是全量的二进制数据快照，尽管可以通过主进程 fork 一个子进程在后台进行 RDB 操作，但是如果一分钟做一次，消耗的资源还是会比较多；有可能上一次 RDB 还没做完，下一秒又 fork 一个子进程做；主进程 fork 子线程也会消耗资源，造成阻塞；



## 二、RDB 详解

### 1、怎样开启 RDB 持久化

Redis 是默认开启 RDB 的

配置文件中可以设置 RDB 的阈值，比如说几分钟内有几条写操作就触发 RDB 持久化

Redis 的默认设置是：

```Java
save 900 1
save 300 10
save 60 10000
```

意思就是如果900s内有1次写操作，就触发，这三条是或的关系

### 2、RDB 文件存放在哪

Redis 配置文件中有指定

```Java
#指定 rdb 文件名称
dbfilename dump.rdb

#指定存放位置
dir ******
```

最终生成的RDB文件是一堆乱码，因为是二进制格式；但是最开头会有 REDIS 这个字符串标识

![img](http://yolo-img.oss-cn-beijing.aliyuncs.com/img/asynccode)

### 3、什么时候持久化

- 当超过了配置文件设定的阈值时，bgsave，非阻塞式持久化    （周期函数会定期检查是否到达了阈值，默认是 100ms 检查一次）
- 当主动执行 save、bgsave 命令时；save 是阻塞式持久化；bgsave 是非阻塞式
- 当关闭redis 时，会进行阻塞式持久化

### 4、RDB 如何进行持久化

- 主进程 fork 出一个子进程，进行非阻塞式持久化
- 子进程创建一个临时 rdb 文件，保存全量的二进制数据快照
- 使用临时 rdb 文件替换掉旧的 rdb 文件

fork 命令创建子进程时，会将父进程的页表复制给子进程，也就是新建PCB 之后，将父进程的 PCB中的信息复制给子进程的PCB；

父进程子进程页表一样，共享同一片内存空间

这里还有个点，如果子进程在持久化过程中，父进程发生了写操作，那么就会引起写时复制；

写时复制（Copy-On-Write，简称COW ）：

父进程在创建子进程时，为了提高创建速度以及节省不必要的内存开销，不会给子进程分配物理空间，而是将父进程的页表复制给子进程，父子进程使用同一块物理空间；此时的内核会将父进程的所有内存页设置为 read-only，如果后续父子进程有了写操作，就会触发页异常中断；内核此时就会将触发异常的页复制一份，于是父子进程各自持有独立的一份；

https://blog.csdn.net/qq_32131499/article/details/94561780

Redis 中，此时子进程指向的还是旧的物理空间，所以此时的写操作的数据并不会保存在本次 RDB持久化中；



## 三、AOF 详解

### 1、怎样开启 AOF

配置文件中 

```Java
appendonly no
appendfilename "appendonly.aof"
```

设置 appendonly 为 yes 就开启了 AOF，可以看出，Redis 是默认关闭 AOF 的；

开了 AOF 后，每条修改数据的命令都会记录下来；恢复时，通过重放命令进行恢复，这个操作耗时一些；

Redis 设置key 过期的指令执行时，过期时间会转化为过期时的时间戳，因此，对于这类命令重放时，已经过期的就不存储，还没过期的就存储过期时的时间戳

### 2、AOF 写入流程

AOF 的写入流程为：

1. 当执行一条修改命令时，执行成功后将其写入到 AOF 缓冲区
2. 根据指定的刷盘策略，将缓冲区数据刷入到磁盘

这里，刷盘策略有三种：

1. Appendfsync always: 每执行一次命令，立马刷盘
2. Appendfsync everysec: 每秒刷一次盘
3. Appendfsync no：不主动刷盘，让操作系统刷，Linux 一般是 30 s

![img](http://yolo-img.oss-cn-beijing.aliyuncs.com/img/asynccode)

Redis 推荐的刷盘策略是 everysec，每1s刷一次盘，性能也不会影响太多，丢失最多1s 的数据；

如果非常追求性能，并且可以容忍丢失很长时间的数据，那么也可以选择 no

Always 一般不会用，Redis 的定位也不是完全可靠

Always 策略是同步刷盘，会阻塞主线程

Everysec 是后台线程异步刷盘

### 3、AOF 写入细节

写入其实分了好几步：

（1）写入 AOF 缓冲区

这个缓冲区其实是一个 sds，名字叫 aof_buf

（2）从 AOF 缓冲区刷入到到磁盘缓存，也就是 pagecache（操作系统缓冲区）

会有四个时机做这个，先不了解

（3）从磁盘缓存刷入到磁盘中

这一步就跟设置的刷盘策略紧密相关；调用系统的 flush 函数

![img](http://yolo-img.oss-cn-beijing.aliyuncs.com/img/asynccode)

### 4、AOF重写

AOF文件是不断写入的，这就导致一个问题：AOF 文件会不断膨胀；

针对这个问题，Redis 采用了重写的办法：

具体来说，就是当 AOF 文件大于 64M ，并且相比于上次已经增长了 100%时，自动 fork 一个子进程，进行 AOF 重写；子进程根据Redis中所有的数据，生成相应的命令，（比如说看到了 a 1，就会生成 set a 1），然后放入临时 AOF 文件中；

同时，如果此时主进程还执行了写操作，则会将命令写入到 AOF缓冲区 和 AOF 重写缓冲区；等子进程重写完毕后，就将 AOF 重写缓冲区中的数据追加到新的AOF文件中，然后用新的 AOF 文件替换掉旧的。

> 重写的原理，比如执行了 set a 1，然后后来又执行了 set a 2，那么前一条已经没有意义了

![img](http://yolo-img.oss-cn-beijing.aliyuncs.com/img/asynccode)

> 这个图左侧的红页稍微有点问题，没有 set b 3

1、为什么不直接复用原来的 AOF 文件？

因为如果重写操作失败，原来的AOF文件重写了一半就用不了了

2、为什么写操作后要分别写入 AOF 缓冲区 和 AOF 重写缓冲区呢？

如果没有 AOF 重写缓冲区，那么当重写过程中主进程执行了写操作修改了数据，而此时子进程是不知道的，最后生成的新的AOF文件就与内存数据不一致



## 四、AOF优化-混合持久化

### 1、什么是混合持久化

混合持久化是指，在 AOF 重写时，将当前数据库状态通过 rdb 二进制快照保存下来，然后将重写期间的写操作命令以 AOF 文件的格式追加到 rdb 二进制后面

![img](http://yolo-img.oss-cn-beijing.aliyuncs.com/img/asynccode)

### 2、为什么要混合持久化

混合持久化是结合了 RDB 和 AOF 的优点；混合持久化之后，前半段是 RDB 二进制文件，恢复数据的速度很快，后半部分是持久化期间的操作命令，使得数据更少的丢失。

混合持久化大大降低了 AOF 重写期间的性能消耗，以及减少了 AOF 文件的空间占用（因为RDB文件是紧凑型的二进制数据文件）；但是代价是丧失了人的可读性

开启混合持久化需要在配置文件中开启 aof-use-rdb-preamble；  目前使用的版本是默认开启的，也就说，只要你开启了 AOF，就默认开启了混合持久化

### 3、混合持久化文件恢复

混合持久化文件还是 AOF 文件，只不过前半部分是 二进制数据，是乱码；

最开始会有 REDIS 几个字符，就标志着这是个混合持久化的AOF文件；



## 五、AOF优化-MP方案

MP：Multi Part AOF

### 1、AOF重写的缺陷

- 占用主进程CPU时间：AOF重写时，如果有写操作，需要主进程分别向 AOF 缓冲区和 AOF 重写缓冲区写入新的写操作命令；以及子进程重写结束后，将 AOF 重写缓冲区的内容写入到新的 AOF 文件
- 占用额外内存：这两份数据是一样的，造成了内存的额外占用（AOF 重写缓冲区）；
- 额外磁盘开销：重写完成后，主进程不仅需要将 AOF 缓冲区的内容写到旧的 AOF 文件中，还需要将 AOF 重写缓冲区的内容写到新的 AOF 文件中；多了一次磁盘消耗，而这两份数据是一样的；

### 2、改进

针对这些问题，Redis 7.0提出了改进，采用了 MP方案，Multi Part AOF，也就是使用两个 AOF 文件；

具体描述：

采用两个 AOF 文件，base aof 和 incr aof；这两个文件组合起来，就是完整的操作

base aof 用于重写时，将数据库的数据转化为操作记录下来；incr aof 用于将重写过程中的写操作指令记录下来，即将AOF缓冲区中的内存写入进去；当重写完成后，更新 .manifeat 文件，记录新的这两个 base aof 和 incr aof 文件；将旧的base aof 和 incr aof 记录为 history；  后续通过后台线程异步进行删除

这样改造的话，就不需要再有一个 AOF 重写缓冲区；也不需要主进程再多次将 AOF 重写缓冲区内容写入新的 AOF 文件；

