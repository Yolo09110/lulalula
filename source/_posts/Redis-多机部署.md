---
title: Redis-多机部署
date: 2023-12-09 11:39:26
category: Redis
---

## 一、主从模式

为了避免机器挂掉或者出现故障就停止服务，或者是磁盘损坏丢失数据，Redis 提供了主从模式

一个主机负责读写，一个或多个从机负责读；主机挂掉之后，从机依然可以提供服务，可以由人工或者设置脚本，将其中一台从机设置为主机；

使用 slaveof/replicaof 命令成为从机

主从之间要保证数据的一致性，主机的写操作要同步到从机

### 1、第一次同步

当使用 slaveof / replicaof 命令成为从机后，就要进行第一次同步，第一次同步分为三部分：

- 建立链接，协商同步
  - 从机向主机发送 psync 命令，表示自己要进行数据同步；（有两个参数，runID 是每个 Redis 服务器在启动时产生的随机 id，此时从机并不知道主机的 runID，所以为 ？；  另一个参数为 offset，表示复制的进度，第一次为 -1）
  - 主机收到后，向从机发送 fullresync 命令，表示是全量复制。（该命令也有两个参数，runID 和 offset，runID 为自己的 runID， offset 为主服务器目前的复制进度）
  - 从机收到后保存主机的信息
- 主机同步数据给从机
  - 主机发送完命令后，执行 bgsave 生成 RDB 文件，然后将 RDB 文件发送给从机
  - 从机收到后，清空自己的数据，然后载入 RDB 文件
  - 主机在执行 bgsave 命令、将 RDB 发送给从机 以及 从机载入 RDB 文件这段时间的写操作，并没有同步到从机；主机会将这段时间的写操作 写入到 repication buffer 缓冲区中
- 主机发送新的写操作到从机
  - 当从机完成载入 RDB 操作后，发送命令给主机，告诉主机完成了
  - 主机收到后，将 replication buffer 中的操作发送给从机，从机收到后执行，然后就完成了第一次同步的整个过程

### 2、后续的同步

 主从之间会维持一个 TCP 连接，长连接；后续主机的写操作就同步这个连接传播给从机，从及执行命令完成同步

 这个过程被称为 基于长连接的命令传播；

### 3、增量复制

主从节点在第一次同步之后，就会通过 TCP 长连接进行命令传播；

但是，后续从节点可能出现掉线、重启等故障，此时主机的写操作就没有同步到从机；

等从机恢复后，主机的写操作如何同步到从机呢？    采用增量复制的方式

- 连接恢复后，从机会发送 psync 命令给主机，offset 是从机目前的复制进度
- 主服务器收到命令后，然后发送 continue 命令告诉从机将以增量复制的方式同步数据
- 然后主机将从机断联这段时间的写操作发送给从机进行同步

主服务器如何知道从什么位置进行增量数据同步呢？

主服务器有一个 repl_backlog_buffer，主服务器在进行写操作后，不仅通过命令传播将其发送给从机，还会写到这个缓冲区中；这个缓冲区是一个环形的缓冲区，大小默认为 1M，如果写满了就会不停的覆盖之前的数据；

主机通过从机发过来的 offset，与自己的 offset 进行对比，确定从机断联这段时间缺失的数据，然后去 repl_backlog_buffer 中找，如果找到了，则复制到 replication_buffer 中，然后传播给从机；

如果在 repl_backlog_buffer 中没有找到，则重新采用全量复制的方式

***** repl_backlog_buffer 一个主节点只会有一个，replication_buffer 是主节点为每一个从节点设置一个；

全量复制的开销很大，所以尽量保证 repl_backlog_buffer 中有缺失的操作，最简单的办法就是调整它的大小；一般调整的大小是：从机恢复所需时间的平均值 * 平均每秒产生的写命令的数据大小

更可靠的话可以调整为这个 2 倍

https://xiaolincoding.com/redis/cluster/master_slave_replication.html#%E9%9D%A2%E8%AF%95%E9%A2%98

## 二、哨兵模式

主从模式中，如果主服务器挂掉了，从服务器无法自动转为主服务器，要么就靠人工进行调换，要么就写一个脚本程序进行监控，这显然是不好的；

Redis 提供了哨兵模式来解决这一问题，Redis 哨兵可以监视主节点和从节点，如果主节点发生故障，哨兵可以选择合适的从节点转变为主节点，同时通知应用层以及其他从节点，主节点变了。

哨兵（sentinel）服务本质上还是 Redis 进程，执行特殊任务的 Redis 进程；

哨兵主要责任是：监控、选主、通知

### 1、监控

哨兵负责监控所有的主节点和从节点m

哨兵每隔一秒给所有的节点发送 PING 命令，如果节点在特定时间回应，则代表正常，不回应哨兵则将其标记为 *主观下线；*

因为可能是由于网络拥塞等原因导致节点并没有响应，避免误判因此只是标记为主观下线； 所以，一般情况下，哨兵都是有多个组成哨兵集群（最少3台部署集群），通过多个哨兵进行监控，多个哨兵同时网络故障的可能性很小；

当某个哨兵发现节点无响应时，将其标记为主观下线，然后向其它哨兵发送命令，投票表示赞成还是反对，当有 quorum （配置项）个赞成时，将节点标记为客观下线；

如果是主节点，哨兵就要进行选主

### 2、选主

选主就是从所有从节点中选择合适的设置为新的主节点；  多个哨兵谁负责选主呢？？

此时就需要在所有哨兵中选举出一个 leader ，由他来负责选主

选举 leader 的过程：

- 首先发现节点无响应，将其标记为客观节点的哨兵，作为候选者
- 候选者向其他哨兵发送命令，表明自己想成为 leader，让其他哨兵投票
- 其他哨兵投赞成或者反对票，每个哨兵只有一次投票机会，投完就不能投了；只有候选者可以把票投给自己，其他人都不可以
- 当赞成票超过一半，并且大于等于 quorum 参数时，候选者成功成为 leader

这个也就是为什么集群最少是 3 个的原因：

当有两个哨兵同时发现节点客观下线，都会成为候选者，并且都投票给了自己，那么此时，两个候选者都成为不了 leader，无法进行主从切换

quorum 的大小一般为 哨兵节点个数 / 2 + 1

哨兵节点个数一般为奇数

当leader 选举出来后，有它负责选主；

选主的过程：

- 在从节点中选择一个作为新的主节点
  - 首先将网络不好的节点剔除
  - 然后根据优先级选择优先级最高的
  - 如果有多个优先级一样大的，在其中选择复制进度最大的（也就是offset 最接近主节点 offset 的从节点）
  - 如果还有进度一样的，选择 id 最小的（每个 Redis 实例创建时都会有一个随机的 id）
- 向选择好的从节点发送 slaveof no one 命令，将其设置为主节点
- 向其他所有的节点发送 slaveof 命令，将其他从节点的主节点变更
- 向客户端发送消息，说明主节点已经变化
- 持续监控旧的主节点，如果上线，将其设置为从节点

### 3、通知

通知就是上述给从节点、客户端通知主节点变更

## 三、集群模式（cluster）

单个 Redis 的读写能力已经很强了，tps 很高了，但是随着互联网的发展，一些场景比如双11，单机就很难支撑（集群主要是提升读写的能力，主从模式提升的只是读的能力）

所以就出现了集群模式

集群就是多个 Redis 节点，节点之间相互连接，但是存储不同的数据，通过哈希槽进行分片；

客户端会提前缓存哈希槽信息，在执行命令时，先使用 CRC16计算出16bits 的数据，然后对 16384 进行取余，确定到是哪个槽，确定是哪个节点负责的，然后直接请求；一般情况下，是没有问题的；

但是当集群新增或者删除节点，或者为了负载均衡重新分配哈希槽，这时客户端的缓存数据就没有用了，定位到的节点可能不准确，此时的节点会回应 MOVED，参数带上实际的节点ip 和端口，告知客户端这个槽不是自己的，是另一个人的；客户端收到后会进行重定向；

集群中总共有 16384 个槽，每个节点负责一部分；当操作的数据不在自己负责的槽上时，会重定向到负责的节点，然后获得数据；

每个节点会维护一个 clusterState 结构，里面有一个指针数组 slots[16384]，每一个数组元素的值是指向负责该槽的节点的指针；

> slot = CRC16(key) % 16383

集群模式的好处：客户端直接连接服务器，避免了各种 代理 Proxy 的性能损耗
