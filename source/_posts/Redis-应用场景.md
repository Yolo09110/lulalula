---
title: Redis-应用场景
date: 2023-12-09 11:38:09
category: Redis
---

## 一、缓存



### （一）缓存异常

#### 1、缓存雪崩

##### （1）什么是缓存雪崩：

（大量的应用请求因为异常无法在 Redis 缓存中处理，从而直接打到数据库）

缓存雪崩是指，在同一时刻，许多 key 同时到期，导致大量的请求无法使用缓存而直接落在数据库上，最终造成数据库崩溃

##### （2）怎么解决

- 均匀设置过期时间：可以在设置过期时间时采用随机数，防止大量 key 同时过期
- 重建缓存加互斥锁：线程在发现缓存中没有时，进行加锁，其他没有获取锁的线程阻塞或者返回空或错误，由成功获取锁的这一个线程去查询数据库，查到之后将数据添加到缓存。然后解锁； （针对不同的 key 加不同的锁）

#### 2、缓存击穿

缓存击穿是指：缓存中没有数据库中有的数据；    一般指某一热点数据过期，这一瞬间大量针对这一热点数据的请求无法使用缓存，落在数据库上，导致崩溃

解决方法：

- 设置互斥锁：请求这一热点数据的线程在发现缓存中没有时，进行加锁，其他没有获取锁的线程阻塞或者返回空或错误，由成功获取锁的这一个线程去查询数据库，查到之后将数据添加到缓存。然后解锁；      这就避免了大量请求落在数据库上
- 热点数据支持续期：支持热点数据续期，当快要过期时，由后台线程更新数据过期时间

#### 3、缓存穿透

缓存穿透是指：大量请求针对的某一数据既不在缓存中也不在数据库中，请求数据库导致崩溃

（缓存穿透有可能是由于攻击者导致的，比如大量的请求 id 为 -1 的数据）

解决办法：

- 设置默认值：当请求的数据既不在缓存也不在数据库中时，设置 key-value 为 key-null, 设定过期时间，不能太长（因为后续数据库可能添加了这个数据，但是由于缓存一直没过期，导致数据获取不到）

> 有缺点：如果攻击者每次都用不同的且都不存在的 key 来请求数据，那么这种措施毫无效果。并且，因为要回写特殊值，那么这些不存在的 key 都会有特殊值，浪费了 Redis 的内存。这可能会进一步引起另外一个问题，就是 Redis 在内存不足，执行淘汰的时候，把其他有用的数据淘汰掉。

- 布隆过滤器：使用布隆过滤器过滤大量请求，最终只有少部分落在数据库
- 增加校验：在接口层增加校验，比如对非法参数请求进行拦截、对攻击者ip进行拦截

布隆过滤器：布隆过滤器底层是一个 64 位整型，根据 key 使用三个哈希函数生成对应的三个 hash 值，然后对 64 取余，获取三个索引，将对应索引位置更新为1；

后续请求该数据时，先进入布隆过滤器，如果根据请求的参数计算出的哈希值得到的索引位置上不都为 1， 则代表数据不存在，直接返回，不落在数据库上；如果都为1，则代表数据可能存在，接着去查数据库（布隆过滤器可以在查缓存之前查，也可以在查完缓存没有之后查，不同的方案罢了）

为什么可能存在呢？

因为数据量大的时候，发生哈希冲突的概率增大，有可能是其他数据使得那些位置为1，所以是有可能存在

布隆过滤器的优点是：占用空间小、速度快

缺点：还有一部分请求落在数据库上



### （二）缓存一致性问题

什么是缓存一致性问题？

缓存一致性问题是指，请求数据库数据时，缓存中如果不存在会添加到缓存中，后续的请求都会请求缓存；如果数据库中数据发生了改变，缓存如何和数据库保持一致

有三种思路：

- 更新 MySQL，不管 Redis，仅仅使用过期时间兜底
- 更新 MySQL，更新 Redis
- 更新 MySQL，异步将更新同步到 Redis

不能先操作 Redis 再操作数据库，因为 Redis 宕机后，数据可能就丢失了

#### 第一种：过期时间兜底

最简单的处理方法，缺点也很明显，设置时间太短则缓存频繁失效，太长更新不及时，达成一致性延迟高；

当然也有优点：Redis 的原生接口，实现简单； 管理成本低，不容易出问题

#### 第二种：先更新 MySQL，再更新 Redis

更新 Redis 有两种：修改和删除

对于修改，容易造成时序性问题，所以不咋用；基本都用删除

删除也有问题，就是删除操作可能失败；此时就只剩过期时间，退化到了第一种

优点：相比第一种，达成一致性的延迟小；       实现成本小，只是增加了删除缓存的操作

缺点：删除操作可能失败，退化为第一种；       需要删除这一额外操作，消耗资源

#### 第三种：异步更新MySQL的修改到 Redis

通过将搭建的消费服务设定为 MySQL 的 slave，订阅到 mysql 的 binlog，解析日志内容，再更新到 Redis；   适合数据不过期或者过期时间很长的场景，因为 解析 binlog 同步到 Redis 这个操作很重

优点：无时序性问题，可靠性强；        和业务逻辑解耦，不需要程序员关心具体操作

缺点：引入了消息队列这一比较重的组件，需要单独搭建消费服务，维护成本高；

​      如果压力过大，消费服务崩了，则很长一段时间 Redis 都是旧数据



## 二、分布式锁

顾名思义，就是分布式场景下的锁，比如不同机器上的进程去竞争同一个资源，就需要加分布式锁

### 1、分布式锁的特性

- 互斥性：锁是资源的使用权，因此要保证锁只能被特定数量的线程获得
- 安全性：线程获取锁之后如果发生了异常之类的情况不能解锁，需要有处理措施，否则资源会一直加锁，其他线程永远获取不到
- 对称性：解锁只能解自己加的锁，不能解掉别人的锁
- 可靠性：需要有一定的异常处理能力、容灾能力

### 2、如何保证互斥性

使用 set 命令，加上 nx 参数，如果setnx 或者 set key value nx 返回了 1，说明之前没有人加锁，加锁成功，如果返回了0，说明已被加锁，加锁失败；

解锁时，delete 操作就行

### 3、如何保证安全性

某线程加了锁，因为阻塞、异常甚至崩溃等原因不能返回解锁，导致锁一直无法释放，其他线程无法获得资源；

使用过期时间，锁到期就自动释放； 可以使用 expire 命令，但是由于 set 和 expire 不具有原子性，不能这样使用；

但是 Redis 有 ex 参数以及 px 参数， set k1 v1 nx ex 10 就是原子性的

### 4、如何保证对称性

A线程加了锁，结果阻塞了，锁过期自动解锁了；此时B线程获得了锁，在处理业务； A从阻塞中恢复，并不知道锁已经被释放了，继续操作业务，操作完之后释放锁，结果释放的是 B 加的锁

> B此时没有锁了，执行完流程后释放锁操作，进行的是空操作

针对这个问题，就要标明锁是谁的，设置 owner；很简单，在 set 的 value 中标注这是谁的，一般是将线程的 uuid 设置为 value；

释放锁时，先查一下这是不是自己的，如果是，再释放；

但是这还有一个问题！ 如果A线程释放锁时查到了这是自己的，还没有释放；此时锁过期了，B线程立马获取了锁，那么A释放的还是 B 的锁；

这个问题是由于：查锁和删除锁两个连起来不是原子化的；

Redis 引入 lua 脚本刚好解决这一问题，lua 脚本保证其中的操作是原子化的；

![img](http://yolo-img.oss-cn-beijing.aliyuncs.com/img/asynccode)

这下，分布式锁的特性前三个就满足了，互斥性、安全性、对称性

lua 脚本一定就能保证原子性吗？

lua 脚本本身并没有原子性，它是将多个操作放进一个流程中，相当于打包在一起；Redis 本身的核心处理逻辑是单线程的，所以执行一个流程时并不会被打断，因此才保证了这些操作的原子性；

lua 脚本执行时，如果发生了错误，那么，之前的所有操作还是生效的，不会回滚，后续的才不会执行

### 5、如何保证可靠性

保证可靠性，就是节点挂了、网络故障等等异常之后还能提供服务；

这种就采用两种方案，一种是 主从模式，另一种是 多机部署

#### （1）主从模式

一个主 Redis 有多个从 Redis，当主 Redis 挂了之后，从 Redis 中选取一个变为主 Redis 继续提供服务；

那么，如何知道主 Redis 挂了，以及如何将从 Redis 变为 主Redis 呢？可以人为不停的去检查，发现挂掉之后，手动选择一个从Redis 转为 主Redis，并且通知上层应用；这样比较麻烦，可以采用脚本方式，自动去检测以及转换；其实，Redis 提供了成熟的解决方案，就是Redis 哨兵模式

*哨兵模式*

不需要人工参与，由哨兵节点自己决定主节点挂没挂，以及由哪个从节点转为主节点

哨兵模式一般都是多个哨兵节点；

但是主从模式有一个问题就是：当主节点A挂掉时，可能有一些数据还没有同步到从节点B；资源CCC的分布式锁信息恰好在这部分；主节点A挂掉后，从节点B接替为主节点B，此时，资源CCC的锁信息B并没有，其他线程此时申请锁，就申请到了；  这就产生了问题，导致两个线程同时持有了锁

更可靠的办法就是 **多机部署**

#### （2）多机部署

比如 Redis 的 RedLock ；定义是：有多个 Redis 主节点，这些主节点之间没有关系，完全相互独立；

操作：

- 线程获取锁时，同时向 n 个主节点申请锁
- 一半以上的节点申请锁成功就算是申请到锁
- 如果没有一半以上的申请成功，则是申请失败，线程给所有节点发送解锁命令
- 申请成功后，由于网络请求需要时间，所以锁的实际剩余持有时间 = 申请的时间 - 请求的时间
- 业务处理完毕后，线程给所有节点发送解锁命令

优点：可靠性高，就算是有部分节点挂掉，也能继续提供服务

> 每个主节点是相互独立的，普通主节点能实现的功能这些主节点也都有，比如哨兵模式等（比如说主节点 A，也可以有自己的从节点，有哨兵）

### 6、RedLock 一定可靠吗

其实，也不一定可靠；

> 由于分布式的三大困境，并没有完全可靠的分布式锁

三大困境是 NPC，即 Network Delay（网络延迟）、Process Pause（进程暂停）、Clock Drift（时钟漂移）

RedLock 处理了 Network Delay 这一困境，其他的没有

#### （1）Network Delay

申请锁成功，节点回包给申请者，结果因为网络堵塞迟迟不能到申请者，等到了申请者，可能申请的锁已经过期了，那么此时就会出现问题，锁已经过期了申请者却不知道；

RedLock 已经解决了这个问题，在申请成功后，锁剩余的持有时间 = 实际申请锁的时间 - 网络请求时间；网络请求时间是考虑在内的

#### （2）Process Pause

一个线程A申请到了锁，已经持有了，但是由于系统之类的问题（比如 JVM 的 GC），线程A暂停了；  此时锁过期了，另一个线程B申请到了锁；等线程A返回回来的时候，它并不知道自己的锁已经过期了； 那么就会出现多个线程持有同一把锁的情况

![img](http://yolo-img.oss-cn-beijing.aliyuncs.com/img/asynccode)

#### （3）Clock Drift

时钟偏移是指时钟突然变化（细节不管）

假设多机部署有5个主节点，线程A向三个节点申请锁成功了，此时A就成功获取到了锁；

之后，三台中的一台发生了时钟漂移，导致锁立马过期了；B线程又恰好向包含时钟漂移的这个节点的三个节点申请成功了，那么，此时就会出现两个线程同时持有锁的情况；

### 7、总结

分布式锁没有完全可靠的，要根据实际应用场景选择合适的，一般情况都用的是 主从模式，RedLock 很少用；



## 三、事务

什么是事务？ 多个操作被看作一个整体，一起执行；事务一般具有原子性

### 1、Multi 事务

Redis 原生有 Multi 命令，用于开启事务；

整个事务的执行是由几个命令构成：Watch、Multi、Exec、Discard

- Multi：用于开启事务，开启后，所有的命令都会加入到事务队列中
- Exec：执行事务
- Discard：放弃事务，执行后事务取消，已经加到事务队列中的命令就无效了
- Watch：用于监视事务中操作的 key；一般的操作：在 Multi 开启事务之前执行 Watch，监视某几个 key，Multi 开启事务后，操作这几个 key ，如果在事务执行之前，有其他客户端修改了监视的 key，则事务执行不成功；

multi：

```Java
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set a 1
QUEUED
127.0.0.1:6379> set b 2
QUEUED
127.0.0.1:6379> exec
1) OK
2) OK
127.0.0.1:6379> keys *
1) "b"
2) "a"
127.0.0.1:6379>
```

watch：

```Java
终端1：

127.0.0.1:6379> watch a
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set a a
QUEUED
127.0.0.1:6379> set b b

终端2：

127.0.0.1:6379> set a 1
OK

终端1：

127.0.0.1:6379> exec
(nil)
```

当 watch 监视的 key 被修改时，事务回滚，操作无效

Multi 并不具备原子性，他只是将命令添加在一起，一块执行，依赖的还是 Redis 核心逻辑单线程执行，Multi 操作不会被打断；看起来就是原子操作

Multi 事务不使用 watch 时不支持回滚，事务中有命令执行失败时，其他命令还是会执行成功；

注意：执行失败是指执行的时候出错，而不是输入命令编译就出错等情况，编译出错等情况下，整个事务执行失败

Multi事务的缺点：

1. 事务开启后，每个命令都是一次调用，消耗资源
2. 事务开启后，防止事务中的 key 被修改，还需要 watch 命令，操作繁琐
3. 事务中的命令执行出错时，其他命令能正常执行，令人疑惑

### 2、Lua 事务

Lua 是使用标准 C 语言写的轻量的脚本语言，目的是嵌入到应用程序中，为应用程序提供灵活的扩展和定制功能；       Lua 脚本实际上是将许多命令添加到一个流程中，相当于打包；

Lua 的执行命令为 eval

```Java
127.0.0.1:6379> eval "return {redis.call('set', 'a', 'ww'), redis.call('set', 'b', 'ss')}" 0
1) OK
2) OK
127.0.0.1:6379> get a
"ww"
127.0.0.1:6379> get b
"ss"
```

> 如果执行过程中发生错误，之前的仍然是执行成功，之后的停止执行

很明显，Lua 的使用很方便，不需要那么多命令配合

Lua 在 Redis 中常用的场景就是 分布式锁 、秒杀

## 四、消息队列

消息队列就是传递消息的队列，先入先出，一般用于 异步流程、消息分发、流量削峰等；

Redis 中可以用作队列的：

### 1、List

虽然 List 是双端操作，不过在用作消息队列时，可以设定只能左进右出或者右进左出；

Lpush 放进消息，Rpop 取出消息；但是这样的话消费者不知道什么时候有消息，得一直询问；所以有了 BRPOP 、BLPOP 阻塞取出，命令格式为 BRPOP key seconds；  seconds 为限定时间，如果这么长时间没有消息，就返回； 这个阻塞命令只能接收一条消息，接收到就返回；

List 的缺点：不支持 ACK（消息取出后就出队列了，如果消费失败，消息放不回去）； 不支持多消费者消费

### 2、Pub/Sub 生产订阅模式

Redis 支持发布订阅模式

当订阅者订阅了某个频道时，有消息它就会感知到；支持多消费者消费，每个消息每个消费者都能消费一次

> 需要消费者先订阅，不然订阅之前生产的消息生产失败

![img](http://yolo-img.oss-cn-beijing.aliyuncs.com/img/asynccode)

缺点：没有 ACK，消费失败后消息也放不回；        没有持久化，系统宕机消息就丢失了

### 3、Stream

Stream 可以作为轻量级消息队列，是 Redis 中最完备的消息队列

优点：支持 ACK，支持消费组， 支持持久化

缺点：跟真正的消息队列相比可靠性还有很大差距； 等等

### 4、总结

List：不需要 ACK、不需要消费组 的场景可用

Pub/Sub 生产订阅模式：不需要 ACK、不需要持久化、不需要消费组 的场景可用（相比 List 的优点在于 支持多消费者，默认是阻塞获取消息，有了消息后消费者是知道的）

Stream：需要 ACK、需要消费组、需要持久化 的场景可以用

## 五、秒杀

秒杀需要考虑几个问题：高并发、超卖、少卖       后续补充........
