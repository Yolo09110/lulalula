---
title: 进程管理
date: 2023-11-14 20:36:56
category: 操作系统
---





# 1、进程、线程基础知识

## 1.1 进程

### 1.1.1 进程的状态

进程的状态有 创建、就绪、运行、阻塞、就绪挂起、阻塞挂起、结束 七种状态。

- 创建：进程创建过程中的状态，创建成功后转变为就绪状态
- 就绪：等待CPU运行时的状态
- 运行：在CPU上运行时的状态
- 阻塞：运行时的进程，需要等待某些事件发生，例如 IO 操作，就会暂时停止运行；转为阻塞状态，等待条件完成后，就转为就绪状态
- 因为内存不存，被换出到磁盘上，称之为挂起。等再次需要运行的时候，再换入到内存中
- 进程终止过程中的状态，称为结束状态



状态之间的转换关系：

创建 -》就绪    ==创建 -》就绪挂起==    就绪 ->》运行    就绪 -》就绪挂起    运行 -》就绪    运行 -》阻塞     运行 -》就绪挂起    运行 -》结束    阻塞 -》就绪    阻塞 -》阻塞挂起    就绪挂起 -》就绪    阻塞挂起 -》就绪挂起    阻塞挂起 -》阻塞    

<img src="http://yolo-img.oss-cn-beijing.aliyuncs.com/img/image-20231114205950041.png" alt="image-20231114205950041" style="zoom: 67%;" />

![知乎搜 PCB 的提示](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/操作系统/进程和线程/11-PCB嫖娼.jpg)

### 1.1.2 进程的控制结构

PCB（Process Control Block）进程控制块，==是进程的唯一标识==，PCB随着进程的创建而创建，随着进程的结束而消失

PCB 中记录了：

- 进程描述信息：pid、用户标识（进程属于哪个用户）
- 进程控制和管理信息：进程状态、==进程优先级==
- 进程资源分配清单：有关内存地址和虚拟地址空间的信息，打开的文件以及使用的 I/O 设备等信息
- CPU相关信息：保存了该进程在 CPU 中的上下文信息，即 CPU 寄存器等信息
- 其他进程的PCB链接：PCB 一般使用==链表==进行管理，需要存储下一个PCB节点的地址信息



PCB有两种组织结构：链表和索引，因为进程创建、销毁比较频繁，所以采用链表方式。

将同状态的进程的PCB使用链表链接起来。

<img src="http://yolo-img.oss-cn-beijing.aliyuncs.com/img/image-20231114213031737.png" alt="image-20231114213031737" style="zoom: 67%;" />



### 1.1.3 进程的控制

1、创建进程

操作系统允许一个进程创建另一个进程，并且运行子进程继承父进程所拥有的资源（虚拟地址空间一样）

创建过程：

- 创建一张空白PCB，向其中填写一些控制和管理信息，比如 pid、用户标识符等
- 为该进程分配运行所必须的资源，比如内存资源
- 将PCB插入到就绪队列，等待被调度

2、终止进程

终止进程有三种方式：进程执行完正常终止、进程异常终止、外界干预（kill 命令）

==当子进程被终止时，在父进程处继承的资源要归还给父进程；当父进程终止时，该父进程的子进程作为孤儿进程被一号进程托管，由一号进程负责完成状态收集工作==

终止过程：

- 查找需要终止的进程的PCB
- 如果处于运行状态，就立即终止运行
- 如果还有子进程，将子进程交给一号进程接管
- 将所有的资源归还给操作系统
- 将PCB从所在队列中删除

3、阻塞进程

进程的阻塞是主动过程，而阻塞的进程被唤醒是被动的，只能由另一个进程唤醒

阻塞过程：

- 查找需要阻塞的进程的PCB
- 停止进程运行，保护现场，释放CPU资源
- 将PCB中的进程状态改变为阻塞，将其从运行队列中转移至阻塞队列

4、唤醒进程

==阻塞的进程不可能自己唤醒自己==

唤醒过程：

- 在阻塞队列中找到需要唤醒的进程的PCB
- 修改PCB中的进程状态为就绪
- 将PCB从阻塞队列中删除，添加到就绪队列中



### 1.1.4 进程的上下文切换

`进程是由内核进行管理和调度的，因此进程的上下文切换一定发生在内核态`

进程在 CPU 中运行时，会有一系列信息，包含进程的用户空间资源（虚拟内存、栈、全局变量等）、内核空间资源（内核堆栈、寄存器等），这些信息在进程离开CPU或者进入CPU时，都是需要保存下来或者恢复的，这就叫进程的上下文（==上下文就是进程运行时的环境==）切换。这些信息都存储在PCB中。

（简单说，就是把进程在CPU中运行时，CPU中所有与该进程有关的信息保存下来）

### 1.1.5 进程的组成

进程由 PCB、程序段、数据段组成

PCB 是给操作系统用的，用来管理进程；而程序段和数据段是给进程自己用的；



## 1.2 线程



### 1.2.1 为什么使用线程

（问题可以理解为：有了进程为什么还需要线程）

进程的缺点：

- 通信、共享数据困难；
- 维护进程的开销大。创建时，创建PCB，分配内存；终止时，回收资源；切换时，保存进程状态信息

因为这些缺点，线程才出现了。



没有线程时，进程是资源分配和调度的单位，创建或者撤销进程时，系统都要分配/回收资源，如内存空间、I/O设备等，需要较大的时空开销，限制了并发程度的提高。所以，将进程的==资源分配==和==调度==这两个属性分开处理，资源分配还是进程，但是调度改为线程，把调度执行与切换的责任交给线程

==引入线程前，进程是资源分配和独立调度的基本单位。引入线程后，**进程是资源分配的基本单位，线程是独立调度的基本单位**。==



### 1.2.2 什么是线程

==线程是进程中的一条执行流程==

同一个进程中的线程可以共享代码段、数据段、文件等资源，但每个线程又有自己的一套独立的栈和寄存器（程序计数器），这样可以确保线程的控制流是相对独立的。

<img src="http://yolo-img.oss-cn-beijing.aliyuncs.com/img/image-20231114223939715.png" alt="image-20231114223939715" style="zoom: 50%;" />

线程的优点：

- 一个进程中可以存在多个线程
- 维护线程的开销小
- 同一个进程中的线程之间，可以方便的进行通信、共享数据

线程的缺点： 

- ==一个线程崩溃，所属进程的所有线程都崩溃==。（因为进程中的所有线程是共享一些资源的，某一个线程出现问题，可能会使共享的资源产生错误，为了避免其他线程纷纷出现错误，让所有的线程全都崩溃是安全选择）
- Java 是个特例，某个线程崩溃，所属进程不会崩溃
- 因为这个缺点，对于游戏的用户设计，就不能使用多线程，否则一个挂了，同属一个进程的所有线程都会挂掉



### 1.2.3 进程和线程的比较

异：

- 进程是资源分配（内存、打开的文件等）的单位，线程是 CPU 调度的单位
- 进程维护的开销大，线程维护的开销小（从创建、切换、销毁等方面）
- 进程间共享数据、通信困难麻烦，同一个进程的线程之间通信较为简便
- 进程拥有完整的资源平台，线程只独享必不可少的资源（栈、寄存器），共享代码段、数据段、文件等资源

同：

- 进程有就绪、运行、阻塞等状态，线程同样也有
- 进程有 PCB，线程有 TCB



==线程相比进程能减少开销==，体现在：

1. 线程创建所需时间更短。进程创建时还需要各种资源管理信息，比如内存管理信息、文件管理信息等。而线程创建时就不需要，线程只需要一些必要的信息就可以，各种资源信息直接共享。
2. 线程终止时间也更短，因为不需要释放那么多的资源
3. 线程切换更快，因为需要维护的上下文信息没有那么多，线程共享虚拟内存空间，所以在切换时，就不用切换页表等。而进程需要切换页表
4. 同一进程的所有线程之间，共享内存空间和文件资源，在线程之间通信、共享数据时，就不用通过内核，效率就会极大提升



