---
title: 进程管理
date: 2023-11-14 20:36:56
category: 操作系统
---





# 1、进程、线程基础知识

## 1.1 进程

### 1.1.1 进程的状态

进程的状态有 创建、就绪、运行、阻塞、就绪挂起、阻塞挂起、结束 七种状态。

- 创建：进程创建过程中的状态，创建成功后转变为就绪状态
- 就绪：等待CPU运行时的状态
- 运行：在CPU上运行时的状态
- 阻塞：运行时的进程，需要等待某些事件发生，例如 IO 操作，就会暂时停止运行；转为阻塞状态，等待条件完成后，就转为就绪状态
- 因为内存不存，被换出到磁盘上，称之为挂起。等再次需要运行的时候，再换入到内存中
- 进程终止过程中的状态，称为结束状态



状态之间的转换关系：

创建 -》就绪    ==创建 -》就绪挂起==    就绪 ->》运行    就绪 -》就绪挂起    运行 -》就绪    运行 -》阻塞     运行 -》就绪挂起    运行 -》结束    阻塞 -》就绪    阻塞 -》阻塞挂起    就绪挂起 -》就绪    阻塞挂起 -》就绪挂起    阻塞挂起 -》阻塞    

<img src="http://yolo-img.oss-cn-beijing.aliyuncs.com/img/image-20231114205950041.png" alt="image-20231114205950041" style="zoom: 67%;" />

![知乎搜 PCB 的提示](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/操作系统/进程和线程/11-PCB嫖娼.jpg)

### 1.1.2 进程的控制结构

PCB（Process Control Block）进程控制块，==是进程的唯一标识==，PCB随着进程的创建而创建，随着进程的结束而消失

PCB 中记录了：

- 进程描述信息：pid、用户标识（进程属于哪个用户）
- 进程控制和管理信息：进程状态、==进程优先级==
- 进程资源分配清单：有关内存地址和虚拟地址空间的信息，打开的文件以及使用的 I/O 设备等信息
- CPU相关信息：保存了该进程在 CPU 中的上下文信息，即 CPU 寄存器等信息
- 其他进程的PCB链接：PCB 一般使用==链表==进行管理，需要存储下一个PCB节点的地址信息



PCB有两种组织结构：链表和索引，因为进程创建、销毁比较频繁，所以采用链表方式。

将同状态的进程的PCB使用链表链接起来。

<img src="http://yolo-img.oss-cn-beijing.aliyuncs.com/img/image-20231114213031737.png" alt="image-20231114213031737" style="zoom: 67%;" />



### 1.1.3 进程的控制

1、创建进程

操作系统允许一个进程创建另一个进程，并且运行子进程继承父进程所拥有的资源（虚拟地址空间一样）

创建过程：

- 创建一张空白PCB，向其中填写一些控制和管理信息，比如 pid、用户标识符等
- 为该进程分配运行所必须的资源，比如内存资源
- 将PCB插入到就绪队列，等待被调度

2、终止进程

终止进程有三种方式：进程执行完正常终止、进程异常终止、外界干预（kill 命令）

==当子进程被终止时，在父进程处继承的资源要归还给父进程；当父进程终止时，该父进程的子进程作为孤儿进程被一号进程托管，由一号进程负责完成状态收集工作==

终止过程：

- 查找需要终止的进程的PCB
- 如果处于运行状态，就立即终止运行
- 如果还有子进程，将子进程交给一号进程接管
- 将所有的资源归还给操作系统
- 将PCB从所在队列中删除

3、阻塞进程

进程的阻塞是主动过程，而阻塞的进程被唤醒是被动的，只能由另一个进程唤醒

阻塞过程：

- 查找需要阻塞的进程的PCB
- 停止进程运行，保护现场，释放CPU资源
- 将PCB中的进程状态改变为阻塞，将其从运行队列中转移至阻塞队列

4、唤醒进程

==阻塞的进程不可能自己唤醒自己==

唤醒过程：

- 在阻塞队列中找到需要唤醒的进程的PCB
- 修改PCB中的进程状态为就绪
- 将PCB从阻塞队列中删除，添加到就绪队列中



### 1.1.4 进程的上下文切换

进程在 CPU 中运行时，会有一系列信息，包含进程的用户空间资源（虚拟内存、栈、全局变量等）、内核空间资源（内核堆栈、寄存器等），这些信息在进程离开CPU或者进入CPU时，都是需要保存下来或者恢复的，这就叫进程的上下文（==上下文就是进程运行时的环境==）切换。这些信息都存储在PCB中。



## 1.2 线程

### 1.2.1 为什么使用线程

（问题可以理解为：有了进程为什么还需要线程）

进程的缺点：

- 通信、共享数据困难；
- 维护进程的开销大。创建时，创建PCB，分配内存；终止时，回收资源；切换时，保存进程状态信息

因为这些缺点，线程才出现了
