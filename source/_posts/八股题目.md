## Spring

##### 1、使用 Spring 的好处是什么？

MyAnswer：

首先，Spring 是一个开源的轻量型框架，是非侵入式的，可以以很小的代价改造旧的项目。其次，Spring 的生态很好，支持的框架和组件非常丰富。再有，Spring 极大地简化了开发，不用再重复造轮子，开箱即用，拓展性很强。Spring 支持 IOC，极大的降低了耦合度，对象的生命周期和配置都由容器管理。还支持 AOP，将业务逻辑和系统服务分开。Spring 还支持事务操作

##### 2、什么是AOP？

AOP（Aspect-Oriented Programming，面向切面编程），是指将与业务逻辑无关，但是被业务逻辑模块共同调用的逻辑和责任进行封装，便于减少代码的重复，降低模块间耦合度。     当需要为分散的对象引入公共行为的时候，使用AOP。

##### 3、AOP的代理方式有哪几种？

当被代理对象有实现接口时，使用 JDK 动态代理。没有实现接口时，使用 Cglib 代理

##### 4、怎样实现动态代理(被代理对象必须实现了某接口)

动态代理最核心的是一个接口 （InvocationHandler）和一个方法（ newProxyInstance ）

代理类首先实现该接口，表明该类是一个动态代理类，重写 invoke 方法，完成代理过程，返回被代理对象方法执行的结果。 

通过 Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) 得到代理对象，代理对象是被代理对象实现的接口类型

##### 5、AOP的一些基本概念

目标（Target）：被通知的对象（要增强的目标）

代理（Proxy）：向目标对象通知以后创建的代理对象

连接点（JointPoint）：目标对象所属类中，定义的所有方法均为连接点

切入点（Pointcut）：被切面拦截 / 增强的连接点。 切入点一定是连接点，连接点不一定是切入点

通知（Advice）：增强的逻辑 / 代码

切面（Aspect）：切入点 + 通知

织入（Weaving）：将通知应用到目标对象，进而生成代理对象的过程动作 

##### 6、通知（Advice）的类型

前置通知 Before 、后置通知 After 、返回后通知 After Return 、异常后通知 After Throwing、环绕通知 Around 

##### 7、Bean的生命周期

- 实例化
- set 方法属性填充
- 如果实现了 Aware 接口，调用相关方法
- 如果有和加载这个 Bean 的容器相关的 BeanPostProcessor 接口实现类，则调用 postProcessBeforeInitialization() 
- **如果实现了 InitializingBean 接口，执行 afterPropertiesSet() 方法**
- 如果有自定义配置的 init-method 则调用
-  调用 postProcessAfterInitialization() 
- 使用Bean
- **Bean销毁时，如果实现了 DisposableBean 接口，则调用 destroy() 方法**
- Bean 销毁时，如果有自定义配置的 destroy-method ，则调用

#####  8、Bean 的作用域

- singleton：唯一的 Bean 实例，如果没有设置懒加载则在创建容器时就创建唯一的 Bean，后续操作都是统一 Bean
- prototype：每次从容器中获取，都会新创建一个 Bean 实例
- request：每次请求新建一个 Bean 实例，在本次请求中都是同一个 Bean。该作用域仅适用于使用 web 的 Spring ApplicationContext 环境
- session：每次会话新建一个 Bean 实例
- application：每个web应用拥有一个 Bean

##### 9、Spring 中单例 Bean 的线程安全问题

单例 Bean 分为两种，一种是拥有可变**成员变量**的有状态 Bean，这种单例 Bean 存在线程安全问题。另一种是不拥有可变**成员变量**的无状态 Bean，这种单例 Bean 不存在线程安全问题。

解决有状态 Bean 的线程安全问题，一是尽量避免使用可变成员变量，二是使用 ThreadLocal 对象，将可变成员变量存入其中

##### 10、Spring 常见的注入方式

- 构造器依赖注入：通过容器触发一个类的构造器来实现，构造器有一系列参数，每个参数代表对其他类的依赖

```java
@Controller
public class FooController {
    
  private final FooService fooService;
 
  //注意，不能有无参构造，如果有的话 SpringBoot 默认使用无参构造，注入为null
  @Autowired
  public FooController(FooService fooService) {
      this.fooService = fooService;
  }
}

```

Spring 推荐使用构造器依赖注入，原因是：注入的依赖不可变（推荐使用 final 修饰成员变量）、依赖不为空（在实例化对象时，调用它的有参构造进行注入，如果依赖为 null 的话，直接报错）、避免循环依赖，如果存在循环依赖，应用启动时就报错

- setter 方法注入

```java
@Controller
public class UserController {

    private UserService userService;

    @Autowired
    public void setUserService(UserService userService){
        this.userService = userService;
    }
}
```

好处：①如果有注入参数很多时，构造器注入过于臃肿，setter 注入就比较方便

②能够让类在之后重新配置或者重新注入

- 属性 / Field 注入

```java
@Controller
public class UserController {
    @Autowired
    private UserService userService;
}
```

优点：简单明了、新增依赖十分方便

缺点：注入为 null 时只能等到使用时报空指针异常才能发现、有可能造成循环依赖

##### 11、Spring框架用到了哪几种设计模式

- 工厂设计模式：Spring 使用工厂模式通过 BeanFactory 创建 Bean 对象
- 代理设计模式：Spring AOP 的实现使用了代理模式
- 单例设计模式：Spring 中的 Bean 默认都是单例
- 模板方法模式：Spring 中 JdbcTemplate 等以 template 结尾的对数据库操作的类使用到了模板模式
- 包装器设计模式：项目需要连接很多数据库，每次访问可能是不同的数据库，包装器模式使可以动态的切换不同的数据源
- 观察者模式：Spring 事件驱动模型就是很典型的观察者模式
- 适配器模式：Spring MVC 中用到了适配器模式进行 Controller 的适配

##### 12、ApplicationContext 的实现类

- ClassPathXmlApplicationContext：加载类路径下的配置文件，读取其中 bean 的定义
- AnnotationConfigApplicationContext：读取注解信息，创建容器加载 Bean
- FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件



## Mysql

##### 1、Mysql架构

Mysql 分为 Server 层和存储引擎层。所有跨存储引擎的功能都是在 Server 层实现的，存储引擎层负责数据的存储查询等

- Server 层：从上到下依次有 连接器（身份校验、权限查询）、查询缓存（如果是查询语句的话，Mysql8 已经删除）、分析器（语法语义分析）、优化器（执行方案的最优选择，比如选择使用什么索引）、执行器（首先进行权限校验，通过则调用存储引擎的接口，返回接口执行的结果）
- 存储引擎层：负责数据的存储查询等，采用可插拔式设计，Mysql 默认的存储引擎为 InnoDB，常见的还有 MyISAM

##### 2、数据库的三范式

- 第一范式：强调列的原子性，即表的每一列都是不可分割的原子数据项
- 第二范式：要求实体的属性完全依赖于主关键字（可以是多个属性组合），完全依赖是指不能仅依赖主关键字一部分的属性
- 第三范式：任何非主属性不依赖其他非主属性

##### 3、char 和 varchar 的区别

- char 是定长的，对于不定长的数据，char 占用空间。适合存储固定长度的数据，效率高

- varchar 是不定长的，存储的是所有的数据 + 自身此时的长度（占一个字节）

##### 4、varchar(10) 和 varchar(20) 的区别

在硬盘存储上二者没有任何区别，所占的空间的都是所有数据的总字节长度 + 1，但是有些需要在内存中完成的作业就会有差别，因为在内存中是按照定义时的长度分配空间的，比如说 order by等操作

##### 5、谈谈你对索引的理解

索引出现的目的就是提高数据的查询效率，相当于书的目录。索引根据不同的分类标准可以分为很多。按照数据结构可以分为 B+ 树索引、Hash 索引、Full-text 索引，按照物理存储可以分为 聚簇索引和二级索引（辅助索引），按照字段类型可以分为 主键索引、唯一索引、普通索引、前缀索引，按照字段数量可以分为 单列索引和聚合索引；

索引的存在并不一定带来好处，因为它存在几个问题：

1. 索引需要占用物理空间
2. 创建和维护索引需要耗费时间
3. 降低了增删改的效率，因为进行增删改操作时，B+ 树为了保持索引的有序性，都要进行动态维护

所以，索引的使用也要根据实际情况来定，不适合创建索引的字段有:

1.  where 、order by 、group by 中用不到的字段
2. 经常被修改的字段
3. 存在大量重复数据的字段
4. 表数据太少时不适合创建索引

适合创建索引的情况：

1. 字段有唯一性限制的
2. 经常在 where、order by、group by 中出现的字段

建立索引的原则就是：

1. 在最频繁使用的、用以缩小查询范围的字段上建立索引
2. 在最频繁使用的、需要排序的字段上建立索引



##### 6、为什么InnoDB使用 B+ 树而不是 B 树

1. B+ 树只有叶子节点存放数据，非叶子节点不存放数据；而 B 树所有节点都存放数据。这样的话，B+ 树的非叶子节点可以存放更多的索引，相比于 B 树 B+ 树就更加“矮胖”，查询时磁盘 I/O 的次数就少
2. B+ 树的叶子节点使用双向链表相互连接，有利于范围查询；而  B 树要进行范围查询只能遍历所有的节点
3. B+ 树有大量的冗余节点（所有非叶子节点都是冗余节点，所有节点的索引子节点都有），这些冗余让 B+ 树在删除、插入时效率更高。而 B 树在删除、插入操作时会发生复杂的树的变化



##### 7、对聚簇索引的理解

聚簇索引就是对磁盘上数据重新组织以按一个或多个列的值进行排序的算法。特点是存储数据的顺序和索引一致。一张表只允许且一定有一个聚簇索引。如果有主键则以其为索引键，如果没有主键则以第一个不为 null 的唯一键作为索引键，如果没有，则 InnoDB 自己生成一个隐式自增 id 作为索引键



##### 8、聚簇索引和非聚簇索引的区别

聚簇索引的叶子节点存放数据，而非聚簇索引的叶子节点不存放数据，仍然是索引节点，存放的是聚簇索引的索引键



##### 9、谈谈对 Hash 索引的理解

Hash 索引能以 O（1）的时间进行查找，但是失去了有序性。无法用于范围查找、部分查找和排序，只支持精确查找。

InnoDB 对 B+ 树索引进行了优化，当某个索引值被频繁使用时，就在 B+ 树索引之上再建一个 Hash 索引，这样 B+ 索引也就具有了 Hash 索引的快速查找优点



##### 10、谈谈对覆盖索引的理解

覆盖索引就是指索要查询的字段数据在辅助索引中直接就可以查到，而不用回表操作，再去聚簇索引中查记录。



##### 11、怎么直到是否使用到了索引

使用 explain 命令来查看执行计划，关注 possible_keys（可能用到的索引）、key（经过优化器评估最终使用的索引）、key_len（使用的索引的长度）这几个字段



##### 12、索引失效的几种情况

1. 对索引字段进行了表达式计算
2. 对索引字段使用了函数运算
3. 索引字段进行了隐式类型转换（字符串与数字比较时，默认会把字符串类型转为数字）
4. 进行左或者左右模糊查询 like "%aa"  或者 like "%aa%"
5. where 语句里使用了 or



##### 13、查询性能的优化

1. 减少查询的数据量：只返回必要的列，避免使用 select *；  只返回必要的行，使用 limit   ；缓存重复查询的数据
2. 减少服务端扫描的行数：最有效的办法是使用索引来覆盖查询，也就是索引覆盖



##### 14、InnoDB 和 MyISAM 的区别

- InnoDB 支持事务，MyISAM 不支持事务
- InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持表级锁
- InnoDB 支持数据库异常崩溃后的安全恢复，依赖于 redo log，MyISAM 不支持
- InnoDB 支持 MVCC，MyISAM 不支持
-  InnoDB 支持外键，MyISAM 不支持
- InnoDB 的性能好于 MyISAM

##### 15、主从复制中涉及的三个线程

- binlog 线程：负责将主服务器上的数据更改写入到二进制日志（binlog）中
- I/O 线程：负责从主服务器上读取二进制日志，并写入到从服务器的重放日志（relay log）中
- SQL 线程： 负责读取重放日志，并重放其中的 SQL 语句

##### 16、请你描述下事务的特性

- 原子性（atomicity）：事务中的操作要么全部执行，要么都不执行，发生错误就回滚
- 一致性（consistency）：事务执行前后，数据满足**完整性约束**，数据库保持一致性状态。换种说法，事务执行后的结果要与所抽象的客观世界的真实情况保持一致。
- 隔离性（isolation）：数据库允许多事务并发执行，在对同一数据进行操作时，多个并发事务应该互不影响，也就是事务之间是隔离的
- 持久性（durability）：事务一旦提交，对数据库的修改就是永久的

原子性通过 undo log（回滚日志）来实现；持久性通过 redo log（重做日志）来实现； 隔离性通过 MVCC 或锁机制来实现；一致性通过 原子性 + 持久性 + 隔离性 来实现

##### 17、谈谈对 MVCC 的理解

MVCC（多版本并发控制 multi-version concurrency control），是一种并发控制的方法，基于 隐藏字段 trx_id、roll_pointer + Read View + undo log 来实现。InnoDB 的**可重复读**、**读已提交**隔离级别都是基于 MVCC 实现的。相较于加锁的粗暴操作以及较大的性能影响，MVCC 用更好的方式去处理冲突，能有效提高数据库的并发性能

##### 18、说一下 MySQL 的表锁和行锁

- 表级锁：MySQL 中粒度比较大的一种锁，主要有 表锁、元数据锁、意向锁、AUTO-INC锁，针对的是非索引字段。对当前操作的整张表加锁，实现简单，资源消耗少，加锁快，不会出现死锁。但是触发冲突的概率大，高并发下效率低。表级锁和存储引擎无关。 
- 行级锁：MySQL 中粒度最小的锁，主要有 Record Lock、Gap Lock、Next-Key Lock，针对的是索引字段。对表中的行记录加锁。实现较复杂，消耗资源较多，加锁慢，会出现死锁。但是行级锁能大大降低触发冲突的概率，高并发下效率高。行级锁与存储引擎有关，InnoDB 支持行级锁，MyISAM 不支持

##### 19、MySQL 服务器 CPU 飙升到 500% 怎么处理

先使用操作系统的 top 命令查看是不是 mysqld 占用导致的，如果不是，则找出占用高的进程进行相关处理；

如果是 mysqld 占用导致的，则使用 SHOW PEOCESSLIST 查看 MySQL 正在运行的线程，找出消耗高的 SQL，看看它的执行计划是否准确，索引是否失效，或者其他原因。

然后 kill 掉这些线程，做出调整，比如 sql 优化、索引优化等，再重新运行。

如果所有的 SQL 消耗都不高，只是同一时间有大量的 MySQL 连接导致 CPU 飙升，则分析相关原因，同时做出调整。

##### 20、谈谈你对水平切分和垂直切分的理解

- 水平切分是指将同一个表中的记录拆分到多个结构相同的表中，可以将数据分布到集群的不同节点上，从而减小单个数据库的压力
- 垂直切分是指将一个表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可将经常使用和不经常使用的切分开

##### 20、主从同步的延迟原因及解决办法

从服务器的 SQL 线程是单线程，当主库负载过高，从库读取重放日志，其中需要重放的DML、DDL 操作太多太费时，就会导致 SQL 线程处理不过来，导致延迟出现。

解决办法：增加从服务器，降低服务器负载； 提升从服务器配置

##### 21、对数据库读写分离的理解

读写分离常用代理方式实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作和实时性要求比较高的读操作，从服务器处理读操作；

读写分离极大的缓解了锁的争用，提升了系统性能，增加了冗余，提高了可用性

##### 22、MySQL问题排查的手段

- 使用 show processlist 命令查看当前的所有连接信息
- 使用 explain 命令查看SQL 的执行计划
- 开启慢查询日志，查看慢查询的SQL

##### 23、binlog、undolog、redolog都是干什么的

binlog：server层实现的，记录所有引擎对数据库的修改，用于事务提交时，是逻辑日志，记录语句的原始逻辑。是可以追加写入的，写到一定大小会创建一个新的文件继续写，不会覆盖。用于读写分离主从复制

undolog：记录修改前记录，用于事务回滚和MVCC。

redolog：是 InnoDB 存储引擎独有的，是物理日志，记录的是在具体某个数据页上做了什么修改。是循环写，写满之后会覆盖之前的。用于数据库故障之后的数据恢复。

##### 24、SQL 和 MySQL 的区别

SQL 是一种结构化查询语言，用于在数据库上执行各种操作，而MySQL 是一个软件，是一个数据库管理系统，使用 SQL 执行所有数据操作

##### 25、什么是死锁？如何解决

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

官方解答：两个事务都持有对方需要的锁，并且都在等待对方释放锁，自己不会释放锁

常见的解决死锁的方法：

- 设置事务等待锁的超时时间，超过这个时间就回滚，手中的锁就会释放
- 开启死锁主动检测，在发现死锁发生时，手动回滚死锁链条中的一个事务

##### 26、什么是悲观锁和乐观锁？如何实现

- 悲观锁：假定一定会发生冲突，屏蔽一切可能违反数据完整性的操作。实现方式：在数据库中使用锁机制
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。适用于读多写少的场景。实现方式：版本号机制 或 CAS 算法

##### 27、DROP、DELETE、TRUNCATE

drop属于 DDL，用来删除表结构，不可回滚。删除速度最快。

delete属于DML，用来删除表中的记录，表的结构不变。可回滚，速度慢。需要逐行删除

truncate 属于DDL，不删除表结构，清空表中的所有数据，不可回滚，删除速度快

##### 28、为什么要分库分表

随着时间和业务的发展，库中的表会越来越多，表中的数据也会越来越多。相关的数据库操作开销也会越来越大，同时，一台服务器的资源是有限的。所以从 性能和可用性角度考虑，进行数据库拆分有助于提升系统性能。拆分分为分库和分表，分库是将原本一个数据库中的表拆分到不同的数据库中。分表是指将一张表拆分成多张表。

##### 29、分库分表的问题

- 事务问题：同一个数据库的表分在了不同的数据库上，如果单个操作涉及到多个数据库，自带的事务就没办法使用。
- join操作：同一个数据库的表分在了不同的数据库上，join 操作就没法使用。只能手动多次查询进行封装
- 自增的主键id：分库分表后，数据遍布在不同的数据库上，自增主键就没法满足生成主键唯一的要求。需要使用分布式id

##### 30、读写分离的实现方案

推荐 sharding-jdbc



## Redis

##### 1、谈下你对redis的了解

redis 是一种非关系型数据库，是基于内存的键值对数据库，对数据的操作都是在内存中完成，因此读写速度非常快。常用于缓存、消息队列、分布式锁等场景。提供了多种数据类型，比如 String、set、zset、hash、list、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流）。Redis 还支持事务、持久化、多种集群方案、Lua脚本、发布/订阅模式、内存淘汰机制、过期删除机制等等

##### 2、Redis的使用场景

- String：缓存对象、分布式下共享session、分布式锁、常规计数
- Set：聚合计算（并集、差集、交集）场景，比如点赞、共同关注、抽奖活动等
- List：消息队列
- Hash：购物车、缓存对象（一般使用String缓存，Hash比较少用）
- ZSet：排序场景，比如排行榜
- Bitmap：签到统计、判断用户登陆状态
- GEO：滴滴叫车
- Stream：消息队列

##### 3、Redis的常见功能

数据持久化、分布式锁的实现、数据缓存、支持事务、支持消息队列

##### 4、Redis为什么快？为什么单线程还快？

- 基于内存，对数据的操作都在内存中，速度快。性能瓶颈不在CPU，而在内存和网络I/O，因此单线程不影响性能
- 数据结构简单，对数据的操作也简单
- 采用单线程，避免了线程切换的开销，避免了线程竞争产生的消耗
- 使用多路I/O复用，而不是阻塞IO 

##### 5、缓存雪崩、缓存穿透、缓存击穿以及解决方案

[缓存问题](https://xiaolincoding.com/redis/base/redis_interview.html#如何避免缓存雪崩、缓存击穿、缓存穿透)

- 缓存雪崩：大量缓存在同一时间过期，此时有大量的用户请求，在Redis中都无法命中，于是直接请求数据库，从而导致数据库压力骤增。

解决方案：将缓存失效时间随机打散、设置缓存不过期

- 缓存击穿：缓存中的某个热点数据过期了，此时有大量请求访问该热点数据，Redis中无法命中，于是直接请求数据库，导致数据库压力骤增。

解决方案：互斥锁方案（保证同一时间只有一个业务线程请求缓存）、不给热点数据设置过期时间

- 缓存穿透：当发生缓存雪崩和缓存击穿时，一旦缓存恢复相应的数据，数据库压力就可减小，而缓存穿透不同。当大量的请求访问缓存和数据库中都没有的数据时，数据库压力骤增。

缓存穿透一般是由于误操作（误删除了数据）或者黑客恶意攻击造成的

解决方案：限制非法请求、设置空值或者默认值（当发现有缓存穿透发生时，针对查询的数据设置空值或默认值）、使用布隆过滤器

##### 6、怎么保证缓存和数据库的数据的一致性

- 设置合理的缓存过期时间，过期后就会请求数据库获取数据
- 当数据库发生修改时，更新或删除缓存

就出现了四种方案：

先更新数据库，再更新缓存    ；先更新缓存，再更新数据库；   先删除缓存，再更新数据库；   先更新数据库，再删除缓存

**一般选用先更新数据库再删除缓存。这种叫做Cache Aside（旁路缓存）策略，是Redis 和 MySQL 的更新策略**

<img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/1cc7401143e79383ead96582ac11b615.png" alt="图片" style="zoom: 50%;" />

可能出现的问题如上，但是，缓存的写入是远远快于数据库写入的，所以上述情况出现的可能性很小。

##### 7、Redis 的持久化有几种方式

- AOF（Append-only file）：Redis会将收到的每一个写命令都通过 write 函数追加到文件末尾。当Redis重启时，会读取文件，重新执行其中的命令在内存中重建整个数据库的内容。
- RDB（Redis Database）：按照一定的时间周期策略把内存中的数据以快照（snapshot）的形式保存到硬盘的二进制文件中。
- 混合持久化：AOF文件前半部分为RDB格式的全量数据，后半部分为AOF格式的增量数据

AOF和RDB区别：

- AOF比RDB 更新频率高，优先使用AOF
- AOF比RDB更安全，文件也更大，恢复时资源消耗更大，更耗时
- 如果两个都配置了则优先加载AOF

##### 8、Redis的内存淘汰策略有哪些

- 不进行数据淘汰的策略：当运行内存大于最大设置值时，暂停服务，直接返回错误
- 进行数据淘汰的策略（可分为在 设置了过期时间的数据之间淘汰 和 在所有数据之中淘汰）：**volatile-random**：随机淘汰设置了过期时间的任意键值；    **volatile-ttl**：优先淘汰更早过期的键值。    **volatile-lru**（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；     **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；                                                                                                 在所有数据范围内进行淘汰：      **allkeys-random**：随机淘汰任意键值;      **allkeys-lru**：淘汰整个键值中最久未使用的键值；      **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。

##### 9、Redis过期键的清除

过期策略主要有三个：

- 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就立即清除。 优点是清除及时，对内存友好；缺点是会占用大量的CPU资源去处理过期的数据
- 惰性过期：只有在访问一个key时，才会判断该 key 是否过期，过期则清除。优点是可以最大化的节省CPU资源；缺点是对内存非常不优化，很久都不访问的过期数据可能一直无法清除
- 定期清除：每隔一定的时间，会扫面一定数量的key，并清除其中的过期的key。如果过期的key占比超过一定比例，则继续扫描一定数量的key，直到过期的key占比不超过设定比例或者扫描时间达到了设定上限，则停止清除。







## 计算机网络

##### 1、OSI 的七层模型分别是什么？各自的功能是什么？

七层分别是：

- 应用层：各种应用软件，包含 Web 应用。**协议有HTTP、FTP、SMTP、DNS等**
- 表现层：数据处理（编解码、加密解密、压缩解压缩）
- 会话层：控制应用程序之间的会话能力。**有安全性协议 SSL（安全套接字层协议）、TLS（安全传输层协议）**
- 传输层：为两台主机进程之间的通信提供通用的数据传输服务。**协议有 TCP、UDP**。数据为段 segment
- 网络层：路由和寻址。如不同设备的数据转发。**协议有ICMP、IGMP、IP**。此时的数据是包 packages
- 数据链路层：帧编码和误差纠正控制。定义数据的基本格式，如何传输，如何标识。如网卡 MAC 地址。**协议有ARP（地址解析协议）**。此时的数据是帧 frames
- 物理层：底层的数据传输，透明的传输比特流。解决两个硬件之间怎么通信的问题，如网线、网卡等。此时的数据是比特流 bits

##### 2、



## JVM

##### 1、介绍下Java内存区域

JDK 1.7之前：

线程共享的是堆和方法区，堆中有字符串常量池，方法区中是运行时常量池。线程私有的是 本地方法栈、虚拟机栈、程序计数器PC

JDK1.8 及以后：

没有了方法区，本地内存中添加了元空间，运行常量池放在其中

- 堆：是所有线程共享的一块区域，是Java虚拟机管理的最大的一块空间。堆存在的唯一目的就是存放对象实例，几乎所有的对象实例和数组都在堆上分配内存。但JDK 1.7 开始，有了逃逸分析，如果某些方法的对象引用没有被返回或者未在外面使用，也可以分配在栈上。   堆也是垃圾收集管理的主要区域，因此也被称为 GC 堆。
- 方法区：当虚拟机需要使用一个类时，需要读取并解析Class 文件获取相关信息，再将信息存入方法区。方法区会存放已被虚拟机加载的类信息、字段信息、方法信息 等
- 虚拟机栈：除了一些本地方法外，其他所有的Java方法调用都是通过虚拟机栈实现的。每一个方法的调用都会有一个对应的栈帧压入栈中，每一个方法结束后都会弹出对应的栈帧。栈帧由 局部变量表、操作数栈、动态链接、方法返回地址构成。
- 本地方法栈：本地方法的调用通过本地方法栈实现，也是栈帧的压栈和弹出。栈帧由 操作数栈、局部变量表、动态链接、出口信息构成
- 程序计数器PC：是一块比较小的内存区域，可以看作当前线程所执行的字节码的行号指示器。有两个主要作用，一是字节码解释器通过改变PC的值来依次读取指令；二是多线程时，用来记录当前线程执行的位置，在线程切换回来时直到从哪继续执行。

##### 2、对象创建的过程

- 类加载检查：虚拟机在遇到一条 new 指令时，会先看能不能在常量池中找到需要 new 的类的符号引用，并且检查这个类是否已经被加载过、解析和初始化过。如果没有，则执行类加载过程
- 分配内存：在类加载检查通过后，就为对象在堆上分配内存，所需的大小在加载时就已经确定。分配内存有两种，一种是 指针碰撞（针对堆内存区域规整，用过的内存在一边，没用过的在另一边，由一个指针分隔），另一种是空闲列表（针对堆内存不规整，在分配时找一块足够大的内存块分配给对象实例，空闲不空闲由一个表来记录）
- 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初设为零值。这样对象的实例字段在不赋初始化值时也能使用
- 设置对象头：初始化零值后，虚拟机需要对对象进行必要的设置，将一些信息存放到对象头中，例如这个对象是哪个类的实例、对象的哈希码等
- 执行init方法：在虚拟机角度看上述其实已经创建好了一个对象实例，这部是按照程序员的想法对对象进行初始化

##### 3、对象的访问定位的两种方式

- 句柄：引用指向对象的句柄地址，在堆中开辟一块区域叫做句柄池，其中存放对象实例的地址和对象类型数据的地址
- 直接指针：引用直接是对象实例的地址

使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

##### 4、如何判断对象死亡（不能再被任何途径使用的对象）

- 引用计数法：每个对象添加一个引用计数器，有一个地方引用计数器就加一，当为0时代表没有引用，则证明死亡。这种方法实现简单，效率高，但是使用的不多。原因是如果对象之间循环引用，则无法回收
- 可达性分析算法：基本思想是通过一系列的称为 GC Roots 的对象作为起点，从这些节点往下开始搜索，所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，就判定它死亡。需要被回收。

<img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/jvm-gc-roots.png" alt="可达性分析算法" style="zoom:50%;" />

这种 6-10都要被回收

GC Roots如何选？

- 虚拟机栈或本地方法栈中引用的对象
- 方法区中类静态属性或常量引用的对象
- 所有被同步锁持有的对象

##### 5、引用的类型

- 强引用：当内存空间不足时，虚拟机宁愿抛出 OutOfMemory 也不随意回收具有强引用的对象
- 软引用：如果内存足够，就不会回收，如果内存不够才回收
- 弱引用：扫描到就回收
- 虚引用：扫描到就回收，并不会决定对象的生命周期。虚引用主要用来跟踪对象被垃圾回收的活动

##### 6、判断一个类是无用类

- 该类的所有实例都被回收了，也就是说Java堆中不存在该类的实例
- 加载该类的类加载器 ClassLoader 被回收了
- 该类对应的 Class 对象没有在任何地方被引用

##### 7、垃圾收集算法

- 标记清除算法：最基础的收集算法，先标记出所有不需要被回收的对象，标记完成后统一回收没被标记的对象。   **存在的问题**：标记和清除两个操作效率都很低、清除后会产生大量不连续的内存碎片

<img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/mark-and-sweep-garbage-collection-algorithm.png" alt="标记-清除算法" style="zoom: 67%;" />

- 复制算法：将内存分为大小相同的两块，每次使用其中一块。当这一块使用完了之后，将其中存活的对象复制到另一边，赋值完成后对这一块进行全部清除。    **存在的问题**：可用内存只有一半、对于大对象，复制开销比较大

<img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/copying-garbage-collection-algorithm.png" alt="复制算法" style="zoom: 67%;" />

- 标记-整理算法：标记过程一样，但是不是标记完就清除，而是先将所有的存活对象移到同一端，然后直接清除掉存活对象边界以外的所有区域      **存在的问题：**效率仍比较低，适合老年代这种回收频率低的场景

<img src="%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE.assets/mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法" style="zoom:67%;" />

- 分代收集算法：根据对象存活周期的不同将内存分为几块。一般将堆分为新生代和老年代，然后根据不同的年代特点选择合适的垃圾收集算法。  比如新生代每次收集都有大量对象死去，那么就采用 标记-复制算法，这样每次只需要复制很少数量的对象，成本比较低。而对于老年代这种存活几率比较高同时回收频率低的，就采用 标记-清除算法或者标记-整理算法。

***像 为什么堆要分代 这种问题，就可以从这个方面回答***

##### 8、垃圾收集器

（1）CMS（Concurrent Mark Sweep）：

使用标记-清除算法，分为四个步骤：

- 初始标记：暂停其他所有线程，标记所有与 GC Roots 直接相连的对象，速度很快
- 并发标记：同时开启GC 和用户线程，用一个闭包结构去记录可达对象，但是由于用户线程还在不断更新引用，所以并不能保证实时性
- 重新标记：暂停其他所有线程。修正并发标记期间用户线程更新的引用，比初始标记时间稍长，但远远短于并发标记
- 并发清楚：同时开启用户线程和 GC 线程，对未标记区域进行清除

优点：并发收集、低停顿          缺点：对CPU资源敏感、无法处理浮动垃圾、会产生大量空间碎片（因为使用的是标记清除）

（2）G1 （Garbage First）收集器

一款面向服务器的垃圾收集器，从整体上看基于标记整理，从局部看基于标记复制。可预测停顿的时间。

分为四个步骤：初始标记、并发标记、最终标记、筛选回收

G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的区域（名字的由来）。

##### 9、类的加载过程

加载 		 ->		连接/链接（包括 验证、准备和解析）		-> 		初始化 		 -> 		使用		  ->   	卸载

##### 10、
