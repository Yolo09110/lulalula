算法笔记（LeetCode）

## 算法知识：

### 1、回溯算法：（递归实现）

回溯算法是穷举的一种改进，回溯算法依然会列举所有可能的结果（没有剪枝函数的情况下）。

它是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回到上一步，重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

回溯算法在包含所有解的解空间树中，采取深度优先的策略，从根节点出发。

剪枝函数：![v2-368ff92d458bc2e3ae6eed63d550d75e_1440w](http://yolo-img.oss-cn-beijing.aliyuncs.com/img/v2-368ff92d458bc2e3ae6eed63d550d75e_1440w.webp)

简单来说，某个节点出现后已经不满足要求，那这个节点和后续的所有子节点都没有必要再探索，此时需要“剪掉”该枝



### 2、链表和栈

链表：

```java
class ListNode {
    int val;
    ListNode next;
    
    ListNode() {}

    ListNode(int val) { this.val = val; }

    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```

**在使用链表时，最好加一个pre节点指向头节点**

**在连接节点时，要注意改变的是当前指针的next，而不是当前指针，不然只是修改了指针的指向，连接不上**



栈：
目前，已经用Deque代替了Stack，原因在于Stack效率低，并且只是简单的栈。而Deque作为万能接口，可以作为栈、队列等，只要程序员想。

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDEzNjI5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom:50%;" />

（因为Vector是当初JAVA曾经写得不太行的类，所以Stack也不太行。

Vector不行是因为效率不太行，很多方法都用了synchronized修饰，虽然线程安全，但是像ArrayDeque,LinkedList这些线程不安全的，在需要安全的时候也可以用Collections.synchronizedCollection()转化成线程安全的，所以Vector就没什么用处了）

Deque常用的方法：

​	当栈用：push()、pop()、peek()等，peek()函数是用来取栈顶元素的值，但不弹出。

​	当队列用：入队offer()、出队poll()



### 3、分治思想（自顶向下）

将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

（1）分治的策略：

​		对于一个规模为n的问题，若该问题可以容易的解决(比如规模n较小)则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，**递归**地解决这些子问题，然后将各个子问题的解合并得到原问题的解。

​		如果原问题可以分割成k个子问题，1<k<=n，且这些子问题均可解并且利用这些子问题的解求出原问题的解，那么分治方法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归经常同时应用在算法设计之中。

（2）使用场景：

- 该问题的规模缩小到一定的程度就可以容易的解决。
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。（基础）
- 利用该问题分解出的子问题的解可以合并为该问题的解。（关键）
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

（3）可以使用分治的场景：

二分搜索、大整数乘法、Strassen矩阵乘法、棋盘覆盖、合并排序、快速排序、线性时间选择、最接近点对问题、循环赛日程表、**汉诺塔**

### 4、动态规划

动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。

（1）动态规划的核心思想：**拆分子问题，记住过往，减少重复计算**。

（2）动态规划一般是自底向上，从较小问题的解，逐步求出大的问题的解。大的问题的解依靠上一个最优的子问题的解

（3）动态规划有几个典型特征，**最优子结构、状态转移方程、边界、重叠子问题**。

​		最优子结构：假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质



可以使用动态规划的情况：**最长递增子序列、最小编辑距离、背包问题、凑零钱问题**等

相关文章：[看一遍就理解：动态规划详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/365698607)





## day 1	

### 17、电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![image-20230420135137788](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230420135137788.png)

```
eg:
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

#### 思路：

看到所有二字，就考虑用回溯算法。##为什么不用嵌套for循环呢，因为字符串的长度不确定，不知道要使用几层for。只能使用递归来实现

#### 题解：

```java
class Solution {
    private List<String> res = new ArrayList<>();
    private String[] digit_map = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

    public List<String> letterCombinations(String digits) {
        
        //空字符串时
        if (digits == null || digits.length() == 0) {
            return new ArrayList();
        }
        backtrace(digits, 0, new StringBuilder());
        return res; 
    }
    //以 2(a,b,c) 3(d,e,f)为例
    public void backtrace(String str, int index, StringBuilder letter) {
        //递归第一步：设置出口
        if (index == str.length()) {
            res.add(String.valueOf(letter));
            return;
        }
        //先拿到digits的第一个字符2, 寻找它的字符映射(a, b, c)
        char c = str.charAt(index);
        //ASCII 32减去ASCII 32
        int pos = c - '2';
        String map_letter = digit_map[pos];
        //拿到映射后，进行遍历
        for (int i = 0; i < map_letter.length(); i++) {
            letter.append(map_letter.charAt(i));
            backtrace(str, index + 1, letter);
            //相对难点
            //比如letter得到adg之后，下一个遍历的是h，此时就需要先把g先截掉
            letter.deleteCharAt(letter.length() - 1);
        }

    }
}
```

优秀解答：https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/



## day 2

### 19. 删除链表的倒数第 N 个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**进阶：**尝试使用一趟扫描实现

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230421103030482.png" alt="image-20230421103030482" style="zoom: 67%;" />

#### 思路：

不考虑进阶时，最容易想到的是先遍历一遍链表，获得总长度，然后定位到n的位置，进行删除。

**但是**，看到倒数类似的字眼，就考虑可以使用栈，因为栈可以后进的先出。

如果要求一趟扫描，也就是说不能退回或者重新来一遍，那么栈也就不能用了。此时就要使用**快慢指针**。

**快慢指针在链表相关问题中重要，需要掌握**

#### **题解**：

1、使用栈

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
		//使用pre,可以简单实现只有头指针单个节点，n为1时的情况
        ListNode pre = new ListNode(0, head);
    	//cur指向pre而不是head，因为在后续出栈时，目标节点上一个节点也要得到才能完成
    	//对目标节点的删除。针对的也是只有头节点的情况
        ListNode cur = pre;

    	//所有节点入栈，包括pre
        Deque<ListNode> stack = new LinkedList<ListNode>();
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
    	//弹出n个节点，最后一个弹出的恰好是目标节点
        while (n != 0) {
            n--;
            stack.pop();
        }
    	//获取目标节点上一个节点
        cur = stack.peek();
    	//删除
        cur.next = cur.next.next;
        return pre.next;
    }

```

2、快慢指针

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode pre = new ListNode(0, head);
    //快指针
    ListNode ahead = pre;
    //慢指针
    ListNode after = pre;
    //快指针先走n步
    while (n != 0) {
    	n--;
        ahead = ahead.next;
    }
    //快慢指针一块走
    //走到快指针所指节点的下一个节点为null时，慢指针恰好指向目标节点的上一个
    while (ahead.next != null) {
        ahead = ahead.next;
        after = after.next;
    }
    //删除
    after.next = after.next.next;
    return pre.next;
    }
}
```



### 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。

```
输入：s = "()"		输出：true
输入：s = "()[]{}"		输出：true
输入：s = "(]"		输出：false
```

#### **思路**：

左右匹配问题直接用栈，栈使用

```
Deque<> stack = new LinkedList()
```

最开始想的是使用双栈，先把所有char入栈A，然后栈A的栈顶开始出栈，与栈B的栈顶元素进行匹配，如果匹配的上，栈B的栈顶元素就出栈，匹配不上则A栈刚刚出栈的元素压入栈B。当栈A为空时，如果栈B为空，则返回true，否则返回false；

事实证明该想法想的过于复杂，简单问题复杂化。

******只需要使用一个栈。<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/baa8829ac398e665eb645dca29eadd631e2b337e05022aa5a678e091471a4913-20.gif" alt="20.gif" style="zoom: 50%;" />

这是一种办法。另一种办法是，当s.charAt（index） 出现左括号时，栈中压入对应的右括号。当出现右括号时，判断当前栈是否为空，为空return false，不为空则判断当前的char与栈顶元素是否相等，不相等就return false；

当所有元素遍历结束时，栈为空就返回true，否则返回false。

第二种相对难想到。



#### **题解**

第一种：

```java
class Solution {
    //map的新用法
   	private static final Map<Character,Character> map = new HashMap<Character,Character>(){{
        put('{','}'); put('[',']'); put('(',')'); put('?','?');
    }};
		
    public boolean isValid(String s) {
		//要一一匹配必须是偶数个字符
        if (s.length() % 2 == 1) {
            return false;
        }
        Deque<Character> stack = new LinkedList<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            //如果是左括号就入栈
            if (map.containsKey(c)) {
                stack.push(c);
            } else {
                //如果不是左括号，并且此时栈已经为空，也就是类似（）{}} 这种情况，返回false
                //如果栈不为空，但是此时的c和栈顶元素不相等，说明括号匹配不上，返回false
                if (stack.isEmpty() || c != map.get(stack.peek())){
                    return false;
                }
                //匹配的上则出栈，消掉一对括号
                stack.pop();
            }
        }
        //最终如果栈为空则true
        return stack.isEmpty();
    }
}
```

```java
public boolean isValid(String s) {
        if(s.isEmpty())
            return true;
        Stack<Character> stack=new Stack<Character>();
        for(char c:s.toCharArray()){
        	//如果是左括号，则入栈对应的右括号
            if(c=='(')
                stack.push(')');
            else if(c=='{')
                stack.push('}');
            else if(c=='[')
                stack.push(']');
            //如果不是左括号，并且此时栈已经为空，也就是类似（）{}} 这种情况，返回false
            //如果栈不为空，但是此时的c和栈顶元素不相等，说明括号匹配不上，返回false
            else if(stack.empty()||c!=stack.pop())
                return false;
        }
        if(stack.empty())
            return true;
        return false;
    }
```



## day 3

### 21. 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/merge_ex1.jpg" alt="img" style="zoom: 50%;" />

```
输入：l1 = [1,2,4], l2 = [1,3,4]		输出：[1,1,2,3,4,4]
输入：l1 = [], l2 = []			输出：[]
输入：l1 = [], l2 = [0]		输出：[0]
```

#### 思路：

最开始看到题目想到的是新建第三个链表L3，然后将值依次填到L3中，应该可以实现。但是编码失败，问题出在函数出入口上，条件和语句顺序处理不好。（也有可能是直接用头节点往下遍历，应该在头节点前加一个pre节点）    **最终实现了！！！ 之前没有实现的原因在于，没设pre节点，导致遍历结束之后多一个空节点**

上述方法的简化是，不用给L3填值，而是直接用一个pre节点，将L1，L2所有节点按照val的大小串起来，最终返回pre.next就行。

递归也可实现，使用递归时，考虑：递归的出口、子问题是什么。 理解较难，但是理解后就很通透。

#### 题解：

1、迭代：（使用L3）

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode prehead = new ListNode(-1);
        //prev节点，使用prev就会简化很多过程
        ListNode prev = prehead;
       	//没必要提前处理l1 或者 l2 为空，因为最终都要处理
        while (l1 != null && l2 != null) {
            //l1的当前val小,则prev直接串上该节点，而不是赋值
            //l1 后移
            if (l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            //prev 后移，后移到哪无所谓
            prev = prev.next;
        }
        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 == null ? l2 : l1;
        return prehead.next;
    }
}
```

2、递归

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230422095516053.png" alt="image-20230422095516053" style="zoom: 67%;" />

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
		//递归出口
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else if (l1.val < l2.val) {
            //当l1的val小时，该节点就相当于被处理了
            //只需要考虑l1和l2剩下的节点
            //l1.next就是将该节点和剩下的节点连接起来
            l1.next = mergeTwoLists(l1.next, l2);
            //当之后的所有节点处理完时，需要返回该节点，与之前的所有节点相连
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}

```



## day 4

### 22. 括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

```
输入：n = 3		输出：["((()))","(()())","(())()","()(())","()()()"]
输入：n = 1		输出：["()"]
```

#### 思路：

看到所有可能的组合，考虑使用回溯。这一类问题是在一棵隐式的树上求解。

**注意**：在从空生成一个括号序列的过程中，左括号数量一定是大于等于右括号数量的。否则生成的括号组合是无效的。

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230423095529327.png" alt="image-20230423095529327" style="zoom: 67%;" />

可以分析出的结论：

当前左右括号数量都不为n的时候，才产生分支；
产生左分支的时候，只看当前左括号数量是否为n；
产生右分支的时候，还受到左分支的限制，右边的括号数量一定得在严格小于左边数量的时候，才可以产生分支；
在左边和右边的括号数都等于 n 的时候结算。



使用到剪枝函数。此思路学习某个答主的，甚妙甚妙。

https://leetcode.cn/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/

答主还有其他解法，有空再看。

#### 题解：

```java
public List<String> generateParenthesis(int n) {
        //看到所有情况的时候，使用回溯
        List<String> result = new ArrayList<>();
        if (n <= 0) {
            return result;
        }
        dfs("", 0, 0, n, result);
        return result;
    }

    public void dfs(String cur, int left, int right, int n, List<String> result) {
        //设置递归出口
        if (left == n && right == n) {
            result.add(cur);
            return;
        }
        //当右括号多于左括号时，剪枝
        if (left < right) {
            return;
        }
		//此时，左括号数量一定大于右括号数量
        //因此可以加上一个左括号，然后继续递归
        if (left < n) {
            dfs(cur + "(", left + 1, right, n, result);
        }
		//右括号数量小于左括号数量
        if (right < n) {
            dfs(cur + ")", left, right + 1, n, result);
        }

    }
```

递归执行流程见上图箭头指向。



## day 5

### 23. 合并 K 个升序链表

给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6

输入：lists = []		输出：[]
输入：lists = [[]]		输出：[]

```

#### 思路：

合并读个链表到一个链表中可以这样考虑：

（1）用一个目标链表和数组中的每一个链表进行合并，每次得到一个升序链表，再用这个升序链表和数组中的下一个合并，最终合并完所有的。这个思路相对简单，两个链表合并day 3也已经做过。（但是效率低）

（2）对（1）进行优化，分治，两两合并，两两合并.....最终子问题的结果汇总就是题目的解

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png" alt="img" style="zoom: 50%;" />

（3）优先队列：简单明了。一个队列中存放数组中每个链表的头节点，根据val的值进行优先级排序，val小的优先级高。每次优先级高的先出队，该节点指针向后移，将该链表的下一个节点放入队列中。

知道队列为空，所有的链表都处理完成。

#### 题解：

1、依次合并

```java
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode result = new ListNode();
        for (ListNode listNode:
             lists) {
            //result和数组中的每一项进行合并
            result = mergeTwo(result, listNode);
        }
        return null;
    }
    public ListNode mergeTwo(ListNode l1, ListNode l2) {
        ListNode l3 = new ListNode(-1);
        ListNode pre = l3;
        while (l1 != null && l2 != null) {
            pre.next = new ListNode();
            if (l1.val <= l2.val) {
                pre.next = l1;
                l1 = l1.next;
            } else {
                pre.next = l2;
                l2 = l2.next;
            }
            pre = pre.next;
        }
        pre.next = l1 == null ? l2 : l1;
        return l3.next;
    }
```

2、分治

```java
public ListNode mergeLists(ListNode[] lists) {

        //两两配对进行合并，一直合并到只剩一个ListNode
        //分治自顶向下，一层一层划分
        //因此，从首尾开始，往下分解问题
        //分解到只有单个节点时返回，然后进两两merge
        //子问题的解交给上层，再进行两两merg
        //最终得到问题的解
        int length = lists.length;
        return merg(lists, 0, length -1);
    }

    public ListNode merg(ListNode[] lists, int l, int r) {

        //递归出口
        //子问题无法再分
        if (l == r) {
            return lists[l];
        }
        //防止出现[]这种情况，此时length为-1
        if (l > r) {
            return null;
        }
        int mid = (l + r) / 2;
        return mergeTwo(merg(lists, l, mid), merg(lists, mid + 1, r));
    }

    public ListNode mergeTwo(ListNode l1, ListNode l2) {
        ListNode l3 = new ListNode(-1);
        ListNode pre = l3;
        while (l1 != null && l2 != null) {
            pre.next = new ListNode();
            if (l1.val <= l2.val) {
                pre.next = l1;
                l1 = l1.next;
            } else {
                pre.next = l2;
                l2 = l2.next;
            }
            pre = pre.next;
        }
        pre.next = l1 == null ? l2 : l1;
        return l3.next;
    }
```

3、优先队列

```java
public ListNode mergKLists(ListNode[] list3) {
        if (lists == null || lists.length == 0) {
            return null;
        }
        ListNode result = new ListNode();
        ListNode pre = result;
    	//优先队列，根据val的值，val值越小，对应的节点在队列中优先级越高
        PriorityQueue<ListNode> queue = new PriorityQueue<>(lists.length, new Comparator<ListNode>() {
            @Override
            public int compare(ListNode o1, ListNode o2) {
                if (o1.val < o2.val) return -1;
                else if (o1.val == o2.val) return 0;
                else return 1;

            }
        });
		//所有链表头节点入队
        for (ListNode node : lists) {
            if (node == null) {
                continue;
            }
            queue.add(node);
        }
		//队列为空代表结束
        while (!queue.isEmpty()){
            //取出优先级最高的节点接在目标链表尾部，也就是val值最小的那个
            pre.next = queue.poll();
            //取到出队节点的下一个节点
            pre = pre.next;
            /
            if (pre.next != null){
                queue.add(pre.next);
            }
        }
        return result.next;
    }
```



## Day 6

### 31.下一个排列

arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。

#### 思路：

首先从后往前找，找出第一组nums[i] < nums[i + 1], 此时，**可以保证nums[i+1]以后是降序排列的。**

找到 nums[i] 后，就要把它往后换，换的那个数要比 nums[i] 大，并且保证它仅仅比 nums[i] 大，比 nums[i] 后边的其他数都小。  这样较为复杂，**换个思路**，    此时 nums[i] 后边已经是降序了，那么从 nums 末尾往前找第一个比nums[i] 大的就行。交换 nums[i] 和这个数， 然后将 i 位置后边的数重新升序排列。  

如果没找到 nums[i] < nums[i + 1] ，直接将数组倒序输出就行

图解较为明显：

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150509405.png" alt="image-20230425150509405" style="zoom: 50%;" />

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150532584.png" alt="image-20230425150532584" style="zoom:50%;" />

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150544910.png" alt="image-20230425150544910" style="zoom:50%;" />

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150600018.png" alt="image-20230425150600018" style="zoom:50%;" />

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150611569.png" alt="image-20230425150611569" style="zoom:50%;" />

#### 题解：

```java
public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
    	//找到nums[i] 小于 nums[i + 1]
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
    	//i >= 0 说明nums[i] < nums[i + 1]存在
        if (i >= 0) {
            int j = nums.length - 1;
            //从末尾找第一个大于nums[i]的数
            //此时可以保证是i以后的最小的满足条件的数
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            //交换位置
            swap(nums, i, j);
        }
    	//然后将 i 位置以后的进行升序排序
    	//如果此时 i < 0 ，说明nums本来就已经是降序，是最大的组合。
    	//因此返回 最小的组合 
        reverse(nums, i + 1);
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
	//因为已经保证了 i 位置以后是降序，则只需要前后不断交换就行
	//不需要双层循环
    public void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }
```

### 32. 最长有效括号

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

```
输入：s = "(()"	输出：2
解释：最长有效括号子串是 "()"

输入：s = ")()())"		输出：4
解释：最长有效括号子串是 "()()"

输入：s = ""
输出：0
```

#### 思路：

出现有关括号这种匹配问题的字眼，考虑用栈。该题就是在  day 2 20.有效的括号  那一题的基础上进行求解。

也就是说，字符串从前往后遍历，看哪些连着的字串能够匹配起来，匹配成功长度就增加，然后在所有能够匹配的相连子串中，找到最长的那个。

**该题目稍微有点不同的是**，入栈的不是括号而是对应的下标。 这样，就可以相对轻松的计算出能够匹配的子串的长度

描述一下算法流程：遍历给定的字符串，取每一位上的字符，首先，判断该字符是 '(' 还是 ')' ，如果是左括号，那就直接下标入栈，因为左括号不可能与前边的字符匹配。如果是右括号，则取出栈顶元素n， 判断 s.charAt(n) 是不是左括号，是就说明这两个匹配成功，成功就出栈，并用当前右括号的下标减去出栈后栈顶元素的数值（也就是没能匹配上的最后一个字符的下标），这样就计算出了当前相连的有效的子串的长度。然后继续往后，如果又有有效的子串，则又计算出它的长度，如果比之前的子串长，则选择这个。   直到遍历完整个字符串。

#### 题解：

```java
public static void longestValidParentheses2(String s) {
    //定义栈
	Deque<Integer> stack = new LinkedList<>();
	//最长有效子串长度
    int length = 0;
    //因为如果第一个字符就是 ) ，那么就需要出栈，但是此时栈为空就会出错
    //所以提前入栈一个-1
   	//还有一个作用是，当有效的子串在整个字符串首部时
    //需要用最后一个匹配的字符的下标减去栈顶元素，设置为-1才能满足条件
	stack.push(-1);
	for (int i = 0; i < s.length(); i++) {
        //遍历每一个字符
		char c = s.charAt(i);
        //如果是左括号说明不满足条件，直接入栈
		if (c == ')') {
			int top = stack.peek();
            //是右括号时，取出栈顶元素，判断是不是左括号，如果是则匹配成功，计算目前有效的子串的长度
            //判断top等不等于-1的目的是看当前栈是不是为空
			if (top != -1 && s.charAt(top) == '(') {
				stack.pop();
                //在所有有效的子串中拿最长的
				length = (i - stack.peek()) > length ? i - stack.peek() : length;
			} else {
                //如果栈顶元素不是左括号说明匹配失败，则直接入栈
				stack.push(i);
			}
		} else {
			stack.push(i);
		}
	}
	return length;
}
```



## Day 7

### 33. 搜索旋转排序数组

整数数组 `nums` 原本按升序排列，数组中的值 **互不相同** 。然后从某个位置阶段，将前边的部分拼接到后边。

给定一个target，在数组中查找，如果有，返回下标，没有返回-1。时间复杂度要求为 `O(log n)`

```
输入：nums = [4,5,6,7,0,1,2], target = 0		输出：4
输入：nums = [4,5,6,7,0,1,2], target = 3		输出：-1
输入：nums = [1], target = 0		输出：-1
```

#### 思路：

升序或者降序的数组中查找一个数，并且要求时间复杂度是`O(log n)`，就要使用二分查找。

但是这个题目是升序数组变换得到的，因此需要在二分查找的基础上进行补充修饰。

考虑，尽管这个数组已经不是升序数组了，但是，如果从中间截断，那么前半段和后半段一定有一个仍然是升序。所以针对前半段是升序和后半段是升序两种情况进行分别处理。 判断前半段是升序的条件是 nums[0] <= nums[mid] ，（因为数组中的值互不相同，因此这里的 = 是针对只有两个数的情况）。

判断target是在升序段还是非升序段，如果在升序段直接使用二分查找。如果是在非升序段，则继续二分，看哪段是升序，.....一直到找到target，或者是l  > r，说明没找到。程序结束

#### 题解：

```java
public int search(int[] nums, int target) {
        if (nums.length == 0) {
            return -1;
        }
        if (nums.length == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0;
        int r = nums.length - 1;
		
        while (l <= r) {
            int mid = (l + r) / 2;
            //找到了
            if (target == nums[mid]) {
                return mid;
            }
            //前半部分有序的情况
            if (nums[0] <= nums[mid]) {
                //说明target在有序的前半部分
                //直接使用二分查找
                if (target >= nums[0] && target < nums[mid]) {
                    r = mid - 1;
                } else {    //说明target不在前半部分
                    l = mid + 1;
                }
            } else {		//后半部分有序的情况
				//说明target在后半部分
                if (target > nums[mid] && target <= nums[r]) {     
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
```



### 34. 在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

```
输入：nums = [5,7,7,8,8,10], target = 8		输出：[3,4]
输入：nums = [5,7,7,8,8,10], target = 6		输出：[-1,-1]
输入：nums = [], target = 0		输出：[-1,-1]
```

#### 思路：

在数组中查找元素并且要求`O(log n)`的时间复杂度，用二分查找。

这个题有点变化的就是目标元素可能不止一个。 

解法一：用二分查找找到一个目标元素，然后向两边扩散，直到找到所有的目标元素，之后返回起始位置和结束位置。 如果target元素很多，甚至于整个数组都是target，则算法退化到 `O(n)`。

解法二：用二分查找找到第一个等于目标元素的，再二分查找找到第一个大于目标元素的（也就是找第一个大于等于 target + 1 的），然后就得到了解。（思路容易理解，但是编码不太容易理解）

#### 题解：

解法一：

```java
public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = (right + left) / 2;
            //找到了任意一个目标元素
            if (nums[mid] == target) {
                left = mid - 1;
                right = mid + 1;
 				//向左扩散
                while (left >=0 && nums[left] == target) {
                    left--;
                }
                //向右扩散
                while (right <= nums.length - 1 && nums[right] == target) {
                    right++;
                }
                return new int[]{++left, --right};
            }
            //二分查找
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    	//没找到就返回[-1, -1]
        return new int[]{-1, -1};
    }
```

解法二：

```java
public static int[] searchRange2(int[] nums, int target) {
		//查找大于等于target的第一个元素，如果target存在，返回的就是开始位置，如果不存在，返回的是第一		  //个比target大的元素的位置
        int begin = binarySearch(nums, target);
    	//查找大于target的第一个元素（即大于等于 target + 1 的第一个元素）
        int end = (binarySearch(nums, target + 1) - 1);
    	//如果查到的位置满足左小于等于右，并且开始和结束位置的元素都是target，则证明查找成功，返回
        if (begin <= end && nums[begin] == target && nums[end] == target) {
            return new int[]{begin, end};
        }
        return new int[]{-1, -1};
    }

    public static int binarySearch(int[] nums, int target) {
        int length = nums.length;
        int l = 0;
        int r = length - 1;
        int ans = length - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] >= target) {
                r = mid - 1;
                ans = mid;
            } else {
                l = mid + 1;
            }
        }
        return ans;
    }
```



### 39. 组合总和

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

```
输入：candidates = [2,3,6,7], target = 7		输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

#### 思路：

所有组合，出现类似字眼考虑回溯。画出解空间树：

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/1598091943-hZjibJ-file_1598091940241.png" alt="img" style="zoom: 25%;" />

从根节点出发，将所有小于根节点大小的candidates元素作为子节点，小于就说明该子节点可能是有效解的一部分，将该子节点数值加入res中，此时target变成 target - 该子节点 ，然后以该子节点为根节点重复上述过程，直到叶子节点。达到叶子节点时有两种情况，一种是target恰好为零，说明此时res中的所有节点大小加起来刚好是原始的target，则是一个有效的解。另一种情况是target不为零，则不是有效解，此时需要回到当前叶子节点的父节点，也就是回溯，需要把当前叶子节点从res中删除。深度优先搜索直到拿到所有有效解。

这里存在一个问题是，[2, 2, 3] 和 [3, 2, 2] 这两条路径是重复的解，需要处理。如何处理呢？ 因为确定子节点的时候是遍历candidates数组，因此在确定该节点的子节点时，要排除掉该节点之前的兄弟节点。（因为之前的兄弟节点在求解过程中，肯定会将该节点作为子节点）

#### 题解：

```java
   public static List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> res = new ArrayList<>();
       	//start的作用就是在确定某个节点子节点的时候，排除掉之前出现过的兄弟节点
        int start = 0;
        dfs(candidates, target, res, ans, start);
        return ans;
    }

    public static void dfs(int[] candidates, int target, List<Integer> res, List<List<Integer>> ans, int start) {
        //递归出口
        //此时target变为了0，说明此路径上的所有节点值加起来为target，是一个有效解
        if (target == 0) {
            //不能使用ans.add(res)
            //因为res是地址，虽然地址一直不会变
            //但是由于回溯的原因，res的内容最终为[]
            ans.add(new ArrayList<>(res));
            return;
        }
		//i = start 就排除了已经处理过的兄弟节点
        for (int i = start; i < candidates.length; i++) {
            //满足成为有效解一部分的条件
            if (candidates[i] <= target) {
                res.add(candidates[i]);
                dfs(candidates, target - candidates[i], res, ans, i);
                //回溯
                res.remove(res.size() - 1);
            }
        }
    }
```



## Day 8

### 46. 全排列

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```
输入：nums = [1,2,3]		输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
输入：nums = [0,1]		输出：[[0,1],[1,0]]
```

#### 思路：

所有可能的全排列，考虑回溯。

执行过程

```
  递归之前 => [1]
  递归之前 => [1, 2]
  递归之前 => [1, 2, 3]
递归之后 => [1, 2]
递归之后 => [1]
  递归之前 => [1, 3]
  递归之前 => [1, 3, 2]
递归之后 => [1, 3]
递归之后 => [1]
递归之后 => []
  递归之前 => [2]
  递归之前 => [2, 1]
  递归之前 => [2, 1, 3]
递归之后 => [2, 1]
递归之后 => [2]
  递归之前 => [2, 3]
  递归之前 => [2, 3, 1]
递归之后 => [2, 3]
递归之后 => [2]
递归之后 => []
  递归之前 => [3]
  递归之前 => [3, 1]
  递归之前 => [3, 1, 2]
递归之后 => [3, 1]
递归之后 => [3]
  递归之前 => [3, 2]
  递归之前 => [3, 2, 1]
递归之后 => [3, 2]
递归之后 => [3]
递归之后 => []
输出 => [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
```



#### 题解：

```java
    public List<List<Integer>> permute(int[] nums) {
  
        if (nums.length == 0) {
            return new ArrayList<>();
        }
        List<Integer> ans = new ArrayList<>();
        List<List<Integer>> res = new ArrayList<>();
        dfs(nums, ans, res, 0);
        return res;
    }

    public void dfs(int[] nums, List<Integer> ans, List<List<Integer>> res, boolean[] used, int size) {
        //递归出口，size代表遍历解空间树的深度
        if (size == nums.length) {
            res.add(new ArrayList<>(ans));
            return;
        }
		//每次递归i都要从0开始
        //这样才能让nums中的每一个元素都能做ans的头元素
        for (int i = 0; i < nums.length; i++) {
            //判断当前元素是不是已经被加入了ans中
            //也可以使用used[]数组表示当前元素是否被使用过  来代替 contains
            if (!ans.contains(nums[i])) {
                //如果没有则加入，并递归搜索子树
                ans.add(nums[i]);
                dfs(nums, ans, res, used, size + 1);
                //回溯
                ans.remove(ans.size() - 1);
            }
        }
    }
```



### 48. 旋转图像

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230502101338537.png" alt="image-20230502101338537" style="zoom: 50%;" />

#### 思路：

1. 使用一个额外的矩阵进行转换，观察发现第一行变成了最后一列，第二行变成了倒数第二列.....
2. 先将矩阵上下翻转，然后对角翻转

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230502101554478.png" alt="image-20230502101554478" style="zoom:50%;" />

#### 题解：

1、额外矩阵

```java
public void rotate2(int[][] matrix) {
        int n = matrix.length;
        int[][] res = new int[n][n];
    	//矩阵的第一行变成了倒数第一列，第二行变成了倒数第二列....
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                res[j][n - i - 1] = matrix[i][j];
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = res[i][j];
            }
        }
    }
```

2、原地变换翻转

```java
public void rotate(int[][] matrix) {
        int length = matrix.length;
    	//上下翻转
        for (int i = 0; i < length / 2; i++) {
            for (int j = 0; j < length; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[length - i - 1][j];
                matrix[length - i - 1][j] = temp;
            }
        }
    	//沿对角线翻转
        for (int i = 0; i < length; i++) {
            for (int j = i; j < length; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
```



### 49. 字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

#### 思路：

字母异位体排列虽有不同，但是组成的字符种类（只有小写字母）以及各个字符的数量是完全一致的，因此可以考虑：

1. 将字符串的所有字符进行排序，这样的话只要时字母异位体，排序后是完全一样的，对应的哈希值也是一样的。这时就可以使用HashMap，将排序后hash值相同的字符串收集在一块。
2. 统计26个字母每一个的数量，最终所有字母的数量都相等的字符串收集在一起

#### 题解：

1、hash

```java
    public List<List<String>> groupAnagrams(String[] strs) {

        Map<String, List<String>> map = new HashMap();
        
        for (String str :
                strs) {
            //字符串转为char数组
            char[] chars = str.toCharArray();
            //排序
            Arrays.sort(chars);
            //重新转为String，因为相同内容的String哈希值相同，而相同内容的char数组哈希值不同
            s = new String(chars);
            //如果此哈希值已经有先例，则拿出对应的List
            //如果没有，即此字符串是第一次，则新建一个ArrayList
            //getsOrDefault方法：如果key有对应的value，则返回，如果没有，则返回设定的默认值
            List<String> list = map.getOrDefault(s, new ArrayList<>());
            //注意，add的是str，而不是s
            list.add(str);
            //key设置的是排序后的zi'fu'hcu	
            map.put(s, list);
        }
        
        return new ArrayList<List<String>>(map.values());
    }
```



## Day 9

### 53. 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**子数组** 是数组中的一个连续部分。

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]		输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

#### 思路：

1、暴力解，求出该数组每一个子数组的和，取最大值，但这样时间复杂度太高。

2、动态规划：

求解出以数组中每一个元素为结尾的最大连续子数组和dp[i] ，例如 以 -2 为结尾的最大连续子数组 dp[0] 和为 -2 ， 以 1 为结尾的最大连续子数组和 dp[1] 为 1 （因为前边以 -2 为结尾的最大连续子数组和小于0 ）....

总结规律发现，以 nums[i] 为结尾的最大连续子数组和 dp[i] ，取值取决于以 nums[i-1] 为结尾的最大连续子数组和 dp[i-1] ， 当 dp[i -1] > 0 时，dp[i] = dp[i-1] + nums[i] ;  当 dp[i-1] <= 0 时， dp[i] = nums[i] ;

这样的话，我们自底向上，保存每一个子问题解的 dp[i] , 最终取其中的最大值，就可以求出问题的解。

#### 题解：

```java
public int maxSubArray(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len];
    	//以第一个元素为结尾的连续子数组的和
        dp[0] = nums[0];
        int res = dp[0];
        for (int i = 1; i < len; i++) {
            //这个子问题的解依赖于上一个子问题的解
            dp[i] = dp[i - 1] > 0 ? dp[i - 1] + nums[i] : nums[i];
            res = dp[i] > res ? dp[i] : res;
        }
        return res;
    }
```

优秀解答：https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/



###  [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

#### 思路:

如果能到达每一个下标，则该下标之前的所有下标都可以达到。

从前往后遍历，更新整个数组能达到的最远距离，如果最远距离大于等于数组 length - 1 ，则说明能够到达最后一个下标。

#### 题解：

```JAVA
    public boolean canJump(int[] nums) {
        int len = nums.length;
        //到达的最远位置
        int maxIndex = 0;
        for (int i = 0; i <= len - 1; i++) {
            //如果此时遍历到的位置 i 已经大于 该数组能达到的最远距离maxIndex，说明越界了，直接返回				//false
            if (i > maxIndex) {
                return false;
            }
            //取最远的距离
            maxIndex = Math.max(i + nums[i], maxIndex);
            //如果能够到达的最远位置已经超过了数组结尾，则直接返回true
            //不要该判断也可以，只要 i 能遍历到数组结尾，说明成功了
            //这个判断的作用在于满足条件后直接返回，免去了后续
            if (maxIndex >= len - 1) {
                return true;
            }
        }
        	//
            return true;
    }
```



### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

#### 思路：

首先把intervals数组按每个区间开始的值从小打到排列。新造一个数组 res\[][] 用来存放答案，先把第一个区间赋值给 res[0] ，然后，遍历剩下的所有区间。判断每一个区间的开始是否小于等于 res[index] 的结束，是的话说明该区间和 res[index] 区间有重合，则合并，将 res[index] 的结束更新为这两个重合区间的最右边。如果不是则说明不重合，index++，直接将该区间赋值给res[index] 

#### 题解：

```java
public int[][] merge1(int[][] intervals) {
    	//先把intervals排序
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });
        int[][] res = new int[intervals.length][2];
    	//先把第一个区间赋值给 res[0] 
        res[0][0] = intervals[0][0];
        res[0][1] = intervals[0][1];
        int index = 0;
        for (int i = 1; i <= intervals.length - 1; i++) {
            //有重合
            if (res[index][1] > intervals[i][0]) {
                //区间的末尾取最右边
                res[index][1] = Math.max(intervals[i][1], res[index][1]);
            } else {
                //没重合
                index++;
                res[index][0] = intervals[i][0];
                res[index][1] = intervals[i][1];
            }
        }
    	//可以使用 res = Arrays.copyOfRange(res, 0, index+1);  替换
    	//但是Arrays.copyOfRange费时
        int[][] res1 = new int[index + 1][2];
        for (int i = 0; i < index + 1; i++) {
            res1[i] = res[i];
        }
        return res1;
    }
```



### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

![img](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/robot_maze.png)

```
输入：m = 3, n = 7			输出：28
```

#### 思路：

1、动态规划

从Finish往回看，可以走到Finish的只有上和左两个方块，因此到Finish的路径数量就等于 两个方块的路径和。....所以子问题就分析出来，求到某个块的路径数量，只需要求前置块的路径数量，然后加和。

边界就是起点。 需要注意的是，最上面和最左边的一行一列，所有块的路径数量都是1。

2、数学公式

因为规定了只能往下和往右，因此无论怎样走，向下走的都是3-1格，向右走的都是7-1格，总共是走8格。

所以只需要在8格中任意选两个向下就可以列出所有结果。
$$
C_{m+n-2}^{m-1}
= 
{(m+n−2)(m+n−3)⋯n
\over(m−1)!}
= 
{(m−1)!(n−1)!
\over(m+n−2)!}
$$

#### 题解：

1、动态规划

```java
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                //最上面一行
                if (i == 0) {
                    dp[i][j] = 1;
                    continue;
                }
                //最左边一列
                if (j == 0) {
                    dp[i][j] = 1;
                    continue;
                }
                //上面的块和左边的块的路径和为当前块的路径和
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m-1][n-1];
    }
```

2、数学公式：

```java
public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
```



### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。	**说明：**每次只能向下或者向右移动一步。

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/minpath.jpg" alt="img" style="zoom:50%;" />

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]		输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

#### 思路：

动态规划

#### 题解：

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0) {
                    dp[i][j] = grid[i][j];
                    continue;
                }
                if (i == 0) {
                    dp[i][j] = dp[i][j - 1] + grid[i][j];
                    continue;
                }
                if (j == 0) {
                    dp[i][j] = dp[i - 1][j] + grid[i][j];
                    continue;
                }
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
}
```



### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

#### 思路：

最简单的动态规划问题

#### 题解：

```java
class Solution {
    public int climbStairs(int n) {
        if(n == 1){
            return 1;
        }
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n - 1];
    }
    
    //简化
    public int climbStairs(int n) {
        int p = 1;
        int q = 1;
        int res = 1;
        for (int i = 1; i < n; i++) {
            res = p + q;
            p = q;
            q = res;
        }
        return res;
    }
}
```



## Day 10

### [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。必须在不使用库内置的 sort 函数的情况下解决这个问题。

#### 思路：

1、两次遍历，设置有序界限index。第一次将所有的 0 移动到头部，每次移动更新 index的值。第二次将所有的 1 移动到 0 后面。

2、一次遍历，两个指针。设置指针p0、p1，初始值为0，代表 0 和 1 的放置位置。遍历时，如果 nums[i] 为 0 则与 nums[p0] 交换；如果为1， 则先判断 p1 > p0 是否成立，不成立先令 p1 = p0 , 然后交换 nums[i] 和 nums[p1] 。因为如果 p1 <= p0 , 说明前边都是 0 ，p1首先需要移动到 0 后面。

#### 题解：

1、两次遍历：

```java
    public void sortColors(int[] nums) {
        int index = 0;
        //把 0 放在最头部
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                    int temp = nums[index];
                    nums[index] = nums[i];
                    nums[i] = temp;
                    index++;
            }
        }
        // 1 放在 0 后面
        for (int i = index; i < nums.length; i++) {
            if (nums[i] == 1) {
                int temp = nums[index];
                nums[index] = nums[i];
                nums[i] = temp;
                index++;
            }
        }
    }
```

2、两个指针：

```java
   public void sortColors2(int[] nums) {
        int p0 = 0;
        int p1 = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                int temp = nums[i];
                nums[i] = nums[p0];
                nums[p0++] = temp;
            }
            if (nums[i] == 1) {
                if (p1 < p0) {
                    p1 = p0;
                } else {
                    int temp = nums[i];
                    nums[i] = nums[p1];
                    nums[p1++] = temp;
                }
            }
        }
    }
```



### [78. 子集](https://leetcode.cn/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```



#### 思路：

看到 **所有** 这类的字眼，考虑回溯，这个题目需要将解空间树的每一个节点都保存下来。

#### 题解：

```java
    public List<List<Integer>> subsets3(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        //空集
        res.add(list);
        dfs2(res, list, nums, 0);
        return res;
    }nn

    public void dfs2(List<List<Integer>> res, List<Integer> list, int[] nums, int index) {
        //叶子节点之后就返回
        if (index == nums.length) {
            return;
        }
        for (int i = index; i < nums.length; i++) {
            //每一个节点都要保存
            list.add(nums[i]);
            res.add(new ArrayList(list));
            //递归该节点的子树
            dfs(res, list, nums, i + 1);
            //回溯
            list.remove(list.size() - 1);
        }
    }
```



### [79. 单词搜索](https://leetcode.cn/problems/word-search/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230505174059190.png" alt="image-20230505174059190" style="zoom:50%;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```



#### 思路：

深度优先搜索 + 回溯

先找出 board 中所有跟 word 第一个字符相等的位置，进入深度优先递归搜索环节，每到一个位置，上下左右判断有没有跟 word 下一个字符相等的，有就再搜索，直到搜索的深度等于 word 的长度，说明搜索到了，设置标志位为1 ，不能直接return true ；因为return是给上一层调用者，而不是返回最终结果。   因为题目说字母不能重复使用，因此设置 isUsed 二维数组，为0代表board该位置未使用过。

#### 题解：

```java
    public boolean exist(char[][] board, String word) {

        int row = board.length;
        int col = board[0].length;
        int[] flag = new int[]{0};

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                //每次从头查找isUsed数组都要重新归零
                int[][] isUsed = new int[row][col];
                //找到了word的第一个字符
                if (word.charAt(0) == board[i][j]) {
                    //表示该位置已被使用
                    isUsed[i][j] = 1;
                    //递归搜索
                    dfs(board, word, i, j, 1, flag, isUsed);
                    //如果 flag[0] 被修改为 1， 说明搜索过程中一定找到过 word
                    if (flag[0] == 1) {
                        return true;
                    }
                }
            }
        }

        return false;

    }

    public void dfs(char[][] board, String word, int i, int j, int index, int[] flag, int[][] isUsed) {
        //查找的深度等于word的长度，说明找到了
        if (index == word.length()) {
            flag[0] = 1;
            return;
        }
        //往左走
        //往左走时需要注意：左边还有没有，左边的字符等不等于word的下一个字符，左边的字符有没有被使用过
        //往左往右往上往下这四步可以优化，简化写法和执行流程，但是本人懒得搞了
        if (j - 1 >= 0 && board[i][j - 1] == word.charAt(index) && isUsed[i][j-1] == 0) {
            isUsed[i][j-1] = 1;
            dfs(board, word, i, j - 1, index + 1, flag, isUsed);
            //回溯时，回溯的位置需要重新标识为未使用
            isUsed[i][j-1] = 0;
        }
        //往右走
        if (j + 1 <= board[0].length - 1 && board[i][j + 1] == word.charAt(index) && isUsed[i][j+1] == 0) {
            isUsed[i][j+1] = 1;
            dfs(board, word, i, j+1, index + 1, flag, isUsed);
            isUsed[i][j+1] = 0;
        }
        //往上走
        if (i - 1 >= 0 && board[i - 1][j] == word.charAt(index) && isUsed[i-1][j] == 0) {
            isUsed[i - 1][j] = 1;
            dfs(board, word, i - 1, j, index + 1, flag, isUsed);
            isUsed[i - 1][j] = 0;
        }
        //往下走
        if (i + 1 <= board.length - 1 && board[i + 1][j] == word.charAt(index) && isUsed[i+1][j] == 0) {
            isUsed[i+1][j] = 1;
            dfs(board, word, i + 1, j, index + 1, flag, isUsed);
            isUsed[i+1][j] = 0;
        }
    }
```



### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

####  思路：

二叉树遍历就是递归，先序、中序、后续几乎一样，只是保存值的位置有点区别。

#### 题解：

```java
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root != null) {
            search(root, res);
        }
        return res;
    }

    public void search(TreeNode node, List<Integer> res) {
        if (node == null) {
            return;
        }
        //遍历左子树
        search(node.lft, res);
		//保存
        res.add(node.val;
        //遍历右子树
        search(node.rght(), res);
    }
                
                
//先序
        res.add(node.val);
       	search(node.lft, res);
        search(node.rght(), res);
                
//后序

       	search(node.lft, res);
        search(node.rght(), res);
        res.add(node.val);
```



## Day11

### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230508112035813.png" alt="image-20230508112035813" style="zoom:50%;" />

#### 思路：

二叉搜索树：从根节点，大的在左子树，小的在右子树。

n个节点组成二叉搜索树，首先，n个节点每一个都可以作为根节点。当 i 作为根节点时，从1 - （i-1）都在左子树，（i+1） - n 都在右子树。考虑此时的左子树，从 1 - （i-1）都可以作为根节点，依次往下，每层子树的构建过程的一样。最终会到叶子节点，0个左子树，0个右子树。 是一个动态规划问题。子问题的解结合起来构成问题的解。

设 G(n) 是 n 个节点可以组成的二叉树搜索树的个数。

设 F(i) 是以 i 为根节点，n个节点可以组成的二叉搜索树的个数。

可以发现，G(n) = F(1) + F(2) + ······ + F(n) 

而 F(i) = G(i-1) * G(n-i)          **原因**：以 i 为节点时， 左子树有 i-1 个节点，这 i-1 个节点可以组成 G(i-1) 个二叉搜索树。右子树有 n-i 个节点，这 n-i 个节点可以组成 G(n-i) 个二叉搜索树。因此，以 i 为根节点的二叉搜索树的个数是 左子树个数 乘以 右子树个数

因此  G(n) = G(1-1)G(n-1) + G(2-1)G(n-2) + ······ + G(n-1)G(n-n)

要求 G(n) 必须先求 G(n-1) G(n-2) ·····G(2) G(1) G(0)

要求 G(n-1) 必须先求 G(n-2) G(n-3) ······ G(1) G(0)

······  因此，这是一个动态规划问题，G(0)、G(1) 很明显为 1 (**备注：G(0) 为1是因为左边没有子树也算一种情况**) 

,G(2) 可以由 G(1)、G(0) 求得，G(3) 可以由 G(2)、G(1)、G(0) 求得 ·······



#### 题解：

```java
    public int numTrees(int n) {
        int[] G = new int[n+1];
        //已知的
        G[0] = 1;
        G[1] = 1;
		//从G(2)开始算起，一直算到G(n),只有G(i-1)知道了，才能求解G(i)
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                G[i] += G[j - 1] * G[i - j];
            }
        }
        return G[n];
    }
```



### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

#### 思路：

1、广度优先遍历 BFS，使用队列，每一层从左到右入队，出队时下面一层又入队。

2、使用map，dep记录当前节点所处的深度，遍历所有节点，同一深度的所有节点使用 map.put(dep, list) 加到同一个List中。最后，拿出map中所有的key。

#### 题解：

1、BFS

```java
	public List<List<Integer>> levelOrder(TreeNode root) {
        //广度优先遍历 -> 使用队列
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        //队列不为空就一直出队
        while (!queue.isEmpty()) {
            List<Integer> list = new ArrayList<>();
            //队列中当前的节点数
            int n = queue.size();
            //这些节点都位于同一层
            for (int i = 0; i < n; i++) {
                TreeNode node = queue.poll();
                list.add(node.getVal());
                if (node.getLeft() != null) {
                    queue.offer(node.getLeft());
                }
                if (node.getRight() != null) {
                    queue.offer(node.getRight());
                }
            }
            res.add(list);
        }
        
        return res;
    }
```

2、记录深度

```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Map<Integer, List<Integer>> map = new HashMap<>();
        dfs(root, map, 0);
        for (List<Integer> value : map.values()) {
            res.add(value);
        }

        return res;
    }

    public void dfs(TreeNode node, Map<Integer, List<Integer>> map, int dep) {
        if (node == null) {
            return;
        }
        //深度增加
        dep++;
		//当前深度对应的list,如果没有就新建一个
        List<Integer> integers = map.getOrDefault(dep, new ArrayList<>());
        integers.add(node.getVal());
        map.put(dep, integers);

        dfs(node.getLeft(), map, dep);
        dfs(node.getRight(), map, dep);
    }
```

