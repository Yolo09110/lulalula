

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lpx">
  <meta name="keywords" content="">
  
    <meta name="description" content="算法笔记（LeetCode） 算法知识：1、回溯算法：（递归实现）回溯算法是穷举的一种改进，回溯算法依然会列举所有可能的结果（没有剪枝函数的情况下）。 它是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回到上一步，重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 回溯算法在包含所有解的">
<meta property="og:type" content="article">
<meta property="og:title" content="Yolo">
<meta property="og:url" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Yolo">
<meta property="og:description" content="算法笔记（LeetCode） 算法知识：1、回溯算法：（递归实现）回溯算法是穷举的一种改进，回溯算法依然会列举所有可能的结果（没有剪枝函数的情况下）。 它是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回到上一步，重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 回溯算法在包含所有解的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yolo-img.oss-cn-beijing.aliyuncs.com/img/v2-368ff92d458bc2e3ae6eed63d550d75e_1440w.webp">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDEzNjI5,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230420135137788.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230421103030482.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/baa8829ac398e665eb645dca29eadd631e2b337e05022aa5a678e091471a4913-20.gif">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/merge_ex1.jpg">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230422095516053.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230423095529327.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150509405.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150532584.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150544910.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150600018.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150611569.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/1598091943-hZjibJ-file_1598091940241.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230502101338537.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230502101554478.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/robot_maze.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/minpath.jpg">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230505174059190.png">
<meta property="og:image" content="http://example.com/2023/11/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230508112035813.png">
<meta property="article:published_time" content="2023-11-09T02:59:33.364Z">
<meta property="article:modified_time" content="2023-11-09T09:17:30.797Z">
<meta property="article:author" content="Lpx">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yolo-img.oss-cn-beijing.aliyuncs.com/img/v2-368ff92d458bc2e3ae6eed63d550d75e_1440w.webp">
  
  
  
  <title>Yolo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"CdrmGVSpBdC5RxmCwvpa4qZB-gzGzoHsz","app_key":"7s5o0uXg54vyI98408Q967HX","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yolo</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-09 10:59" pubdate>
          2023年11月9日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          34k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          287 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <p>算法笔记（LeetCode）</p>
<h2 id="算法知识："><a href="#算法知识：" class="headerlink" title="算法知识："></a>算法知识：</h2><h3 id="1、回溯算法：（递归实现）"><a href="#1、回溯算法：（递归实现）" class="headerlink" title="1、回溯算法：（递归实现）"></a>1、回溯算法：（递归实现）</h3><p>回溯算法是穷举的一种改进，回溯算法依然会列举所有可能的结果（没有剪枝函数的情况下）。</p>
<p>它是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回到上一步，重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>回溯算法在包含所有解的解空间树中，采取深度优先的策略，从根节点出发。</p>
<p>剪枝函数：<img src="http://yolo-img.oss-cn-beijing.aliyuncs.com/img/v2-368ff92d458bc2e3ae6eed63d550d75e_1440w.webp" srcset="/img/loading.gif" lazyload alt="v2-368ff92d458bc2e3ae6eed63d550d75e_1440w"></p>
<p>简单来说，某个节点出现后已经不满足要求，那这个节点和后续的所有子节点都没有必要再探索，此时需要“剪掉”该枝</p>
<h3 id="2、链表和栈"><a href="#2、链表和栈" class="headerlink" title="2、链表和栈"></a>2、链表和栈</h3><p>链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br>    <br>    ListNode() &#123;&#125;<br><br>    ListNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br><br>    ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123; <span class="hljs-built_in">this</span>.val = val; <span class="hljs-built_in">this</span>.next = next; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>在使用链表时，最好加一个pre节点指向头节点</strong></p>
<p><strong>在连接节点时，要注意改变的是当前指针的next，而不是当前指针，不然只是修改了指针的指向，连接不上</strong></p>
<p>栈：<br>目前，已经用Deque代替了Stack，原因在于Stack效率低，并且只是简单的栈。而Deque作为万能接口，可以作为栈、队列等，只要程序员想。</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDEzNjI5,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%;" />

<p>（因为Vector是当初JAVA曾经写得不太行的类，所以Stack也不太行。</p>
<p>Vector不行是因为效率不太行，很多方法都用了synchronized修饰，虽然线程安全，但是像ArrayDeque,LinkedList这些线程不安全的，在需要安全的时候也可以用Collections.synchronizedCollection()转化成线程安全的，所以Vector就没什么用处了）</p>
<p>Deque常用的方法：</p>
<p>​	当栈用：push()、pop()、peek()等，peek()函数是用来取栈顶元素的值，但不弹出。</p>
<p>​	当队列用：入队offer()、出队poll()</p>
<h3 id="3、分治思想（自顶向下）"><a href="#3、分治思想（自顶向下）" class="headerlink" title="3、分治思想（自顶向下）"></a>3、分治思想（自顶向下）</h3><p>将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>（1）分治的策略：</p>
<p>​		对于一个规模为n的问题，若该问题可以容易的解决(比如规模n较小)则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，<strong>递归</strong>地解决这些子问题，然后将各个子问题的解合并得到原问题的解。</p>
<p>​		如果原问题可以分割成k个子问题，1&lt;k&lt;&#x3D;n，且这些子问题均可解并且利用这些子问题的解求出原问题的解，那么分治方法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归经常同时应用在算法设计之中。</p>
<p>（2）使用场景：</p>
<ul>
<li>该问题的规模缩小到一定的程度就可以容易的解决。</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。（基础）</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解。（关键）</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li>
</ul>
<p>（3）可以使用分治的场景：</p>
<p>二分搜索、大整数乘法、Strassen矩阵乘法、棋盘覆盖、合并排序、快速排序、线性时间选择、最接近点对问题、循环赛日程表、<strong>汉诺塔</strong></p>
<h3 id="4、动态规划"><a href="#4、动态规划" class="headerlink" title="4、动态规划"></a>4、动态规划</h3><p>动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p>
<p>（1）动态规划的核心思想：<strong>拆分子问题，记住过往，减少重复计算</strong>。</p>
<p>（2）动态规划一般是自底向上，从较小问题的解，逐步求出大的问题的解。大的问题的解依靠上一个最优的子问题的解</p>
<p>（3）动态规划有几个典型特征，<strong>最优子结构、状态转移方程、边界、重叠子问题</strong>。</p>
<p>​		最优子结构：假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质</p>
<p>可以使用动态规划的情况：<strong>最长递增子序列、最小编辑距离、背包问题、凑零钱问题</strong>等</p>
<p>相关文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365698607">看一遍就理解：动态规划详解 - 知乎 (zhihu.com)</a></p>
<h2 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h2><h3 id="17、电话号码的字母组合"><a href="#17、电话号码的字母组合" class="headerlink" title="17、电话号码的字母组合"></a>17、电话号码的字母组合</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230420135137788.png" srcset="/img/loading.gif" lazyload alt="image-20230420135137788"></p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">eg:<br>输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure>

<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>看到所有二字，就考虑用回溯算法。##为什么不用嵌套for循环呢，因为字符串的长度不确定，不知道要使用几层for。只能使用递归来实现</p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> String[] digit_map = &#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <br>        <span class="hljs-comment">//空字符串时</span><br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        &#125;<br>        backtrace(digits, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>());<br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>    <span class="hljs-comment">//以 2(a,b,c) 3(d,e,f)为例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> index, StringBuilder letter)</span> &#123;<br>        <span class="hljs-comment">//递归第一步：设置出口</span><br>        <span class="hljs-keyword">if</span> (index == str.length()) &#123;<br>            res.add(String.valueOf(letter));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//先拿到digits的第一个字符2, 寻找它的字符映射(a, b, c)</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(index);<br>        <span class="hljs-comment">//ASCII 32减去ASCII 32</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">map_letter</span> <span class="hljs-operator">=</span> digit_map[pos];<br>        <span class="hljs-comment">//拿到映射后，进行遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map_letter.length(); i++) &#123;<br>            letter.append(map_letter.charAt(i));<br>            backtrace(str, index + <span class="hljs-number">1</span>, letter);<br>            <span class="hljs-comment">//相对难点</span><br>            <span class="hljs-comment">//比如letter得到adg之后，下一个遍历的是h，此时就需要先把g先截掉</span><br>            letter.deleteCharAt(letter.length() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优秀解答：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/</a></p>
<h2 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h2><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>尝试使用一趟扫描实现</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230421103030482.png" srcset="/img/loading.gif" lazyload alt="image-20230421103030482" style="zoom: 67%;" />

<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>不考虑进阶时，最容易想到的是先遍历一遍链表，获得总长度，然后定位到n的位置，进行删除。</p>
<p><strong>但是</strong>，看到倒数类似的字眼，就考虑可以使用栈，因为栈可以后进的先出。</p>
<p>如果要求一趟扫描，也就是说不能退回或者重新来一遍，那么栈也就不能用了。此时就要使用<strong>快慢指针</strong>。</p>
<p><strong>快慢指针在链表相关问题中重要，需要掌握</strong></p>
<h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a><strong>题解</strong>：</h4><p>1、使用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>		<span class="hljs-comment">//使用pre,可以简单实现只有头指针单个节点，n为1时的情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    	<span class="hljs-comment">//cur指向pre而不是head，因为在后续出栈时，目标节点上一个节点也要得到才能完成</span><br>    	<span class="hljs-comment">//对目标节点的删除。针对的也是只有头节点的情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre;<br><br>    	<span class="hljs-comment">//所有节点入栈，包括pre</span><br>        Deque&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;ListNode&gt;();<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(cur);<br>            cur = cur.next;<br>        &#125;<br>    	<span class="hljs-comment">//弹出n个节点，最后一个弹出的恰好是目标节点</span><br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n--;<br>            stack.pop();<br>        &#125;<br>    	<span class="hljs-comment">//获取目标节点上一个节点</span><br>        cur = stack.peek();<br>    	<span class="hljs-comment">//删除</span><br>        cur.next = cur.next.next;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>2、快慢指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    <span class="hljs-comment">//快指针</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">ahead</span> <span class="hljs-operator">=</span> pre;<br>    <span class="hljs-comment">//慢指针</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">after</span> <span class="hljs-operator">=</span> pre;<br>    <span class="hljs-comment">//快指针先走n步</span><br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>    	n--;<br>        ahead = ahead.next;<br>    &#125;<br>    <span class="hljs-comment">//快慢指针一块走</span><br>    <span class="hljs-comment">//走到快指针所指节点的下一个节点为null时，慢指针恰好指向目标节点的上一个</span><br>    <span class="hljs-keyword">while</span> (ahead.next != <span class="hljs-literal">null</span>) &#123;<br>        ahead = ahead.next;<br>        after = after.next;<br>    &#125;<br>    <span class="hljs-comment">//删除</span><br>    after.next = after.next.next;<br>    <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span>		输出：<span class="hljs-literal">true</span><br>输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span>		输出：<span class="hljs-literal">true</span><br>输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span>		输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a><strong>思路</strong>：</h4><p>左右匹配问题直接用栈，栈使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Deque&lt;&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedList</span>()<br></code></pre></td></tr></table></figure>

<p>最开始想的是使用双栈，先把所有char入栈A，然后栈A的栈顶开始出栈，与栈B的栈顶元素进行匹配，如果匹配的上，栈B的栈顶元素就出栈，匹配不上则A栈刚刚出栈的元素压入栈B。当栈A为空时，如果栈B为空，则返回true，否则返回false；</p>
<p>事实证明该想法想的过于复杂，简单问题复杂化。</p>
<p>******只需要使用一个栈。<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/baa8829ac398e665eb645dca29eadd631e2b337e05022aa5a678e091471a4913-20.gif" srcset="/img/loading.gif" lazyload alt="20.gif" style="zoom: 50%;" /></p>
<p>这是一种办法。另一种办法是，当s.charAt（index） 出现左括号时，栈中压入对应的右括号。当出现右括号时，判断当前栈是否为空，为空return false，不为空则判断当前的char与栈顶元素是否相等，不相等就return false；</p>
<p>当所有元素遍历结束时，栈为空就返回true，否则返回false。</p>
<p>第二种相对难想到。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h4><p>第一种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//map的新用法</span><br>   	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Character,Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character,Character&gt;()&#123;&#123;<br>        put(<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-string">&#x27;&#125;&#x27;</span>); put(<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;]&#x27;</span>); put(<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;)&#x27;</span>); put(<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;?&#x27;</span>);<br>    &#125;&#125;;<br>		<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>		<span class="hljs-comment">//要一一匹配必须是偶数个字符</span><br>        <span class="hljs-keyword">if</span> (s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-comment">//如果是左括号就入栈</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(c)) &#123;<br>                stack.push(c);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果不是左括号，并且此时栈已经为空，也就是类似（）&#123;&#125;&#125; 这种情况，返回false</span><br>                <span class="hljs-comment">//如果栈不为空，但是此时的c和栈顶元素不相等，说明括号匹配不上，返回false</span><br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || c != map.get(stack.peek()))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//匹配的上则出栈，消掉一对括号</span><br>                stack.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最终如果栈为空则true</span><br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        Stack&lt;Character&gt; stack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s.toCharArray())&#123;<br>        	<span class="hljs-comment">//如果是左括号，则入栈对应的右括号</span><br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;[&#x27;</span>)<br>                stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-comment">//如果不是左括号，并且此时栈已经为空，也就是类似（）&#123;&#125;&#125; 这种情况，返回false</span><br>            <span class="hljs-comment">//如果栈不为空，但是此时的c和栈顶元素不相等，说明括号匹配不上，返回false</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.empty()||c!=stack.pop())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(stack.empty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="day-3"><a href="#day-3" class="headerlink" title="day 3"></a>day 3</h2><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/merge_ex1.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 50%;" />

<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span>		输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br>输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span>			输出：<span class="hljs-comment">[]</span><br>输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span>		输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure>

<h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>最开始看到题目想到的是新建第三个链表L3，然后将值依次填到L3中，应该可以实现。但是编码失败，问题出在函数出入口上，条件和语句顺序处理不好。（也有可能是直接用头节点往下遍历，应该在头节点前加一个pre节点）    <strong>最终实现了！！！ 之前没有实现的原因在于，没设pre节点，导致遍历结束之后多一个空节点</strong></p>
<p>上述方法的简化是，不用给L3填值，而是直接用一个pre节点，将L1，L2所有节点按照val的大小串起来，最终返回pre.next就行。</p>
<p>递归也可实现，使用递归时，考虑：递归的出口、子问题是什么。 理解较难，但是理解后就很通透。</p>
<h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>1、迭代：（使用L3）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prehead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//prev节点，使用prev就会简化很多过程</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> prehead;<br>       	<span class="hljs-comment">//没必要提前处理l1 或者 l2 为空，因为最终都要处理</span><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//l1的当前val小,则prev直接串上该节点，而不是赋值</span><br>            <span class="hljs-comment">//l1 后移</span><br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                prev.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            <span class="hljs-comment">//prev 后移，后移到哪无所谓</span><br>            prev = prev.next;<br>        &#125;<br>        <span class="hljs-comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br>        prev.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> prehead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、递归</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230422095516053.png" srcset="/img/loading.gif" lazyload alt="image-20230422095516053" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>		<span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            <span class="hljs-comment">//当l1的val小时，该节点就相当于被处理了</span><br>            <span class="hljs-comment">//只需要考虑l1和l2剩下的节点</span><br>            <span class="hljs-comment">//l1.next就是将该节点和剩下的节点连接起来</span><br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-comment">//当之后的所有节点处理完时，需要返回该节点，与之前的所有节点相连</span><br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="day-4"><a href="#day-4" class="headerlink" title="day 4"></a>day 4</h2><h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>		输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br>输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span>		输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure>

<h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>看到所有可能的组合，考虑使用回溯。这一类问题是在一棵隐式的树上求解。</p>
<p><strong>注意</strong>：在从空生成一个括号序列的过程中，左括号数量一定是大于等于右括号数量的。否则生成的括号组合是无效的。</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230423095529327.png" srcset="/img/loading.gif" lazyload alt="image-20230423095529327" style="zoom: 67%;" />

<p>可以分析出的结论：</p>
<p>当前左右括号数量都不为n的时候，才产生分支；<br>产生左分支的时候，只看当前左括号数量是否为n；<br>产生右分支的时候，还受到左分支的限制，右边的括号数量一定得在严格小于左边数量的时候，才可以产生分支；<br>在左边和右边的括号数都等于 n 的时候结算。</p>
<p>使用到剪枝函数。此思路学习某个答主的，甚妙甚妙。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/">https://leetcode.cn/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/</a></p>
<p>答主还有其他解法，有空再看。</p>
<h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//看到所有情况的时候，使用回溯</span><br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        dfs(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String cur, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> n, List&lt;String&gt; result)</span> &#123;<br>        <span class="hljs-comment">//设置递归出口</span><br>        <span class="hljs-keyword">if</span> (left == n &amp;&amp; right == n) &#123;<br>            result.add(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//当右括号多于左括号时，剪枝</span><br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>		<span class="hljs-comment">//此时，左括号数量一定大于右括号数量</span><br>        <span class="hljs-comment">//因此可以加上一个左括号，然后继续递归</span><br>        <span class="hljs-keyword">if</span> (left &lt; n) &#123;<br>            dfs(cur + <span class="hljs-string">&quot;(&quot;</span>, left + <span class="hljs-number">1</span>, right, n, result);<br>        &#125;<br>		<span class="hljs-comment">//右括号数量小于左括号数量</span><br>        <span class="hljs-keyword">if</span> (right &lt; n) &#123;<br>            dfs(cur + <span class="hljs-string">&quot;)&quot;</span>, left, right + <span class="hljs-number">1</span>, n, result);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>递归执行流程见上图箭头指向。</p>
<h2 id="day-5"><a href="#day-5" class="headerlink" title="day 5"></a>day 5</h2><h3 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a>23. 合并 K 个升序链表</h3><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br><br>输入：lists = []		输出：[]<br>输入：lists = [[]]		输出：[]<br><br></code></pre></td></tr></table></figure>

<h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>合并读个链表到一个链表中可以这样考虑：</p>
<p>（1）用一个目标链表和数组中的每一个链表进行合并，每次得到一个升序链表，再用这个升序链表和数组中的下一个合并，最终合并完所有的。这个思路相对简单，两个链表合并day 3也已经做过。（但是效率低）</p>
<p>（2）对（1）进行优化，分治，两两合并，两两合并…..最终子问题的结果汇总就是题目的解</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 50%;" />

<p>（3）优先队列：简单明了。一个队列中存放数组中每个链表的头节点，根据val的值进行优先级排序，val小的优先级高。每次优先级高的先出队，该节点指针向后移，将该链表的下一个节点放入队列中。</p>
<p>知道队列为空，所有的链表都处理完成。</p>
<h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>1、依次合并</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    <span class="hljs-keyword">for</span> (ListNode listNode:<br>         lists) &#123;<br>        <span class="hljs-comment">//result和数组中的每一项进行合并</span><br>        result = mergeTwo(result, listNode);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwo</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> l3;<br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>        pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>            pre.next = l1;<br>            l1 = l1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre.next = l2;<br>            l2 = l2.next;<br>        &#125;<br>        pre = pre.next;<br>    &#125;<br>    pre.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>    <span class="hljs-keyword">return</span> l3.next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、分治</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br><br>        <span class="hljs-comment">//两两配对进行合并，一直合并到只剩一个ListNode</span><br>        <span class="hljs-comment">//分治自顶向下，一层一层划分</span><br>        <span class="hljs-comment">//因此，从首尾开始，往下分解问题</span><br>        <span class="hljs-comment">//分解到只有单个节点时返回，然后进两两merge</span><br>        <span class="hljs-comment">//子问题的解交给上层，再进行两两merg</span><br>        <span class="hljs-comment">//最终得到问题的解</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lists.length;<br>        <span class="hljs-keyword">return</span> merg(lists, <span class="hljs-number">0</span>, length -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merg</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br><br>        <span class="hljs-comment">//递归出口</span><br>        <span class="hljs-comment">//子问题无法再分</span><br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> lists[l];<br>        &#125;<br>        <span class="hljs-comment">//防止出现[]这种情况，此时length为-1</span><br>        <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> mergeTwo(merg(lists, l, mid), merg(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwo</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> l3;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                pre.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            pre = pre.next;<br>        &#125;<br>        pre.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> l3.next;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>3、优先队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergKLists</span><span class="hljs-params">(ListNode[] list3)</span> &#123;<br>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> result;<br>    	<span class="hljs-comment">//优先队列，根据val的值，val值越小，对应的节点在队列中优先级越高</span><br>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(lists.length, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;ListNode&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(ListNode o1, ListNode o2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (o1.val &lt; o2.val) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1.val == o2.val) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>            &#125;<br>        &#125;);<br>		<span class="hljs-comment">//所有链表头节点入队</span><br>        <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            queue.add(node);<br>        &#125;<br>		<span class="hljs-comment">//队列为空代表结束</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-comment">//取出优先级最高的节点接在目标链表尾部，也就是val值最小的那个</span><br>            pre.next = queue.poll();<br>            <span class="hljs-comment">//取到出队节点的下一个节点</span><br>            pre = pre.next;<br>            /<br>            <span class="hljs-keyword">if</span> (pre.next != <span class="hljs-literal">null</span>)&#123;<br>                queue.add(pre.next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.next;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h3><p>arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</p>
<p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</p>
<h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><p>首先从后往前找，找出第一组nums[i] &lt; nums[i + 1], 此时，<strong>可以保证nums[i+1]以后是降序排列的。</strong></p>
<p>找到 nums[i] 后，就要把它往后换，换的那个数要比 nums[i] 大，并且保证它仅仅比 nums[i] 大，比 nums[i] 后边的其他数都小。  这样较为复杂，<strong>换个思路</strong>，    此时 nums[i] 后边已经是降序了，那么从 nums 末尾往前找第一个比nums[i] 大的就行。交换 nums[i] 和这个数， 然后将 i 位置后边的数重新升序排列。  </p>
<p>如果没找到 nums[i] &lt; nums[i + 1] ，直接将数组倒序输出就行</p>
<p>图解较为明显：</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150509405.png" srcset="/img/loading.gif" lazyload alt="image-20230425150509405" style="zoom: 50%;" />

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150532584.png" srcset="/img/loading.gif" lazyload alt="image-20230425150532584" style="zoom:50%;" />

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150544910.png" srcset="/img/loading.gif" lazyload alt="image-20230425150544910" style="zoom:50%;" />

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150600018.png" srcset="/img/loading.gif" lazyload alt="image-20230425150600018" style="zoom:50%;" />

<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230425150611569.png" srcset="/img/loading.gif" lazyload alt="image-20230425150611569" style="zoom:50%;" />

<h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>;<br>    	<span class="hljs-comment">//找到nums[i] 小于 nums[i + 1]</span><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>            i--;<br>        &#125;<br>    	<span class="hljs-comment">//i &gt;= 0 说明nums[i] &lt; nums[i + 1]存在</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//从末尾找第一个大于nums[i]的数</span><br>            <span class="hljs-comment">//此时可以保证是i以后的最小的满足条件的数</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//交换位置</span><br>            swap(nums, i, j);<br>        &#125;<br>    	<span class="hljs-comment">//然后将 i 位置以后的进行升序排序</span><br>    	<span class="hljs-comment">//如果此时 i &lt; 0 ，说明nums本来就已经是降序，是最大的组合。</span><br>    	<span class="hljs-comment">//因此返回 最小的组合 </span><br>        reverse(nums, i + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br>	<span class="hljs-comment">//因为已经保证了 i 位置以后是降序，则只需要前后不断交换就行</span><br>	<span class="hljs-comment">//不需要双层循环</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            swap(nums, left, right);<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h3><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(()&quot;</span>	输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br><br>输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;)()())&quot;</span>		输出：<span class="hljs-number">4</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()()&quot;</span><br><br>输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>出现有关括号这种匹配问题的字眼，考虑用栈。该题就是在  day 2 20.有效的括号  那一题的基础上进行求解。</p>
<p>也就是说，字符串从前往后遍历，看哪些连着的字串能够匹配起来，匹配成功长度就增加，然后在所有能够匹配的相连子串中，找到最长的那个。</p>
<p><strong>该题目稍微有点不同的是</strong>，入栈的不是括号而是对应的下标。 这样，就可以相对轻松的计算出能够匹配的子串的长度</p>
<p>描述一下算法流程：遍历给定的字符串，取每一位上的字符，首先，判断该字符是 ‘(‘ 还是 ‘)’ ，如果是左括号，那就直接下标入栈，因为左括号不可能与前边的字符匹配。如果是右括号，则取出栈顶元素n， 判断 s.charAt(n) 是不是左括号，是就说明这两个匹配成功，成功就出栈，并用当前右括号的下标减去出栈后栈顶元素的数值（也就是没能匹配上的最后一个字符的下标），这样就计算出了当前相连的有效的子串的长度。然后继续往后，如果又有有效的子串，则又计算出它的长度，如果比之前的子串长，则选择这个。   直到遍历完整个字符串。</p>
<h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longestValidParentheses2</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//定义栈</span><br>	Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>	<span class="hljs-comment">//最长有效子串长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//因为如果第一个字符就是 ) ，那么就需要出栈，但是此时栈为空就会出错</span><br>    <span class="hljs-comment">//所以提前入栈一个-1</span><br>   	<span class="hljs-comment">//还有一个作用是，当有效的子串在整个字符串首部时</span><br>    <span class="hljs-comment">//需要用最后一个匹配的字符的下标减去栈顶元素，设置为-1才能满足条件</span><br>	stack.push(-<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">//遍历每一个字符</span><br>		<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-comment">//如果是左括号说明不满足条件，直接入栈</span><br>		<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.peek();<br>            <span class="hljs-comment">//是右括号时，取出栈顶元素，判断是不是左括号，如果是则匹配成功，计算目前有效的子串的长度</span><br>            <span class="hljs-comment">//判断top等不等于-1的目的是看当前栈是不是为空</span><br>			<span class="hljs-keyword">if</span> (top != -<span class="hljs-number">1</span> &amp;&amp; s.charAt(top) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>				stack.pop();<br>                <span class="hljs-comment">//在所有有效的子串中拿最长的</span><br>				length = (i - stack.peek()) &gt; length ? i - stack.peek() : length;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果栈顶元素不是左括号说明匹配失败，则直接入栈</span><br>				stack.push(i);<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			stack.push(i);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> length;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h3><p>整数数组 <code>nums</code> 原本按升序排列，数组中的值 <strong>互不相同</strong> 。然后从某个位置阶段，将前边的部分拼接到后边。</p>
<p>给定一个target，在数组中查找，如果有，返回下标，没有返回-1。时间复杂度要求为 <code>O(log n)</code></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>		输出：<span class="hljs-number">4</span><br>输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">3</span>		输出：<span class="hljs-number">-1</span><br>输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>		输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>

<h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>升序或者降序的数组中查找一个数，并且要求时间复杂度是<code>O(log n)</code>，就要使用二分查找。</p>
<p>但是这个题目是升序数组变换得到的，因此需要在二分查找的基础上进行补充修饰。</p>
<p>考虑，尽管这个数组已经不是升序数组了，但是，如果从中间截断，那么前半段和后半段一定有一个仍然是升序。所以针对前半段是升序和后半段是升序两种情况进行分别处理。 判断前半段是升序的条件是 nums[0] &lt;&#x3D; nums[mid] ，（因为数组中的值互不相同，因此这里的 &#x3D; 是针对只有两个数的情况）。</p>
<p>判断target是在升序段还是非升序段，如果在升序段直接使用二分查找。如果是在非升序段，则继续二分，看哪段是升序，…..一直到找到target，或者是l  &gt; r，说明没找到。程序结束</p>
<h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>		<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//找到了</span><br>            <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-comment">//前半部分有序的情况</span><br>            <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt;= nums[mid]) &#123;<br>                <span class="hljs-comment">//说明target在有序的前半部分</span><br>                <span class="hljs-comment">//直接使用二分查找</span><br>                <span class="hljs-keyword">if</span> (target &gt;= nums[<span class="hljs-number">0</span>] &amp;&amp; target &lt; nums[mid]) &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//说明target不在前半部分</span><br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;		<span class="hljs-comment">//后半部分有序的情况</span><br>				<span class="hljs-comment">//说明target在后半部分</span><br>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[r]) &#123;     <br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8		输出：<span class="hljs-comment">[3,4]</span><br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6		输出：<span class="hljs-comment">[-1,-1]</span><br>输入：nums = <span class="hljs-comment">[]</span>, target = 0		输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure>

<h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><p>在数组中查找元素并且要求<code>O(log n)</code>的时间复杂度，用二分查找。</p>
<p>这个题有点变化的就是目标元素可能不止一个。 </p>
<p>解法一：用二分查找找到一个目标元素，然后向两边扩散，直到找到所有的目标元素，之后返回起始位置和结束位置。 如果target元素很多，甚至于整个数组都是target，则算法退化到 <code>O(n)</code>。</p>
<p>解法二：用二分查找找到第一个等于目标元素的，再二分查找找到第一个大于目标元素的（也就是找第一个大于等于 target + 1 的），然后就得到了解。（思路容易理解，但是编码不太容易理解）</p>
<h4 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h4><p>解法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right + left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//找到了任意一个目标元素</span><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                left = mid - <span class="hljs-number">1</span>;<br>                right = mid + <span class="hljs-number">1</span>;<br> 				<span class="hljs-comment">//向左扩散</span><br>                <span class="hljs-keyword">while</span> (left &gt;=<span class="hljs-number">0</span> &amp;&amp; nums[left] == target) &#123;<br>                    left--;<br>                &#125;<br>                <span class="hljs-comment">//向右扩散</span><br>                <span class="hljs-keyword">while</span> (right &lt;= nums.length - <span class="hljs-number">1</span> &amp;&amp; nums[right] == target) &#123;<br>                    right++;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;++left, --right&#125;;<br>            &#125;<br>            <span class="hljs-comment">//二分查找</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    	<span class="hljs-comment">//没找到就返回[-1, -1]</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>解法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] searchRange2(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>		<span class="hljs-comment">//查找大于等于target的第一个元素，如果target存在，返回的就是开始位置，如果不存在，返回的是第一		  //个比target大的元素的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> binarySearch(nums, target);<br>    	<span class="hljs-comment">//查找大于target的第一个元素（即大于等于 target + 1 的第一个元素）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> (binarySearch(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>);<br>    	<span class="hljs-comment">//如果查到的位置满足左小于等于右，并且开始和结束位置的元素都是target，则证明查找成功，返回</span><br>        <span class="hljs-keyword">if</span> (begin &lt;= end &amp;&amp; nums[begin] == target &amp;&amp; nums[end] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;begin, end&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>                ans = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7		输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure>

<h4 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h4><p>所有组合，出现类似字眼考虑回溯。画出解空间树：</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/1598091943-hZjibJ-file_1598091940241.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 25%;" />

<p>从根节点出发，将所有小于根节点大小的candidates元素作为子节点，小于就说明该子节点可能是有效解的一部分，将该子节点数值加入res中，此时target变成 target - 该子节点 ，然后以该子节点为根节点重复上述过程，直到叶子节点。达到叶子节点时有两种情况，一种是target恰好为零，说明此时res中的所有节点大小加起来刚好是原始的target，则是一个有效的解。另一种情况是target不为零，则不是有效解，此时需要回到当前叶子节点的父节点，也就是回溯，需要把当前叶子节点从res中删除。深度优先搜索直到拿到所有有效解。</p>
<p>这里存在一个问题是，[2, 2, 3] 和 [3, 2, 2] 这两条路径是重复的解，需要处理。如何处理呢？ 因为确定子节点的时候是遍历candidates数组，因此在确定该节点的子节点时，要排除掉该节点之前的兄弟节点。（因为之前的兄弟节点在求解过程中，肯定会将该节点作为子节点）</p>
<h4 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>      List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     	<span class="hljs-comment">//start的作用就是在确定某个节点子节点的时候，排除掉之前出现过的兄弟节点</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      dfs(candidates, target, res, ans, start);<br>      <span class="hljs-keyword">return</span> ans;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, List&lt;Integer&gt; res, List&lt;List&lt;Integer&gt;&gt; ans, <span class="hljs-type">int</span> start)</span> &#123;<br>      <span class="hljs-comment">//递归出口</span><br>      <span class="hljs-comment">//此时target变为了0，说明此路径上的所有节点值加起来为target，是一个有效解</span><br>      <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">//不能使用ans.add(res)</span><br>          <span class="hljs-comment">//因为res是地址，虽然地址一直不会变</span><br>          <span class="hljs-comment">//但是由于回溯的原因，res的内容最终为[]</span><br>          ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(res));<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><span class="hljs-comment">//i = start 就排除了已经处理过的兄弟节点</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; i++) &#123;<br>          <span class="hljs-comment">//满足成为有效解一部分的条件</span><br>          <span class="hljs-keyword">if</span> (candidates[i] &lt;= target) &#123;<br>              res.add(candidates[i]);<br>              dfs(candidates, target - candidates[i], res, ans, i);<br>              <span class="hljs-comment">//回溯</span><br>              res.remove(res.size() - <span class="hljs-number">1</span>);<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>



<h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span>		输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br>输入：nums = <span class="hljs-comment">[0,1]</span>		输出：<span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure>

<h4 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h4><p>所有可能的全排列，考虑回溯。</p>
<p>执行过程</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">  递归之前 =&gt; <span class="hljs-comment">[1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 2, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[1, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 3, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[1, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[1]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 1, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[2, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 3, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[2, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[2]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 1, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[3, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 2, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[3, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[3]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>输出 =&gt; <span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>, <span class="hljs-comment">[1, 3, 2]</span>, <span class="hljs-comment">[2, 1, 3]</span>, <span class="hljs-comment">[2, 3, 1]</span>, <span class="hljs-comment">[3, 1, 2]</span>, <span class="hljs-comment">[3, 2, 1]</span>]</span><br></code></pre></td></tr></table></figure>



<h4 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>      <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      &#125;<br>      List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      dfs(nums, ans, res, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;Integer&gt; ans, List&lt;List&lt;Integer&gt;&gt; res, <span class="hljs-type">boolean</span>[] used, <span class="hljs-type">int</span> size)</span> &#123;<br>      <span class="hljs-comment">//递归出口，size代表遍历解空间树的深度</span><br>      <span class="hljs-keyword">if</span> (size == nums.length) &#123;<br>          res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(ans));<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><span class="hljs-comment">//每次递归i都要从0开始</span><br>      <span class="hljs-comment">//这样才能让nums中的每一个元素都能做ans的头元素</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>          <span class="hljs-comment">//判断当前元素是不是已经被加入了ans中</span><br>          <span class="hljs-comment">//也可以使用used[]数组表示当前元素是否被使用过  来代替 contains</span><br>          <span class="hljs-keyword">if</span> (!ans.contains(nums[i])) &#123;<br>              <span class="hljs-comment">//如果没有则加入，并递归搜索子树</span><br>              ans.add(nums[i]);<br>              dfs(nums, ans, res, used, size + <span class="hljs-number">1</span>);<br>              <span class="hljs-comment">//回溯</span><br>              ans.remove(ans.size() - <span class="hljs-number">1</span>);<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>



<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230502101338537.png" srcset="/img/loading.gif" lazyload alt="image-20230502101338537" style="zoom: 50%;" />

<h4 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h4><ol>
<li>使用一个额外的矩阵进行转换，观察发现第一行变成了最后一列，第二行变成了倒数第二列…..</li>
<li>先将矩阵上下翻转，然后对角翻转</li>
</ol>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230502101554478.png" srcset="/img/loading.gif" lazyload alt="image-20230502101554478" style="zoom:50%;" />

<h4 id="题解：-11"><a href="#题解：-11" class="headerlink" title="题解："></a>题解：</h4><p>1、额外矩阵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>    	<span class="hljs-comment">//矩阵的第一行变成了倒数第一列，第二行变成了倒数第二列....</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                res[j][n - i - <span class="hljs-number">1</span>] = matrix[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                matrix[i][j] = res[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>2、原地变换翻转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> matrix.length;<br>    	<span class="hljs-comment">//上下翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[length - i - <span class="hljs-number">1</span>][j];<br>                matrix[length - i - <span class="hljs-number">1</span>][j] = temp;<br>            &#125;<br>        &#125;<br>    	<span class="hljs-comment">//沿对角线翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; length; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure>

<h4 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h4><p>字母异位体排列虽有不同，但是组成的字符种类（只有小写字母）以及各个字符的数量是完全一致的，因此可以考虑：</p>
<ol>
<li>将字符串的所有字符进行排序，这样的话只要时字母异位体，排序后是完全一样的，对应的哈希值也是一样的。这时就可以使用HashMap，将排序后hash值相同的字符串收集在一块。</li>
<li>统计26个字母每一个的数量，最终所有字母的数量都相等的字符串收集在一起</li>
</ol>
<h4 id="题解：-12"><a href="#题解：-12" class="headerlink" title="题解："></a>题解：</h4><p>1、hash</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br><br>    Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <br>    <span class="hljs-keyword">for</span> (String str :<br>            strs) &#123;<br>        <span class="hljs-comment">//字符串转为char数组</span><br>        <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>        <span class="hljs-comment">//排序</span><br>        Arrays.sort(chars);<br>        <span class="hljs-comment">//重新转为String，因为相同内容的String哈希值相同，而相同内容的char数组哈希值不同</span><br>        s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>        <span class="hljs-comment">//如果此哈希值已经有先例，则拿出对应的List</span><br>        <span class="hljs-comment">//如果没有，即此字符串是第一次，则新建一个ArrayList</span><br>        <span class="hljs-comment">//getsOrDefault方法：如果key有对应的value，则返回，如果没有，则返回设定的默认值</span><br>        List&lt;String&gt; list = map.getOrDefault(s, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-comment">//注意，add的是str，而不是s</span><br>        list.add(str);<br>        <span class="hljs-comment">//key设置的是排序后的zi&#x27;fu&#x27;hcu	</span><br>        map.put(s, list);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h2><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]		输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure>

<h4 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h4><p>1、暴力解，求出该数组每一个子数组的和，取最大值，但这样时间复杂度太高。</p>
<p>2、动态规划：</p>
<p>求解出以数组中每一个元素为结尾的最大连续子数组和dp[i] ，例如 以 -2 为结尾的最大连续子数组 dp[0] 和为 -2 ， 以 1 为结尾的最大连续子数组和 dp[1] 为 1 （因为前边以 -2 为结尾的最大连续子数组和小于0 ）….</p>
<p>总结规律发现，以 nums[i] 为结尾的最大连续子数组和 dp[i] ，取值取决于以 nums[i-1] 为结尾的最大连续子数组和 dp[i-1] ， 当 dp[i -1] &gt; 0 时，dp[i] &#x3D; dp[i-1] + nums[i] ;  当 dp[i-1] &lt;&#x3D; 0 时， dp[i] &#x3D; nums[i] ;</p>
<p>这样的话，我们自底向上，保存每一个子问题解的 dp[i] , 最终取其中的最大值，就可以求出问题的解。</p>
<h4 id="题解：-13"><a href="#题解：-13" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    	<span class="hljs-comment">//以第一个元素为结尾的连续子数组的和</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-comment">//这个子问题的解依赖于上一个子问题的解</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? dp[i - <span class="hljs-number">1</span>] + nums[i] : nums[i];<br>            res = dp[i] &gt; res ? dp[i] : res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>优秀解答：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/</a></p>
<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>如果能到达每一个下标，则该下标之前的所有下标都可以达到。</p>
<p>从前往后遍历，更新整个数组能达到的最远距离，如果最远距离大于等于数组 length - 1 ，则说明能够到达最后一个下标。</p>
<h4 id="题解：-14"><a href="#题解：-14" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">//到达的最远位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= len - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">//如果此时遍历到的位置 i 已经大于 该数组能达到的最远距离maxIndex，说明越界了，直接返回				//false</span><br>        <span class="hljs-keyword">if</span> (i &gt; maxIndex) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//取最远的距离</span><br>        maxIndex = Math.max(i + nums[i], maxIndex);<br>        <span class="hljs-comment">//如果能够到达的最远位置已经超过了数组结尾，则直接返回true</span><br>        <span class="hljs-comment">//不要该判断也可以，只要 i 能遍历到数组结尾，说明成功了</span><br>        <span class="hljs-comment">//这个判断的作用在于满足条件后直接返回，免去了后续</span><br>        <span class="hljs-keyword">if</span> (maxIndex &gt;= len - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    	<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure>

<h4 id="思路：-15"><a href="#思路：-15" class="headerlink" title="思路："></a>思路：</h4><p>首先把intervals数组按每个区间开始的值从小打到排列。新造一个数组 res[][] 用来存放答案，先把第一个区间赋值给 res[0] ，然后，遍历剩下的所有区间。判断每一个区间的开始是否小于等于 res[index] 的结束，是的话说明该区间和 res[index] 区间有重合，则合并，将 res[index] 的结束更新为这两个重合区间的最右边。如果不是则说明不重合，index++，直接将该区间赋值给res[index] </p>
<h4 id="题解：-15"><a href="#题解：-15" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge1(<span class="hljs-type">int</span>[][] intervals) &#123;<br>    	<span class="hljs-comment">//先把intervals排序</span><br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intervals.length][<span class="hljs-number">2</span>];<br>    	<span class="hljs-comment">//先把第一个区间赋值给 res[0] </span><br>        res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        res[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= intervals.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">//有重合</span><br>            <span class="hljs-keyword">if</span> (res[index][<span class="hljs-number">1</span>] &gt; intervals[i][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-comment">//区间的末尾取最右边</span><br>                res[index][<span class="hljs-number">1</span>] = Math.max(intervals[i][<span class="hljs-number">1</span>], res[index][<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//没重合</span><br>                index++;<br>                res[index][<span class="hljs-number">0</span>] = intervals[i][<span class="hljs-number">0</span>];<br>                res[index][<span class="hljs-number">1</span>] = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    	<span class="hljs-comment">//可以使用 res = Arrays.copyOfRange(res, 0, index+1);  替换</span><br>    	<span class="hljs-comment">//但是Arrays.copyOfRange费时</span><br>        <span class="hljs-type">int</span>[][] res1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[index + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index + <span class="hljs-number">1</span>; i++) &#123;<br>            res1[i] = res[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res1;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/robot_maze.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span>			输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure>

<h4 id="思路：-16"><a href="#思路：-16" class="headerlink" title="思路："></a>思路：</h4><p>1、动态规划</p>
<p>从Finish往回看，可以走到Finish的只有上和左两个方块，因此到Finish的路径数量就等于 两个方块的路径和。….所以子问题就分析出来，求到某个块的路径数量，只需要求前置块的路径数量，然后加和。</p>
<p>边界就是起点。 需要注意的是，最上面和最左边的一行一列，所有块的路径数量都是1。</p>
<p>2、数学公式</p>
<p>因为规定了只能往下和往右，因此无论怎样走，向下走的都是3-1格，向右走的都是7-1格，总共是走8格。</p>
<h1 id="所以只需要在8格中任意选两个向下就可以列出所有结果。-C-m-n-2-m-1"><a href="#所以只需要在8格中任意选两个向下就可以列出所有结果。-C-m-n-2-m-1" class="headerlink" title="所以只需要在8格中任意选两个向下就可以列出所有结果。$$C_{m+n-2}^{m-1}"></a>所以只需要在8格中任意选两个向下就可以列出所有结果。<br>$$<br>C_{m+n-2}^{m-1}</h1><h1 id="m-n−2-m-n−3-⋯n-over-m−1"><a href="#m-n−2-m-n−3-⋯n-over-m−1" class="headerlink" title="{(m+n−2)(m+n−3)⋯n\over(m−1)!}"></a>{(m+n−2)(m+n−3)⋯n<br>\over(m−1)!}</h1><p>{(m−1)!(n−1)!<br>\over(m+n−2)!}<br>$$</p>
<h4 id="题解：-16"><a href="#题解：-16" class="headerlink" title="题解："></a>题解：</h4><p>1、动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">//最上面一行</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//最左边一列</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//上面的块和左边的块的路径和为当前块的路径和</span><br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、数学公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> n, y = <span class="hljs-number">1</span>; y &lt; m; ++x, ++y) &#123;<br>            ans = ans * x / y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ans;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h3><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。	<strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/minpath.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span>		输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure>

<h4 id="思路：-17"><a href="#思路：-17" class="headerlink" title="思路："></a>思路：</h4><p>动态规划</p>
<h4 id="题解：-17"><a href="#题解：-17" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = grid[i][j];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + grid[i][j];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + grid[i][j];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure>

<h4 id="思路：-18"><a href="#思路：-18" class="headerlink" title="思路："></a>思路：</h4><p>最简单的动态规划问题</p>
<h4 id="题解：-18"><a href="#题解：-18" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">//简化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            res = p + q;<br>            p = q;<br>            q = res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h3><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<h4 id="思路：-19"><a href="#思路：-19" class="headerlink" title="思路："></a>思路：</h4><p>1、两次遍历，设置有序界限index。第一次将所有的 0 移动到头部，每次移动更新 index的值。第二次将所有的 1 移动到 0 后面。</p>
<p>2、一次遍历，两个指针。设置指针p0、p1，初始值为0，代表 0 和 1 的放置位置。遍历时，如果 nums[i] 为 0 则与 nums[p0] 交换；如果为1， 则先判断 p1 &gt; p0 是否成立，不成立先令 p1 &#x3D; p0 , 然后交换 nums[i] 和 nums[p1] 。因为如果 p1 &lt;&#x3D; p0 , 说明前边都是 0 ，p1首先需要移动到 0 后面。</p>
<h4 id="题解：-19"><a href="#题解：-19" class="headerlink" title="题解："></a>题解：</h4><p>1、两次遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//把 0 放在最头部</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index];<br>                nums[index] = nums[i];<br>                nums[i] = temp;<br>                index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 1 放在 0 后面</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index];<br>            nums[index] = nums[i];<br>            nums[i] = temp;<br>            index++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、两个指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>         <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>             nums[i] = nums[p0];<br>             nums[p0++] = temp;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>             <span class="hljs-keyword">if</span> (p1 &lt; p0) &#123;<br>                 p1 = p0;<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                 nums[i] = nums[p1];<br>                 nums[p1++] = temp;<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>



<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a></h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure>



<h4 id="思路：-20"><a href="#思路：-20" class="headerlink" title="思路："></a>思路：</h4><p>看到 <strong>所有</strong> 这类的字眼，考虑回溯，这个题目需要将解空间树的每一个节点都保存下来。</p>
<h4 id="题解：-20"><a href="#题解：-20" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//空集</span><br>    res.add(list);<br>    dfs2(res, list, nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;nn<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs2</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">//叶子节点之后就返回</span><br>    <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//每一个节点都要保存</span><br>        list.add(nums[i]);<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(list));<br>        <span class="hljs-comment">//递归该节点的子树</span><br>        dfs(res, list, nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//回溯</span><br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230505174059190.png" srcset="/img/loading.gif" lazyload alt="image-20230505174059190" style="zoom:50%;" />

<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure>



<h4 id="思路：-21"><a href="#思路：-21" class="headerlink" title="思路："></a>思路：</h4><p>深度优先搜索 + 回溯</p>
<p>先找出 board 中所有跟 word 第一个字符相等的位置，进入深度优先递归搜索环节，每到一个位置，上下左右判断有没有跟 word 下一个字符相等的，有就再搜索，直到搜索的深度等于 word 的长度，说明搜索到了，设置标志位为1 ，不能直接return true ；因为return是给上一层调用者，而不是返回最终结果。   因为题目说字母不能重复使用，因此设置 isUsed 二维数组，为0代表board该位置未使用过。</p>
<h4 id="题解：-21"><a href="#题解：-21" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> board.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>            <span class="hljs-comment">//每次从头查找isUsed数组都要重新归零</span><br>            <span class="hljs-type">int</span>[][] isUsed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row][col];<br>            <span class="hljs-comment">//找到了word的第一个字符</span><br>            <span class="hljs-keyword">if</span> (word.charAt(<span class="hljs-number">0</span>) == board[i][j]) &#123;<br>                <span class="hljs-comment">//表示该位置已被使用</span><br>                isUsed[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//递归搜索</span><br>                dfs(board, word, i, j, <span class="hljs-number">1</span>, flag, isUsed);<br>                <span class="hljs-comment">//如果 flag[0] 被修改为 1， 说明搜索过程中一定找到过 word</span><br>                <span class="hljs-keyword">if</span> (flag[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] flag, <span class="hljs-type">int</span>[][] isUsed)</span> &#123;<br>    <span class="hljs-comment">//查找的深度等于word的长度，说明找到了</span><br>    <span class="hljs-keyword">if</span> (index == word.length()) &#123;<br>        flag[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//往左走</span><br>    <span class="hljs-comment">//往左走时需要注意：左边还有没有，左边的字符等不等于word的下一个字符，左边的字符有没有被使用过</span><br>    <span class="hljs-comment">//往左往右往上往下这四步可以优化，简化写法和执行流程，但是本人懒得搞了</span><br>    <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; board[i][j - <span class="hljs-number">1</span>] == word.charAt(index) &amp;&amp; isUsed[i][j-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>        isUsed[i][j-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dfs(board, word, i, j - <span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>, flag, isUsed);<br>        <span class="hljs-comment">//回溯时，回溯的位置需要重新标识为未使用</span><br>        isUsed[i][j-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//往右走</span><br>    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= board[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> &amp;&amp; board[i][j + <span class="hljs-number">1</span>] == word.charAt(index) &amp;&amp; isUsed[i][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>        isUsed[i][j+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dfs(board, word, i, j+<span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>, flag, isUsed);<br>        isUsed[i][j+<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//往上走</span><br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; board[i - <span class="hljs-number">1</span>][j] == word.charAt(index) &amp;&amp; isUsed[i-<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>) &#123;<br>        isUsed[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        dfs(board, word, i - <span class="hljs-number">1</span>, j, index + <span class="hljs-number">1</span>, flag, isUsed);<br>        isUsed[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//往下走</span><br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt;= board.length - <span class="hljs-number">1</span> &amp;&amp; board[i + <span class="hljs-number">1</span>][j] == word.charAt(index) &amp;&amp; isUsed[i+<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>) &#123;<br>        isUsed[i+<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        dfs(board, word, i + <span class="hljs-number">1</span>, j, index + <span class="hljs-number">1</span>, flag, isUsed);<br>        isUsed[i+<span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<h4 id="思路：-22"><a href="#思路：-22" class="headerlink" title="思路："></a>思路：</h4><p>二叉树遍历就是递归，先序、中序、后续几乎一样，只是保存值的位置有点区别。</p>
<h4 id="题解：-22"><a href="#题解：-22" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            search(root, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">(TreeNode node, List&lt;Integer&gt; res)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//遍历左子树</span><br>        search(node.lft, res);<br>		<span class="hljs-comment">//保存</span><br>        res.add(node.val;<br>        <span class="hljs-comment">//遍历右子树</span><br>        search(node.rght(), res);<br>    &#125;<br>                <br>                <br><span class="hljs-comment">//先序</span><br>        res.add(node.val);<br>       	search(node.lft, res);<br>        search(node.rght(), res);<br>                <br><span class="hljs-comment">//后序</span><br><br>       	search(node.lft, res);<br>        search(node.rght(), res);<br>        res.add(node.val);<br></code></pre></td></tr></table></figure>



<h2 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<img src="%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20230508112035813.png" srcset="/img/loading.gif" lazyload alt="image-20230508112035813" style="zoom:50%;" />

<h4 id="思路：-23"><a href="#思路：-23" class="headerlink" title="思路："></a>思路：</h4><p>二叉搜索树：从根节点，大的在左子树，小的在右子树。</p>
<p>n个节点组成二叉搜索树，首先，n个节点每一个都可以作为根节点。当 i 作为根节点时，从1 - （i-1）都在左子树，（i+1） - n 都在右子树。考虑此时的左子树，从 1 - （i-1）都可以作为根节点，依次往下，每层子树的构建过程的一样。最终会到叶子节点，0个左子树，0个右子树。 是一个动态规划问题。子问题的解结合起来构成问题的解。</p>
<p>设 G(n) 是 n 个节点可以组成的二叉树搜索树的个数。</p>
<p>设 F(i) 是以 i 为根节点，n个节点可以组成的二叉搜索树的个数。</p>
<p>可以发现，G(n) &#x3D; F(1) + F(2) + ······ + F(n) </p>
<p>而 F(i) &#x3D; G(i-1) * G(n-i)          <strong>原因</strong>：以 i 为节点时， 左子树有 i-1 个节点，这 i-1 个节点可以组成 G(i-1) 个二叉搜索树。右子树有 n-i 个节点，这 n-i 个节点可以组成 G(n-i) 个二叉搜索树。因此，以 i 为根节点的二叉搜索树的个数是 左子树个数 乘以 右子树个数</p>
<p>因此  G(n) &#x3D; G(1-1)G(n-1) + G(2-1)G(n-2) + ······ + G(n-1)G(n-n)</p>
<p>要求 G(n) 必须先求 G(n-1) G(n-2) ·····G(2) G(1) G(0)</p>
<p>要求 G(n-1) 必须先求 G(n-2) G(n-3) ······ G(1) G(0)</p>
<p>······  因此，这是一个动态规划问题，G(0)、G(1) 很明显为 1 (<strong>备注：G(0) 为1是因为左边没有子树也算一种情况</strong>) </p>
<p>,G(2) 可以由 G(1)、G(0) 求得，G(3) 可以由 G(2)、G(1)、G(0) 求得 ·······</p>
<h4 id="题解：-23"><a href="#题解：-23" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span>[] G = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>      <span class="hljs-comment">//已知的</span><br>      G[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      G[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//从G(2)开始算起，一直算到G(n),只有G(i-1)知道了，才能求解G(i)</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>              G[i] += G[j - <span class="hljs-number">1</span>] * G[i - j];<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> G[n];<br>  &#125;<br></code></pre></td></tr></table></figure>



<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<h4 id="思路：-24"><a href="#思路：-24" class="headerlink" title="思路："></a>思路：</h4><p>1、广度优先遍历 BFS，使用队列，每一层从左到右入队，出队时下面一层又入队。</p>
<p>2、使用map，dep记录当前节点所处的深度，遍历所有节点，同一深度的所有节点使用 map.put(dep, list) 加到同一个List中。最后，拿出map中所有的key。</p>
<h4 id="题解：-24"><a href="#题解：-24" class="headerlink" title="题解："></a>题解：</h4><p>1、BFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-comment">//广度优先遍历 -&gt; 使用队列</span><br>       List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>       queue.offer(root);<br>       <span class="hljs-comment">//队列不为空就一直出队</span><br>       <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>           List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           <span class="hljs-comment">//队列中当前的节点数</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>           <span class="hljs-comment">//这些节点都位于同一层</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>               list.add(node.getVal());<br>               <span class="hljs-keyword">if</span> (node.getLeft() != <span class="hljs-literal">null</span>) &#123;<br>                   queue.offer(node.getLeft());<br>               &#125;<br>               <span class="hljs-keyword">if</span> (node.getRight() != <span class="hljs-literal">null</span>) &#123;<br>                   queue.offer(node.getRight());<br>               &#125;<br>           &#125;<br>           res.add(list);<br>       &#125;<br>       <br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>2、记录深度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      dfs(root, map, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">for</span> (List&lt;Integer&gt; value : map.values()) &#123;<br>          res.add(value);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, Map&lt;Integer, List&lt;Integer&gt;&gt; map, <span class="hljs-type">int</span> dep)</span> &#123;<br>      <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//深度增加</span><br>      dep++;<br><span class="hljs-comment">//当前深度对应的list,如果没有就新建一个</span><br>      List&lt;Integer&gt; integers = map.getOrDefault(dep, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>      integers.add(node.getVal());<br>      map.put(dep, integers);<br><br>      dfs(node.getLeft(), map, dep);<br>      dfs(node.getRight(), map, dep);<br>  &#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2023/11/09/算法笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lpx</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/09/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/09/%E5%85%AB%E8%82%A1%E9%A2%98%E7%9B%AE/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"CdrmGVSpBdC5RxmCwvpa4qZB-gzGzoHsz","appKey":"7s5o0uXg54vyI98408Q967HX","path":"window.location.pathname","placeholder":"说点啥子~","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问次数 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访问人数 
        <span id="leancloud-site-uv"></span>
         次
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
